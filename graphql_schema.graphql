type Query {
  """
  [PUBLIC] Get the current API version.
  Used by clients to check compatibility and feature availability.
  """
  apiVersion: String!

  "[PUBLIC] Get comprehensive API version information including supported and deprecated versions."
  apiVersionInfo: ApiVersionInfo!

  "[PUBLIC] Check compatibility between client version and current API."
  checkApiCompatibility(clientVersion: String!): CompatibilityCheck!

  """
  [PUBLIC] Validate an invitation token before accepting.
  Returns information about the invitation and whether the user already exists.
  No authentication required - the invitation token itself serves as authorization.
  """
  validateInvitation(
    "The invitation token from the invitation email."
    token: String!
  ): InvitationValidationResult!

  """
  [PUBLIC] Resolve NFC tag URL to active order.
  Entry point for guest NFC taps - no authentication required.
  Rate limited to prevent abuse (30/min per IP, 100/min per organization).
  """
  resolveNFCTag(
    "Organization UUID or slug from the NFC URL."
    organizationSlug: String!

    "Location slug or ID from the NFC URL."
    locationSlug: String!

    "Table local_id (number) from the NFC URL."
    tableNumber: Int!
  ): NFCResolutionResult!

  """
  [PUBLIC] Resolve NTAG 424 DNA tag with cryptographic signature verification.
  Entry point for guest taps on DNA-enabled NFC tags.
  URL format: https://splt.ca/t?uid=xxxxxxxxxxxxxx&ctr=xxxxxx&mac=xxxxxxxxxxxxxxxx
  
  This endpoint:
  1. Validates the CMAC signature using the tag's SDM key
  2. Verifies the counter is higher than last seen (anti-replay)
  3. Resolves the tag to its registered table and active order
  
  Rate limited to prevent abuse (30/min per IP, 100/min per UID).
  """
  resolveNFCTagDNA(
    "Tag UID as 14-character hex string (e.g., '040F67BA851B90')."
    uid: String!

    "Read counter as 6-character hex string (e.g., '000001')."
    ctr: String!

    "CMAC signature as 16-character hex string."
    mac: String!
  ): NFCDNAResolutionResult!

  """
  [PUBLIC] Get the current version of a legal document by type.
  Returns the active published version for the specified document type and locale.
  Used by all clients to display legal documents (privacy policy, terms, etc.).
  """
  legalDocument(
    "The type of legal document to retrieve."
    type: LegalDocumentType!

    "Language code (default: 'en')."
    locale: String = "en"
  ): LegalDocument

  """
  [PUBLIC] List all current legal documents.
  Returns all active legal documents for building a legal index page or settings screen.
  """
  legalDocuments(
    "Language code (default: 'en')."
    locale: String = "en"
  ): [LegalDocument!]!

  """
  [PUBLIC] Get version history for a legal document type.
  Returns all published versions of a document, newest first.
  """
  legalDocumentHistory(
    "The type of legal document."
    type: LegalDocumentType!

    "Language code (default: 'en')."
    locale: String = "en"
  ): [LegalDocument!]!

  """
  Get all organization memberships for the current user.
  Requires the user to be logged into an organization.
  """
  myOrganizations: [UserOrganizationMembership!]!

  """
  Retrieve the complete permissions matrix for a specific user.
  Shows all permissions the user has across different contexts.
  """
  getUserPermissionsMatrix(userId: ID!): UserPermissionMatrix!

  """
  Get metadata (title and description) for all available permissions.
  This provides human-readable information about each permission for frontend display.
  Useful for building permission selection UIs, help text, and documentation.
  """
  permissionsMetadata: [PermissionMetadata!]!

  """
  Returns permissions grouped by category for easier frontend display and organization.
  Each category contains a list of permissions that belong to it.
  This reduces frontend grouping work and provides a cleaner API for permission management UIs.
  """
  permissionsGroupedByCategory: [PermissionsByCategory!]!

  """
  Get the default permissions for a base role template.
  This allows the frontend to pre-populate permission selections when creating
  a custom role based on a base role (e.g., WAIT_STAFF, LOCATION_MANAGER).
  
  Security:
  - Requires authentication
  - Only returns permissions that the current user can grant (intersection with user's permissions)
  - SUPPORT_ADMIN role can only be queried by support admin users
  
  Use case: When a user selects a base role in the "Create Custom Role" UI,
  fetch this query to pre-check all the permissions that role would have.
  """
  baseRolePermissions(baseRole: RestaurantRoles!): BaseRolePermissionsResponse!

  "Fetch a single transfer event."
  getTransfer(id: ID!): SSPTableTransfer

  "Fetch transfers for a specific table order."
  getTransfersForOrder(tableOrderId: ID!): [SSPTableTransfer!]!

  "Fetch transfers for the current organization."
  getTransfers: [SSPTableTransfer!]!

  """
  Fetch all transaction logs associated with a specific order.
  Useful for auditing order-related activities.
  """
  transactionLogsByOrder(orderId: ID!): [TransactionLog!]!

  """
  Fetch all transaction logs associated with a specific user.
  Useful for tracking user activity history.
  """
  transactionLogsByUser(userId: ID!): [TransactionLog!]!

  """
  Fetch all transaction logs for a specific location.
  Useful for location-level auditing and reporting.
  """
  transactionLogsByLocation(locationId: ID!): [TransactionLog!]!

  """
  Retrieve timeclock configuration settings for a specific location.
  Includes rules for clock-in/out, break policies, and overtime settings.
  """
  timeclockSettings(locationId: ID!): TimeclockSettings!

  """
  Retrieve section assignments for a user during specific time periods or shifts.
  Useful for determining which sections a staff member was responsible for.
  """
  sectionAssignmentsByUserAndEntries(locationId: ID!, userId: ID!, entries: [TimespanOrShiftInput!]!): [SectionAtEntry!]!

  """
  Retrieve all sections configured for a specific location.
  Sections are used to organize tables and assign staff coverage.
  """
  sectionsByLocation(locationId: ID!): [SSPSection!]!

  """
  Get the current active section assignments for a location.
  Can be filtered by shift or specific datetime.
  """
  activeSectionRoster(locationId: ID!, shiftId: ID, at: DateTime): [SSPSectionAssignment!]!

  """
  Retrieve the current user's active section assignments.
  Shows which sections the authenticated user is currently covering.
  """
  myActiveCoverage(locationId: ID!, shiftId: ID, at: DateTime): [SSPSectionAssignment!]!

  """
  Get the PIN code policy configuration for a location.
  Includes rules for PIN length, complexity, and expiration.
  """
  pinPolicy(locationId: ID!): PinPolicy!

  """
  Check the PIN status for a specific waiter at a location.
  Indicates if PIN is set, expired, or needs reset.
  """
  waiterPinStatus(waiterId: ID!, locationId: ID!): PinStatus!

  """
  List all waiters/staff members for a location.
  Supports filtering by search term and roles.
  """
  waitersByLocation(locationId: ID!, search: String, roles: [String!]): [WaiterSummary!]!

  """
  Get all currently active (open) clock entries for a location.
  Shows who is currently clocked in and hasn't clocked out.
  """
  activeClockEntriesByLocation(locationId: ID!): [ClockInOut!]!

  """
  Retrieve clock entries that have been flagged for review.
  Includes entries with missing clock-outs, excessive hours, or policy violations.
  
  **Timezone:** Date inputs are interpreted in the location's configured timezone.
  """
  flaggedClockEntries(locationId: ID!, dateFrom: Date!, dateTo: Date!): [ClockInOut!]!

  """
  Fetch clock in/out logs for a location within a date range.
  Optionally filter by specific user.
  
  **Timezone:** Date inputs are interpreted in the location's configured timezone.
  """
  clockLogByLocation(locationId: ID!, dateFrom: Date!, dateTo: Date!, userId: ID): [ClockInOut!]!

  """
  Get the current open clock entry for a specific user at a location.
  Returns null if the user is not currently clocked in.
  """
  currentOpenEntryForUser(userId: ID!, locationId: ID!): ClockInOut

  """
  Generate timesheet summaries for all staff at a location.
  Includes total hours, overtime, and pay calculations for the period.
  
  **Timezone:** Date inputs are interpreted in the location's configured timezone.
  """
  timesheetSummaries(locationId: ID!, dateFrom: Date!, dateTo: Date!): [TimesheetSummary!]!

  """
  List all shifts configured for a specific location.
  Includes shift schedules, roles, and capacity information.
  """
  shiftsByLocation(locationId: ID!): [Shift!]!

  "Retrieve details for a specific shift by ID."
  shift(id: ID!): Shift

  """
  Get all staff assignments for a specific shift.
  Shows which employees are scheduled to work.
  """
  assignmentsByShift(shiftId: ID!): [ShiftAssignment!]!

  """
  Get the current user's open cash drawer at a location.
  Returns null if no drawer is currently open.
  """
  myOpenCashDrawer(locationId: ID!): CashDrawer

  "Get all open cash drawers at a location (for managers)."
  openCashDrawersByLocation(locationId: ID!): [CashDrawer!]!

  """
  Get cash drawer history for a location within a date range.
  
  **Timezone:** Date inputs are interpreted in the location's configured timezone.
  """
  cashDrawerHistory(locationId: ID!, dateFrom: Date!, dateTo: Date!): [CashDrawer!]!

  """
  Get cash drawer summary for end-of-day reconciliation.
  
  **Timezone:** The date input is interpreted in the location's configured timezone.
  """
  cashDrawerSummary(locationId: ID!, date: Date!): CashDrawerSummary!

  """
  List all shift assignments for a specific user.
  Shows the user's work schedule across all shifts.
  Users can view their own shift assignments. Managers can view any user's shift assignments.
  """
  userShiftAssignments(userId: ID!): [ShiftAssignment!]!

  """
  Analyze shift coverage gaps for a location within a date range.
  Identifies unassigned shifts and sections without coverage.
  Useful for managers to ensure adequate staffing.
  
  **Timezone:** Date inputs are interpreted in the location's configured timezone.
  """
  shiftCoverageGaps(locationId: ID!, startDate: Date!, endDate: Date!, includeUnassignedShifts: Boolean = true, includeSectionGaps: Boolean = true): ShiftCoverageGapsResult!

  """
  Analyze a specific user's coverage within a date range.
  Identifies shifts without section assignments.
  
  **Timezone:** Date inputs are interpreted in the location's configured timezone.
  """
  userCoverageAnalysis(userId: ID!, locationId: ID!, startDate: Date!, endDate: Date!): UserCoverageAnalysisResult!

  """
  Fetch all clock in/out entries for a specific user.
  Useful for individual timesheet review.
  Users can view their own clock logs. Managers (ORGANIZATION_ADMIN, CHAIN_MANAGER, LOCATION_MANAGER) can view any user's clock logs.
  """
  clockLogByUser(userId: ID!): [ClockInOut!]!

  "Get the current authenticated user's permissions list."
  getUserPermissions: [Permissions!]!

  """
  Generate a Stripe connection token for terminal integration.
  Used to establish secure payment processing connections.
  """
  getStripeConnectionToken(locationId: ID): StripeConnectionTokenResponse!

  """
  Check the Stripe Connect onboarding status for a location.
  Indicates if payment processing is fully configured.
  """
  getStripeConnectStatus(locationId: ID!): StripeConnectStatus

  """
  Get Clover connection status for a location.
  Returns connection state, merchant info, and token status.
  """
  getCloverConnectStatus(locationId: ID!): CloverConnectStatus

  """
  Get unified payment provider status for a location.
  Returns status of all configured providers (Stripe and Clover) and which is active.
  """
  getPaymentProviderStatus(locationId: ID!): PaymentProviderStatus!

  """
  Retrieve all payment gateway configurations for a location.
  Includes settings for various payment processors.
  """
  getPaymentGatewayConfigs(locationId: ID!): [SSPPaymentGatewayConfiguration!]!

  """
  Run diagnostics on tax rules for a location.
  Identifies configuration issues and conflicts in tax setup.
  """
  taxRuleDiagnostics(location_id: ID!): [TaxDiagnosticsReport!]!

  """
  Generate an item sales report for a specific time period.
  Shows quantity sold and revenue for each menu item.
  
  **Timezone:** startTime and endTime should be provided as ISO 8601 DateTime strings.
  The backend interprets these in UTC.
  """
  itemSalesReport(startTime: String!, endTime: String!, locationId: ID!): [ItemSalesReport!]!

  """
  List all print jobs configured for a specific printer.
  Shows what types of documents are routed to each printer.
  """
  getPrinterJobs(locationId: ID!, printerId: ID!): [SSPPrinterJob!]!

  """
  Find all printers configured to handle a specific job type.
  Useful for routing print requests to appropriate printers.
  """
  getPrintersByJob(locationId: ID!, jobType: String!): [SSPPrinter!]!

  """
  Retrieve configuration settings for a specific location.
  Includes operational preferences and feature toggles.
  Accessible by authenticated staff or guests with valid order token.
  """
  getConfigurationLocation(locationId: ID!): SSPConfigurationLocation

  """
  List all location configurations accessible to the authenticated user.
  Returns configurations for locations within the user's organization.
  """
  locationConfigurations: [SSPConfigurationLocation!]!

  """
  Generate comprehensive end-of-day report for a location.
  Includes sales, labor, and operational metrics.
  
  **Timezone:** The date input (YYYY-MM-DD format) is interpreted in the location's
  configured timezone. For example, "2024-01-15" for a Toronto location means
  midnight to 11:59 PM Eastern Time.
  """
  endOfDayReport(locationId: ID, date: String): EndOfDayReport!

  """
  Generate end-of-shift report for an individual employee.
  Used for shift closeout and server accountability.
  
  Query by either:
  - clockInOutId: Get report for a specific clock-in/out session
  - serverId + dateFrom/dateTo: Get report for a server within a date range
  - serverId + locationId: Get report for today at a specific location
  
  All date/time handling uses the location's configured timezone.
  """
  endOfShiftReport(clockInOutId: ID, serverId: ID, locationId: ID, dateFrom: Date, dateTo: Date): EndOfShiftReport!

  """
  Get or generate a passcode for printer authentication.
  Used to secure printer access and configuration.
  """
  fetchOrGeneratePrinterPasscode(locationId: ID!): PrinterPasscodeResult!

  "List all printers configured for a location."
  fetchPrinters(locationId: ID!): [SSPPrinter!]!

  "Retrieve all tax configurations for a specific location."
  getTaxesByLocation(s_s_p_location_id: ID!): [SSPLocationTax]

  """
  Retrieve paginated tax configurations for a location.
  Supports pagination for large tax rule sets.
  """
  getTaxesByLocationPaginated(s_s_p_location_id: ID!, page: Int = 1, pageSize: Int = 10): PaginatedSSPLocationTaxes

  """
  List all available tax definitions in the system.
  Can be filtered by tax type.
  """
  allTaxes(type: TaxType): [SSPTax]

  """
  Get predefined tax rates for a specific geographic area.
  Helps with automatic tax configuration.
  """
  predefinedTaxes(country: String, region: String, adminArea: String): [SSPTax]

  "Get paginated predefined tax rates for a geographic area."
  predefinedTaxesPaginated(country: String, region: String, adminArea: String, page: Int = 1, pageSize: Int = 10): PaginatedSSPTaxes

  "List all tables configured for a location."
  getLocationTables(locationId: ID!): [SSPTable!]!

  """
  Get paginated list of tables for a location.
  Supports filtering and sorting options.
  """
  getLocationTablesPaginated(locationId: ID!, page: Int = 1, pageSize: Int = 10, filter: String, sort: String): SSPTablePagination!

  """
  Retrieve a specific location layout by ID.
  Contains table positions and floor plan configuration.
  """
  getLocationLayout(id: ID!): LocationLayout

  "List all location layouts in the system."
  getLocationLayouts: [LocationLayout!]!

  "Get the floor plan layout for a specific location."
  getLocationLayoutByLocation(locationId: ID!): LocationLayout

  """
  Get all NFC tags registered at a specific location.
  Returns tags with their associated tables and registration info.
  """
  getNFCTagsByLocation(locationId: ID!): [NFCTag!]!

  """
  Get a specific NFC tag by ID.
  Includes detailed scan history.
  """
  getNFCTag(id: ID!): NFCTag

  """
  Get the active NFC tag assigned to a specific table.
  Returns null if no active tag is assigned.
  """
  getNFCTagByTable(tableId: ID!): NFCTag

  """
  Get all unassigned NFC tags from inventory.
  Returns tags that have been imported but not yet claimed by an organization.
  Admin-only query for managing tag inventory.
  """
  nfcTagInventory: [NFCTagInventory!]!

  "Retrieve a specific menu by ID."
  sspMenu(id: ID!): SSPMenu

  "List all menus in the system."
  sspMenus: [SSPMenu!]!

  menusByLocation(location_id: ID!): [SSPMenu!]! @deprecated(reason: "This mutation is deprecated. Please use menusByLocs.")
  menusByLocationCollection(location_coll_id: ID!): [SSPMenu!]! @deprecated(reason: "This mutation is deprecated. Please use menusByLocs.")

  """
  Retrieve menus for a specific location or location collection.
  Provide either location_id or location_coll_id.
  Accessible by authenticated staff or guests with valid order token.
  """
  menusByLocs(location_id: ID, location_coll_id: ID): [SSPMenu!]!

  """
  Get paginated menus for a location or location collection.
  Accessible by authenticated staff or guests with valid order token.
  """
  menusByLocsPaginated(location_id: ID, location_coll_id: ID, page: Int = 1, pageSize: Int = 10): PaginatedSSPMenu!

  """
  Fetch paginated tax rules for a specific tax.
  Shows conditions and rates for tax application.
  """
  getTaxRules(taxId: ID!, first: Int, page: Int): SSPTaxRulePaginator!

  "Retrieve a specific menu item by ID."
  sspMenuItem(id: ID!): SSPMenuItem

  menuItemsByLocation(location_id: ID!): [SSPMenuItem!]! @deprecated(reason: "This mutation is deprecated. Please use menuItemsByLocs.")
  menuItemsByLocationCollection(location_coll_id: ID!): [SSPMenuItem!]! @deprecated(reason: "This mutation is deprecated. Please use menuItemsByLocs.")

  """
  Retrieve all menu items for a location or location collection.
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemsByLocs(location_id: ID, location_coll_id: ID): [SSPMenuItem!]!

  """
  Get paginated menu items with filtering and sorting.
  Supports search filters and custom sort orders.
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemsByLocsPaginated(location_id: ID, location_coll_id: ID, page: Int, pageSize: Int, filter: String, sort: String): SSPMenuItemPagination!

  """
  Retrieve menu items filtered by category.
  Can be further filtered by location or collection.
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemsByCategory(category_id: ID, location_id: ID, location_coll_id: ID): [SSPMenuItem!]!

  """
  Get paginated menu items filtered by category.
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemsByCategoryPaginated(category_id: ID, location_id: ID, location_coll_id: ID, page: Int, pageSize: Int, filter: String, sort: String): SSPMenuItemPagination!

  """
  Retrieve all items that belong to a specific menu.
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemsByMenu(menu_id: ID, location_id: ID, location_coll_id: ID): [SSPMenuItem!]!

  """
  Get paginated items for a specific menu.
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemsByMenuPaginated(menu_id: ID, location_id: ID, location_coll_id: ID, page: Int, pageSize: Int, filter: String, sort: String): SSPMenuItemPagination!

  "List all menu categories in the system."
  sspMenuCategories: [SSPMenuCategory!]!

  """
  Retrieve menu categories for a location or collection.
  Accessible by authenticated staff or guests with valid order token.
  """
  getMenuCategoriesByLocs(location_id: ID, location_coll_id: ID): [SSPMenuCategory!]!

  """
  Get paginated menu categories for a location or collection.
  Accessible by authenticated staff or guests with valid order token.
  """
  getMenuCategoriesByLocsPaginated(location_id: ID, location_coll_id: ID, page: Int = 1, pageSize: Int = 10): PaginatedSSPMenuCategory!

  "Retrieve a specific menu category by ID."
  sspMenuCategory(id: ID!): SSPMenuCategory

  """
  Retrieve custom menu categories created by users.
  Excludes system-defined categories.
  """
  getUserDefinedMenuCategories(location_id: ID, location_coll_id: ID): [SSPMenuCategory!]!

  """
  Retrieve delegation capabilities for managing a specific user.
  Returns what the current user can do when editing the target user
  (which roles they can assign, which locations/collections, etc.).
  
  Security:
  - Requires 'view_member_capabilities' permission
  - Can only query capabilities for colleagues in the same organization
  - Prevents privilege escalation (cannot elevate to equal/higher privilege)
  """
  userCapabilities(userId: ID!): UserCapabilities!

  """
  Get all custom roles for the authenticated user's organization.
  Returns organization-specific roles with their permissions and metadata.
  """
  customRoles: CustomRoleConnection!

  """
  Get a specific custom role by ID.
  Can only view custom roles within your organization.
  """
  customRole(id: ID!): CustomRole!

  """
  Get all permissions that the current user has.
  Used when creating/editing custom roles to show which permissions can be granted.
  """
  availablePermissions: [Permission!]!

  "Get user-specific settings and preferences."
  getUserSettings(userId: ID!): SSPUserSetting

  """
  Get the current two-factor authentication status for the authenticated user.
  Returns whether 2FA is enabled and which channel is active.
  """
  twoFactorStatus: TwoFactorStatusResponse!

  """
  Check which 2FA channels are available for the authenticated user.
  Helps frontend determine which options to show and if phone is needed.
  """
  twoFactorAvailability: TwoFactorAvailabilityResponse!

  """
  List all active trusted devices for the authenticated user.
  Shows devices that can skip 2FA on login.
  """
  trustedDevices: TrustedDevicesResponse!

  "Get the user's privacy settings and consent preferences."
  myPrivacySettings: UserPrivacySettings!

  "Get all privacy requests made by the authenticated user."
  myPrivacyRequests: [PrivacyRequest!]!

  "Export all user data in machine-readable format (Right to Access & Portability)."
  exportMyData(format: String): UserDataExport!

  "Get all locations the current user has access to."
  getUserLocations: [SSPLocation!]!

  "Get all location collections the current user has access to."
  getUserLocCollections: [SSPLocCollection!]!

  "Get extended profile information for a user."
  getUserProfileExt(id: ID!): UserProfileExt

  "Get all locations that belong to a specific location collection."
  getLocationCollMembers(id: ID!): [SSPLocation!]!

  "Get the current authenticated user's details."
  currentLoggedInUser: SSPUser

  "Get the current authenticated user (alias for currentLoggedInUser)."
  me: SSPUser

  "Retrieve a specific user profile by ID."
  sspProfile(id: ID!): SSPProfile

  "List all users in the system."
  sspUsers: [SSPUser!]!

  "Retrieve a specific user by ID."
  sspUser(id: ID!): SSPUser

  "Check the onboarding progress status for a user."
  getOnboardingStatus(userId: ID!): SSPOnboardingStatus

  """
  Get the feature discovery status for the current user.
  Returns counts of unseen features, new feature lists, and release note status.
  Useful for showing badges and notifications.
  """
  getFeatureDiscoveryStatus(product: SSPProduct = MANAGER): FeatureDiscoveryStatus!

  """
  Get new features for a specific UI location.
  Used to determine where to show "blue dots" in the interface.
  """
  getNewFeaturesForLocation(location: String!, product: SSPProduct = MANAGER): [SSPFeature!]!

  "Get all features, optionally filtered by category and/or product."
  getAllFeatures(category: FeatureCategory, product: SSPProduct = MANAGER): [SSPFeature!]!

  "Get a specific feature by its key."
  getFeature(key: String!): SSPFeature

  "Check if a specific feature is new for the current user."
  isFeatureNew(key: String!): Boolean!

  "Get all release notes (paginated), optionally filtered by product."
  getReleaseNotes(first: Int = 10, page: Int = 1, product: SSPProduct = MANAGER): SSPReleaseNotePaginator!

  "Get a specific release note by ID."
  getReleaseNote(id: ID!): SSPReleaseNote

  "Get the latest release note for a product."
  getLatestReleaseNote(product: SSPProduct = MANAGER): SSPReleaseNote

  "Get release notes that the current user hasn't viewed for a product."
  getUnviewedReleaseNotes(product: SSPProduct = MANAGER): [SSPReleaseNote!]!

  "List all locations in the system."
  sspLocations: [SSPLocation!]!

  "Retrieve a specific location by ID."
  sspLocation(id: ID!): SSPLocation

  "Retrieve a specific location collection by ID."
  sspLocationsCollection(id: ID!): SSPLocCollection!

  "Generate a QR code URL for order payment."
  getQRCodeURL(SSPOrderID: String!): String

  "Retrieve a specific table order by ID."
  sspTableOrder(id: ID!): SSPTableOrder

  "List all table orders in the system."
  allSSPTableOrders: [SSPTableOrder!]!

  """
  Retrieve an order by its unique order ID.
  Requires guest or staff authentication.
  Guests must authenticate with AuthenticateGuestOrder mutation first.
  """
  Order(unique_orderid: ID!): SSPTableOrder

  """
  Get paginated orders filtered by location or collection.
  Supports filtering, sorting, and multi-status filtering options.
  """
  getOrdersByLocs(
    location_id: ID
    location_coll_id: ID
    page: Int
    pageSize: Int
    filter: String
    sort: String

    "Filter by multiple order statuses (e.g., [CREATED, COOKING, SERVED])"
    orderStatuses: [SSPOrderStatus!]

    "Search by order ID (partial match)"
    search: String
  ): OrderResult!

  """
  Get all orders at a location with a specific status.
  Useful for filtering by order state (pending, completed, etc.).
  """
  getOrdersByStatusAndLocation(locationId: ID!, orderStatus: SSPOrderStatus!): [SSPTableOrder!]!

  """
  Get all active orders for a specific table.
  Shows current orders that haven't been completed or paid.
  """
  activeOrdersByTable(locationId: ID!, tableId: ID!): [SSPTableOrder!]!

  """
  Get active orders for multiple tables in bulk.
  Returns orders grouped by table for efficient batch operations.
  """
  activeOrdersByTables(locationId: ID!, tableIds: [ID!]!): [ActiveOrdersForTable!]!

  """
  Get all active orders assigned to a specific server.
  Useful for server-specific workload views.
  """
  activeOrdersByServer(serverId: ID!): [SSPTableOrder!]!

  "Get server assignments for a table at a specific time."
  getAssignmentsForTableAt(tableId: ID!, datetime: String!): [SSPTableAssignment!]!

  "Get current server assignments for a table."
  getCurrentAssignmentsForTable(tableId: ID!): [SSPTableAssignment!]!

  "Retrieve a specific table assignment by ID."
  getAssignment(id: ID!): SSPTableAssignment

  """
  Generate sales aggregation reports for a location or collection.
  Groups sales data by specified criteria (day, week, month, etc.).
  
  Parameters:
  - locationId: Filter by single location (optional)
  - collectionId: Aggregate across all locations in a collection (optional)
  - If neither provided: aggregates across all user's accessible locations
  - If both provided: locationId takes precedence
  
  **Timezone:** startDate and endDate should be ISO 8601 date strings (YYYY-MM-DD).
  If a timezone parameter is provided, dates are interpreted in that timezone.
  Otherwise, dates are interpreted in the location's configured timezone.
  """
  salesAggregates(locationId: Int, collectionId: ID, startDate: String!, endDate: String!, groupBy: SalesAggregateGroupBy!, timezone: String, locale: String): [SalesAggregate!]!

  """
  Get the current shift summary for the authenticated employee.
  Shows real-time stats including orders served, sales, tips, and hours worked.
  
  **DateTime fields (clockInTime, clockOutTime):**
  Returned with the location's timezone offset, e.g., `2024-01-15T09:30:00-05:00`.
  """
  myCurrentShiftSummary(locationId: ID!): ShiftSummary

  """
  Get analytics for a waiter over a specified time period.
  Supports filtering by shift, day, week, month, or custom date range.
  
  ## Date/Time Handling
  
  **Presets (TODAY, THIS_WEEK, THIS_MONTH, CURRENT_SHIFT):**
  Date ranges are calculated using the location's configured timezone. For example,
  "TODAY" in a Toronto restaurant (America/Toronto) returns data from midnight to
  11:59 PM Eastern Time, regardless of the server's timezone.
  
  **CUSTOM time period:**
  Provide startDate and endDate as ISO 8601 DateTime strings.
  - With timezone offset (preferred): `2024-01-15T00:00:00-05:00`
  - UTC: `2024-01-15T05:00:00Z`
  - Without offset: interpreted in location's timezone
  
  **Output DateTime fields:**
  All DateTime values (periodStart, periodEnd, clockInTime, etc.) are returned
  with the location's timezone offset, e.g., `2024-01-15T14:30:00-05:00`.
  """
  myAnalytics(locationId: ID!, timePeriod: AnalyticsTimePeriod!, startDate: DateTime, endDate: DateTime): WaiterAnalytics!

  """
  Get shift summary for a specific shift ID.
  Useful for viewing historical shift performance.
  """
  shiftSummary(shiftId: ID!): ShiftSummary

  """
  [PUBLIC] Retrieve an invitation using its unique code.
  No authentication required - the invitation code itself serves as authorization.
  Used by frontend to display invitation details before user accepts.
  WARNING: Do NOT add @guard - this must remain public for invitation acceptance flow.
  """
  getInvitationByCode(code: String!): Invitation

  "Get all invitations sent by a specific user."
  getInvitationsByUser(userId: ID!): [Invitation]

  "Get all invitations for a specific location."
  getInvitationsByLocation(locationId: ID!): [Invitation]

  "Get all invitations for a specific location collection."
  getInvitationsByCollection(collectionId: ID!): [Invitation]

  getUsersByLocation(locationId: ID!): [SSPUser] @deprecated(reason: "This mutation is deprecated. Please use getUsersByLocsPaginated.")
  getUsersByCollection(collectionId: ID!): [SSPUser] @deprecated(reason: "This mutation is deprecated. Please use getUsersByLocsPaginated.")

  "Get paginated users for a location or collection."
  getUsersByLocsPaginated(location_id: ID, location_coll_id: ID, page: Int, pageSize: Int): PaginatedUsers

  """
  Get detailed information for a specific order.
  Includes items, payments, and customer details.
  """
  orderDetails(orderId: String!): SSPTableOrder!

  "Search menu items by name, description, or other text fields."
  searchMenuItems(search: String!, location_id: Int, location_coll_id: Int): [SSPMenuItem!]!

  """
  Get menu items for autocomplete functionality.
  Returns quick matches for partial search terms.
  """
  autocompleteMenuItems(search: String!, location_id: Int, location_coll_id: Int): [SSPMenuItem!]!

  "Search menu categories by name or description."
  searchMenuCategories(search: String!, location_id: Int, location_coll_id: Int): [SSPMenuCategory!]!

  "Get menu categories for autocomplete functionality."
  autocompleteMenuCategories(search: String!, location_id: Int, location_coll_id: Int): [SSPMenuCategory!]!

  "Retrieve check/receipt design template for a location."
  getCheckDesign(location_id: ID!, location_coll_id: ID, template_type: TemplateTypeInput!): SSPCheckDesign

  """
  Get both check and invoice design templates.
  Optionally replaces placeholders with sample data.
  """
  getCheckAndInvoiceDesigns(location_id: ID!, location_coll_id: ID, replacePlaceholders: Boolean): CheckInvoiceDesigns

  "Get Uber Eats integration account information for a location."
  uberEatsAccount(locationId: ID!): SSPUberEatsIntegration

  "Get orders received from Uber Eats for a location."
  uberEatsOrders(locationId: ID!): [SSPTableOrder]

  "Check the status of Uber Eats integration for a location."
  uberEatsIntegrationStatus(locationId: ID!): UberEatsIntegrationStatus

  """
  Get current organization with billing and subscription details.
  Returns plan, trial status, limits, and billing information.
  
  Note: All authenticated users can view their organization's basic info
  and subscription status. Actual billing management (invoices, payment
  methods, plan changes) requires separate permissions.
  """
  viewerOrganization: SSPOrganization!

  """
  Get subscription invoices for organization.
  Retrieves billing history with downloadable invoice links.
  """
  subscriptionInvoices(organizationId: ID!, first: Int = 12): [Invoice!]!

  """
  Get current subscription status and details.
  Returns comprehensive billing status for frontend display.
  """
  subscriptionStatus(organizationId: ID!): SubscriptionStatus!

  """
  Get a single customer by ID.
  Requires: view_customers permission
  """
  customer(id: ID!): SSPOrderCustomer

  "Get all Uber Eats connections for the authenticated organization."
  uberEatsConnections: [UberEatsConnection!]!

  "Get a specific Uber Eats connection by ID."
  uberEatsConnection(id: ID!): UberEatsConnection

  "Get webhook logs for Uber Eats integrations."
  uberEatsWebhookLogs(connection_id: ID, limit: Int = 50): [UberEatsWebhookLog!]!

  """
  List all customization templates for a location or collection.
  Returns reusable customization options that can be attached to menu items.
  Accessible by authenticated staff or guests with valid order token.
  """
  customizationTemplates(location_id: ID, location_coll_id: ID, type: CustomizationTemplateType, is_active: Boolean): [SSPCustomizationTemplate!]!

  """
  Get a specific customization template by ID.
  Accessible by authenticated staff or guests with valid order token.
  """
  customizationTemplate(id: ID!): SSPCustomizationTemplate

  """
  Get all customization templates attached to a specific menu item.
  Includes pivot data (price_override, is_default, sort_order).
  Accessible by authenticated staff or guests with valid order token.
  """
  menuItemCustomizationTemplates(menu_item_id: ID!): [SSPCustomizationTemplate!]!

  """
  Get currently active menus for a location.
  Only returns menus that are active based on their schedule configuration
  (always, date_range, recurring, or manual with is_active=true).
  This is the primary query for guest/customer menu browsing.
  """
  guestActiveMenus(location_id: ID!): [SSPMenu!]!

  """
  Get menu items from currently active menus at a location.
  Only returns items that belong to active/scheduled menus.
  Optionally filter by a specific menu_id or category_id.
  """
  guestActiveMenuItems(
    location_id: ID!

    "Optional: filter to items in a specific menu"
    menu_id: ID

    "Optional: filter to items in a specific category"
    category_id: ID
  ): [SSPMenuItem!]!

  """
  Get menu categories that have items in currently active menus.
  Returns only categories with available items for the guest to order.
  """
  guestActiveMenuCategories(
    location_id: ID!

    "Optional: filter to categories in a specific menu"
    menu_id: ID
  ): [SSPMenuCategory!]!

  """
  Get current field visibility configuration for the organization.
  Returns all configured field visibility settings.
  
  Requires: manage_analytics_visibility permission
  """
  analyticsFieldVisibilityConfig(
    "Optional: Filter by location ID."
    locationId: ID

    "Optional: Filter by role ID."
    roleId: ID
  ): [AnalyticsFieldVisibility!]!

  """
  Get list of all available fields that can be configured.
  Useful for displaying configuration UI to managers.
  
  Requires: manage_analytics_visibility permission
  """
  availableAnalyticsFields: [AvailableAnalyticsField!]!

  """
  List ALL organizations in the system.
  
  **SUPPORT_ADMIN ONLY** - This query is NEVER accessible to customers.
  Used by support team to search for customer organizations.
  
  Bypasses RLS temporarily to show all organizations.
  Every access is logged for audit purposes.
  
  Returns paginated list with basic organization info.
  """
  listAllOrganizations(
    "Search by organization name, email, or ID"
    search: String

    "Results per page"
    first: Int! = 20

    "Page number"
    page: Int
  ): OrganizationPaginator!

  """
  Get the current focused support session for the authenticated user.
  
  This returns the session the agent is currently viewing/working on.
  Returns null if no session is focused.
  
  Note: User may have multiple active sessions. Use myActiveSupportSessions
  to see all active sessions.
  """
  currentSupportSession: SupportSession

  """
  Get ALL active support sessions for the current support user.
  
  Allows agents to manage multiple concurrent customer sessions.
  This is useful when an agent needs to switch between multiple
  customer organizations without ending existing sessions.
  
  Returns empty array if no active sessions.
  Sorted by most recently created first.
  """
  myActiveSupportSessions: [SupportSession!]!

  """
  Get support session history for an organization.
  
  Access control:
  - **SUPPORT_ADMIN**: Can view sessions for ANY organization
  - **ORGANIZATION_ADMIN**: Can only view sessions for THEIR organization
  
  Returns paginated list of past and current sessions.
  """
  organizationSupportSessions(
    "Organization ID to query"
    organizationId: ID!

    "Page number (starts at 1)"
    page: Int = 1

    "Results per page (max 100)"
    limit: Int = 20
  ): SupportSessionPaginator!

  """
  Get ALL support sessions created by the current support admin.
  
  **SUPPORT_ADMIN ONLY**
  
  Returns a complete history of all support sessions the authenticated
  user has created, across all organizations. Useful for:
  - Reviewing past support interactions
  - Auditing personal support activity
  - Finding sessions by status
  
  Sorted by most recently started first.
  """
  mySupportSessionHistory(
    "Page number (starts at 1)"
    page: Int = 1

    "Results per page (max 100)"
    limit: Int = 20

    "Optional filter by status: ACTIVE, ENDED, or EXPIRED"
    status: SupportSessionStatus
  ): SupportSessionPaginator!

  """
  Fetch all CloudPRNT printers for the current organization.
  Optionally filter by location or status.
  """
  fetchCloudPrinters(locationId: ID, status: CloudPrinterStatus): [CloudPrinter!]!

  "Get a single CloudPRNT printer by ID."
  getCloudPrinter(id: ID!): CloudPrinter

  """
  Get CloudPRNT printers that handle a specific job type.
  Useful for routing print requests to appropriate printers.
  """
  getCloudPrintersByJobType(locationId: ID!, jobType: String!): [CloudPrinter!]!

  "Get print job history for a CloudPRNT printer."
  getCloudPrintJobs(cloudPrinterId: ID, status: CloudPrintJobStatus, limit: Int): [CloudPrintJob!]!

  "Get a single print job by its token."
  getCloudPrintJob(jobToken: String!): CloudPrintJob

  """
  Get kitchen capacity configuration for a location/station
  Staff only - requires JWT authentication.
  """
  kitchenCapacityConfig(locationId: ID!, stationCategoryValue: Int): KitchenCapacityConfig

  """
  Get all capacity configs for a location
  Staff only - requires JWT authentication.
  """
  kitchenCapacityConfigs(locationId: ID!, isActive: Boolean): [KitchenCapacityConfig!]!

  """
  Get current kitchen load status for a station
  Staff only - requires JWT authentication.
  """
  kitchenLoadStatus(locationId: ID!, stationCategoryValue: Int): KitchenLoadStatus!

  """
  Get all station load statuses for a location
  Accessible by authenticated staff or guests with valid order token.
  """
  kitchenLoadStatusAll(locationId: ID!): [KitchenLoadStatus!]!

  """
  Get historical load snapshots
  Staff only - requires JWT authentication and view_kitchen_analytics permission.
  """
  kitchenLoadSnapshots(locationId: ID!, stationCategoryValue: Int, startDate: DateTime, endDate: DateTime, first: Int = 100): [KitchenLoadSnapshot!]!

  """
  Calculate prep time estimate for a menu item based on current kitchen load
  This is the KEY QUERY for guests to see realistic ETAs
  Accessible by authenticated staff or guests with valid order token.
  """
  calculatePrepTimeEstimate(menuItemId: ID!, locationId: ID!, stationCategoryValue: Int): PrepTimeEstimate!

  """
  Get all available kitchen stations for a location.
  Returns stations derived from menu items' category values.
  Staff only - requires JWT authentication.
  """
  kitchenStations(locationId: ID!): [KitchenStation!]!

  """
  Get print requests for monitoring.
  Optionally filter by printer ID, status, or limit results.
  """
  getPrintRequests(printerId: ID, status: PrintRequestStatus, limit: Int): [PrintRequest!]!

  "Get a single print request by ID."
  getPrintRequest(id: ID!): PrintRequest

  "Get print request statistics for a location or printer."
  getPrintRequestStats(locationId: ID, printerId: ID): PrintRequestStats!

  """
  Get unified print job list combining both RabbitMQ and CloudPRNT jobs.
  Useful for a single monitoring dashboard.
  """
  getUnifiedPrintJobs(locationId: ID, status: String, limit: Int): [UnifiedPrintJob!]!

  "Get list of available webhook events for plugin configuration"
  availablePluginEvents: [PluginWebhookEventDefinition!]!

  "Get single plugin integration"
  pluginIntegration(id: ID!): PluginIntegration

  "Get my plugin integrations"
  myPluginIntegrations: [PluginIntegration!]!

  "Get marketplace plugins (public only)"
  marketplacePlugins(plugin_type: PluginType, certified: Boolean, featured: Boolean, search: String): [PluginIntegration!]!

  "List all menu items in the system."
  sspMenuItems(
    "Limits number of fetched items."
    first: Int!

    "The offset from which items are returned."
    page: Int
  ): SSPMenuItemPaginator!

  "List all user profiles in the system."
  sspProfiles(
    "Limits number of fetched items."
    first: Int! = 10

    "The offset from which items are returned."
    page: Int
  ): SSPProfilePaginator!

  """
  Get all customers with pagination and filtering.
  Requires: view_customers permission
  """
  customers(
    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 20

    "The offset from which items are returned."
    page: Int
  ): SSPOrderCustomerPaginator!

  "List all plugin integrations"
  pluginIntegrations(
    plugin_type: PluginType
    status: PluginStatus
    visibility: PluginVisibility
    certified: Boolean
    featured: Boolean
    search: String
    orderBy: [OrderByClause!]

    "Limits number of fetched items."
    first: Int! = 20

    "The offset from which items are returned."
    page: Int
  ): PluginIntegrationPaginator!
}

type Mutation {
  """
  Bulk update user permissions by granting and revoking multiple permissions at once.
  Provides atomic permission updates for efficient user access management.
  """
  updateUserPermissions(userId: ID!, grantPermissions: [Permissions!]!, revokePermissions: [Permissions!]!): UserPermissionMatrix!

  """
  Grant a specific permission to a user.
  Returns true if permission was successfully granted.
  """
  grantPermissionToUser(userId: ID!, permission: Permissions!): Boolean!

  """
  Revoke a specific permission from a user.
  Returns true if permission was successfully revoked.
  """
  revokePermissionFromUser(userId: ID!, permission: Permissions!): Boolean!

  """
  Create a new custom role for your organization.
  
  Security:
  - Requires 'create_custom_role' permission
  - Can only grant permissions you have
  - Cannot create roles with equal/higher privilege than yourself
  - Custom roles are scoped to your organization
  """
  createCustomRole(input: CreateCustomRoleInput!): CustomRoleResponse!

  """
  Update an existing custom role.
  
  Security:
  - Requires 'update_custom_role' permission
  - Can only update roles in your organization
  - Updated permissions must be subset of your permissions
  - Cannot elevate privilege to equal/higher than yourself
  """
  updateCustomRole(input: UpdateCustomRoleInput!): CustomRoleResponse!

  """
  Delete a custom role.
  
  Security:
  - Requires 'delete_custom_role' permission
  - Can only delete roles in your organization
  - Cannot delete if role is assigned to any users
  """
  deleteCustomRole(id: ID!): DeleteCustomRoleResponse!

  """
  Transfer a table order to another waiter.
  Requires manager PIN unless initiator has bypass permission.
  Includes audit trail and transfer history tracking.
  """
  transferTable(input: TransferTableInput!): TransferTablePayload!

  """
  Undo a transfer within the allowed timeframe.
  Restores original waiter assignment and updates transfer status.
  """
  undoTransfer(transferId: ID!): TransferTablePayload!

  """
  [PUBLIC] Register a user with an existing organization.
  Used for joining existing restaurant groups or chains via invitation.
  Invitation token serves as authorization.
  """
  registerWithOrganization(input: RegisterWithOrganizationInput!): RegisterWithOrganizationPayload!

  "[PUBLIC] Authenticate via social provider (Google, Apple, etc)."
  socialLogin(input: SocialLoginInput!): LoginPayload!

  linkSocialAccount(input: LinkSocialAccountInput!): SocialAccount!
  unlinkSocialAccount(provider: SocialProvider!): Boolean!

  """
  Start a 30-day Business trial for the organization.
  Allows organizations to test Business features before committing to paid plan.
  """
  startBusinessTrial(organizationId: ID!): SSPOrganization!

  """
  Create Stripe Checkout session for Business plan upgrade.
  Redirects to Stripe-hosted checkout for secure payment processing.
  """
  createBusinessCheckoutSession(organizationId: ID!, successUrl: String!, cancelUrl: String!): BusinessCheckoutResponse!

  """
  Create Stripe Billing Portal session for subscription management.
  Provides access to invoice history, payment methods, and subscription controls.
  """
  createStripeBillingPortalSession(organizationId: ID!, returnUrl: String!): BillingPortalResponse!

  """
  Create a new section for organizing tables and staff assignments.
  Sections help manage restaurant floor coverage and server responsibilities.
  """
  createSection(input: CreateSectionInput!): SSPSection!

  """
  Update section details including name, color, and configuration.
  Used for modifying existing section properties.
  """
  updateSection(input: UpdateSectionInput!): SSPSection!

  """
  Delete a section and remove all associated table assignments.
  This will unassign all tables currently in the section.
  """
  deleteSection(id: ID!): Boolean!

  """
  Assign a table to a section or clear its section assignment.
  Pass null for sectionId to remove table from any section.
  """
  setTableSection(tableId: ID!, sectionId: ID): SSPTable!

  """
  Bulk assign multiple tables to a section simultaneously.
  Returns the number of tables successfully assigned.
  """
  bulkSetTableSection(tableIds: [ID!]!, sectionId: ID): Int!

  """
  Assign a staff member to cover a section during specific times.
  Creates coverage assignments for section-based table management.
  """
  assignUserToSection(input: AssignSectionInput!): SSPSectionAssignment!

  """
  Remove a staff member from section coverage.
  Ends the section assignment and updates coverage status.
  """
  unassignUserFromSection(assignmentId: ID!): Boolean!

  """
  Create a new work shift with schedule and role definitions.
  Defines work periods, break times, and staffing requirements.
  """
  createShift(input: ShiftInput!): Shift!

  """
  Update existing shift details including times, roles, and capacity.
  Allows modification of shift parameters and scheduling rules.
  """
  updateShift(id: ID!, input: ShiftInput!): Shift!

  """
  Delete a work shift and remove all associated assignments.
  Will unassign all staff currently scheduled for this shift.
  """
  deleteShift(id: ID!): Boolean!

  """
  Assign a staff member to work a specific shift.
  Creates scheduling assignments for shift-based workforce management.
  """
  assignUserToShift(input: ShiftAssignmentInput!): ShiftAssignment!

  """
  Remove a staff member from a shift assignment.
  Ends the shift assignment and updates schedule.
  """
  unassignUserFromShift(id: ID!): Boolean!

  """
  Bulk import shifts from CSV data.
  Creates shifts and optionally assigns employees in a single operation.
  
  CSV format: location_id, title, role, start_time, end_time, employee_email
  
  Use dryRun: true to validate without creating records.
  """
  bulkImportShifts(csvContent: String!, skipHeader: Boolean = true, dryRun: Boolean = false): BulkShiftImportResult!

  """
  Clock in for a work shift at a specific location.
  Records start time and validates shift eligibility.
  """
  clockIn(input: ClockInInput): ClockResult

  """
  Clock out from current work shift.
  Records end time and calculates total hours worked.
  """
  clockOut(input: ClockOutInput): ClockResult

  """
  Configure timeclock settings and policies for a location.
  Sets break rules, overtime thresholds, and clock-in restrictions.
  """
  updateTimeclockSettings(locationId: ID!, input: TimeclockSettingsInput!): TimeclockSettings!

  """
  Approve a flagged clock entry that requires manager review.
  Used for entries with missing clock-outs or policy violations.
  """
  approveFlaggedEntry(id: ID!, note: String): ClockInOut!

  """
  Manually adjust clock in/out times with manager authorization.
  Allows correction of timing errors with audit trail.
  """
  adjustClockEntry(id: ID!, input: AdjustClockEntryInput!): ClockInOut!

  """
  Cancel a clock entry and void the time record.
  Completely removes the clock entry from payroll calculations.
  """
  cancelClockEntry(id: ID!, note: String!): Boolean!

  """
  Open a cash drawer for the current user at a location.
  Requires an opening count of the cash in the drawer.
  """
  openCashDrawer(input: OpenCashDrawerInput!): CashDrawer!

  """
  Close a cash drawer with a final count.
  Calculates expected vs actual cash and records variance.
  """
  closeCashDrawer(input: CloseCashDrawerInput!): CashDrawer!

  """
  Approve a cash drawer variance (for managers).
  Required when closing amount differs from expected.
  """
  approveCashDrawerVariance(drawerId: ID!, note: String): CashDrawer!

  """
  Export various reports in different formats (PDF, Excel, CSV).
  Returns a pre-signed URL for downloading the generated report.
  Supports timesheet, sales, and operational reports.
  
  **Timezone:** Date filters (dateFrom, dateTo) in ReportFilterInput are interpreted
  in the location's configured timezone. See ReportFilterInput for details.
  """
  exportReport(type: ReportType!, format: ExportFormat!, filters: ReportFilterInput): String!

  """
  [PUBLIC] Refresh an expired authentication token using a valid refresh token.
  Extends user session without requiring re-login.
  """
  refreshToken(refresh_token: String!): AuthPayload

  """
  [PUBLIC] Authenticate user with email and password credentials.
  Returns authentication tokens and user information on success.
  
  For multi-org users:
  - If user belongs to multiple organizations and organization_id is not provided,
    returns requiresOrganizationSelection=true with a selector token and organization list.
  - Use the selectOrganization mutation with the selector token to complete login.
  - If organization_id is provided, skips the selection step and logs into that org directly.
  """
  loginSSPUser(
    email: String!
    password: String!

    "Optional device token for 'Remember this device' feature."
    device_token: String

    "Optional organization ID for direct login (multi-org users)."
    organization_id: ID
  ): LoginPayload

  """
  [PUBLIC] Authenticate a guest for order access.
  Validates the uniqueOrderId and order status, returns a 2-hour JWT.
  Rate limited to prevent brute-force attacks on order IDs.
  Rejects inactive orders (completed, cancelled, voided, refunded, abandoned, failed).
  """
  AuthenticateGuestOrder(
    "The unique 6-character order ID from QR code"
    uniqueOrderId: String!

    "Optional session ID for split billing tracking"
    sessionId: String
  ): GuestAuthResponse!

  """
  [PUBLIC] Create an order from NFC scan for self-seating restaurants.
  Only works when location's nfcNoOrderBehavior is AUTO_CREATE_ORDER.
  Rate limited (30/min per IP, 100/min per organization).
  Finds assigned waiter automatically. Requires active NFC tag registered for the table.
  If an active order already exists for the table, returns that order (idempotent).
  """
  createTableOrderFromNFC(
    "Organization UUID or slug from the NFC URL."
    organizationSlug: String!

    "Location slug or ID from the NFC URL."
    locationSlug: String!

    "Table local_id (number) from the NFC URL."
    tableNumber: Int!

    "Party size for the order. Defaults to 1."
    partySize: Int = 1
  ): NFCOrderCreationResult!

  """
  [PUBLIC] Create an order for web ordering (takeout, delivery).
  No table required. Rate limited. No waiter assignment initially.
  Requires location to have web_ordering_enabled = true.
  Returns uniqueOrderId for guest authentication.
  """
  createDirectWebOrder(
    "Organization UUID or slug."
    organizationSlug: String!

    "Location ID or slug."
    locationSlug: String!

    "Order type: TAKE_OUT, PICKUP, or DELIVERY (not DINE_IN)."
    orderType: TableOrderType!

    "Party size (defaults to 1)."
    partySize: Int = 1

    "Frontend-generated UUID for duplicate prevention."
    clientSessionId: String
  ): DirectWebOrderResult!

  """
  [GUEST] Link a customer to an order for checkout.
  Used after guest browses menu and adds items.
  """
  linkCustomerToOrder(
    "The ID of the order to link the customer to."
    orderId: ID!

    "The ID of the customer to link."
    customerId: ID!
  ): SSPTableOrder!

  """
  Log out the current user and invalidate their session.
  Clears authentication tokens and session data.
  """
  logoutSSPUser: Boolean

  """
  [PUBLIC] Register a new user account with initial profile information.
  Creates user record and sends email verification if enabled.
  """
  register(input: RegisterInput!): SSPUser!

  """
  Send email verification link to the user's registered email address.
  Required for account activation in secure environments.
  """
  sendEmailVerification: Boolean

  """
  [PUBLIC] Verify user email address using verification ID and hash.
  Completes email verification process and activates account.
  Token from email serves as authorization.
  """
  verifyEmail(id: ID!, hash: String!): Boolean

  """
  Update user application settings and preferences.
  Modifies user-specific configuration options and display preferences.
  """
  updateUserSettings(input: UpdateUserSettingsInput!): SSPUserSetting

  """
  Change user's email address with verification process.
  Requires email verification for security purposes.
  """
  changeEmail(input: ChangeEmailInput!): Boolean!

  """
  Update basic user profile information including name and contact details.
  Modifies core user account information.
  """
  updateUserProfile(input: UserProfile!): SSPUser!

  """
  Update extended user profile with additional fields and metadata.
  Handles specialized profile data beyond basic information.
  """
  updateUserProfileExt(input: UserProfileExtInput!): UserProfileExt

  """
  Change user password with current password verification.
  Requires current password for security validation.
  """
  changePassword(currentPassword: String!, newPassword: String!): Boolean!

  """
  Set initial password for users who signed up via social login.
  Does not require current password since social users don't have one.
  Only works if user has no password set yet.
  """
  setPassword(newPassword: String!, newPassword_confirmation: String!): Boolean!

  """
  [PUBLIC] Request a password reset email for account recovery.
  Sends secure reset link to user's registered email address.
  """
  requestPasswordReset(email: String!): PasswordResetResponse!

  """
  [PUBLIC] Reset password using secure token from reset email.
  Completes password recovery process with new password.
  Token from email serves as authorization.
  """
  resetPassword(input: ResetPasswordInput!): PasswordResetResponse

  """
  Enable two-factor authentication for enhanced account security.
  Supports multiple channels: TOTP (default), email, and SMS.
  For TOTP: generates QR code (to be confirmed with app code).
  For email/SMS: sends a one-time verification code to user.
  Recovery codes are only returned after confirmTwoFactorAuthentication.
  """
  enableTwoFactorAuthentication(
    "The 2FA channel to enable: totp (default), email, or sms"
    channel: TwoFactorChannel

    "Phone number (required for SMS channel)"
    phone: String
  ): EnableTwoFactorResponse!

  """
  Confirm two-factor authentication setup by verifying a code.
  Must be called after enableTwoFactorAuthentication to complete enrollment.
  Returns recovery codes on successful confirmation (one-time display).
  """
  confirmTwoFactorAuthentication(code: String!): ConfirmTwoFactorResponse!

  """
  Verify two-factor authentication during login.
  Accepts TOTP code, recovery code, or challenge token.
  Can optionally remember this device to skip 2FA on future logins.
  """
  verifyTwoFactorAuthentication(code: String, recoveryCode: String, challengeToken: String!, rememberDevice: Boolean): VerifyTwoFactorResponse!

  """
  Resend two-factor authentication code (for email/SMS channels).
  Can be used during enrollment (authenticated) or login (with challengeToken).
  """
  resendTwoFactorCode(challengeToken: String): ResendTwoFactorCodeResponse!

  """
  Select an organization to log into after initial authentication.
  Used in two-step login flow for multi-organization users.
  
  The selection_token is obtained from loginSSPUser or verifyTwoFactorAuthentication
  when requiresOrganizationSelection=true.
  """
  selectOrganization(
    "The selector token from initial authentication."
    selection_token: String!

    "The ID of the organization to log into."
    organization_id: ID!
  ): LoginPayload!

  """
  Accept an invitation to join an organization.
  Requires the user to be authenticated (have a valid selector token).
  
  Returns a fresh selector token with the newly joined organization included.
  """
  acceptInvitation(
    "The selector token from authentication."
    selection_token: String!

    "The invitation token from the invitation email."
    invitation_token: String!
  ): AcceptInvitationPayload!

  """
  Disable two-factor authentication for the current user.
  Requires the current password (recently confirmed) OR a valid 2FA/recovery code.
  """
  disableTwoFactorAuthentication(currentPassword: String, code: String): DisableTwoFactorResponse!

  """
  Regenerate two-factor recovery codes.
  Invalidates all old recovery codes and returns new ones (one-time display).
  """
  regenerateTwoFactorRecoveryCodes: RegenerateTwoFactorRecoveryCodesResponse!

  """
  Revoke a specific trusted device.
  User will need to verify 2FA again on next login from that device.
  """
  revokeTrustedDevice(deviceId: ID!): RevokeTrustedDeviceResponse!

  "Update user privacy consent preferences (marketing, analytics)."
  updatePrivacyConsent(marketingConsent: Boolean, analyticsConsent: Boolean): ConsentUpdateResponse!

  """
  Request account deletion (Right to Erasure).
  Schedules deletion after 30-day grace period.
  """
  requestAccountDeletion(reason: String, password: String!): AccountDeletionResponse!

  "Cancel a pending account deletion request."
  cancelAccountDeletion: AccountDeletionResponse!

  "Submit a privacy request (access, rectification, portability, restrict, object)."
  submitPrivacyRequest(requestType: PrivacyRequestType!, description: String, metadata: JSON): PrivacyRequestResponse!

  """
  Toggle data processing restriction (Right to Restrict Processing).
  When restricted, only essential processing is performed.
  """
  toggleDataProcessingRestriction(restricted: Boolean!): ConsentUpdateResponse!

  """
  Revoke all trusted devices for the authenticated user.
  User will need to verify 2FA on all devices on next login.
  Useful after security incidents or when changing password.
  """
  revokeAllTrustedDevices: RevokeTrustedDeviceResponse!

  """
  Mark a specific onboarding step as completed for a user.
  Tracks progress through initial setup and training process.
  """
  completeOnboardingStep(userId: ID!, step: OnboardingStep!): SSPOnboardingStatus

  """
  Skip the onboarding process entirely for a user.
  Marks all onboarding steps as completed or skipped.
  """
  skipOnboarding(userId: ID!): SSPOnboardingStatus

  """
  Mark a feature as seen by the current user.
  This removes the "blue dot" notification for this feature.
  """
  markFeatureAsSeen(featureKey: String!): SSPUserFeatureInteraction!

  "Dismiss a feature (user doesn't want to see it again)."
  dismissFeature(featureKey: String!): SSPUserFeatureInteraction!

  "Mark a feature as completed (for onboarding-style features)."
  completeFeature(featureKey: String!): SSPUserFeatureInteraction!

  "Skip a feature (for onboarding-style features that can be skipped)."
  skipFeature(featureKey: String!): SSPUserFeatureInteraction!

  """
  Batch mark multiple features as seen.
  Useful when a user views a page with multiple new features.
  """
  markFeaturesAsSeen(featureKeys: [String!]!): [SSPUserFeatureInteraction!]!

  "Mark a release note as viewed by the current user."
  markReleaseNoteAsViewed(releaseNoteId: ID!): Boolean!

  """
  Mark all release notes as viewed by the current user.
  Returns the count of release notes marked as viewed.
  """
  markAllReleaseNotesAsViewed: Int!

  """
  Upload image with enhanced metadata and processing (v2).
  Supports multiple formats, automatic resizing, and optimization.
  """
  uploadImageV2(input: UploadImageInput!): UploadImagePayload!

  """
  Delete an existing image using its storage path (v2).
  Removes image from storage and cleans up metadata.
  """
  deleteImageV2(imagePath: String!): Boolean!

  """
  Upload a single image file and return the storage path.
  Basic image upload functionality for profile pictures and content.
  """
  uploadImage(file: Upload!): String

  """
  Replace an existing image with a new one.
  Updates image while maintaining the same reference path.
  """
  updateImage(file: Upload!, currentImagePath: String!): String

  """
  Upload new image or update existing one based on path.
  Creates new image if path is null, updates if path exists.
  """
  upsertImage(file: Upload!, currentImagePath: String): String

  """
  Delete an image file from storage using its file path.
  Permanently removes image and associated metadata.
  """
  deleteImage(filePath: String!): Boolean

  """
  Authenticate using location-specific PIN code for POS access.
  Enables quick login for staff at restaurant terminals.
  """
  loginWithPinCode(location_id: ID!, waiter_id: ID!, pin_code: String!, device_id: String): PinLoginResponse!

  """
  Update user's PIN code with current PIN verification.
  Requires existing PIN for security validation.
  """
  updatePinCode(waiter_id: ID!, current_pin_code: String!, new_pin_code: String!): PinResponse!

  """
  Create initial PIN code for a user account (manual entry).
  Sets up PIN-based authentication for restaurant access.
  
  **Deprecated:** Use generatePinCode for best practice server-generated PINs.
  """
  createPinCode(user_id: ID!, new_pin_code: String!): PinResponse! @deprecated(reason: "Use generatePinCode for server-generated unique PINs")

  """
  Generate a server-side unique PIN code for user.
  **Best Practice:** Server generates PIN to prevent collisions and ensure uniqueness.
  PIN is automatically sent via email if user has verified email.
  """
  generatePinCode(user_id: ID!, pin_length: Int, send_email: Boolean): GeneratePinResponse!

  """
  Reset user's PIN code with manager authorization.
  Allows managers to reset forgotten or compromised PINs.
  Can optionally generate a new PIN automatically.
  """
  resetPinCode(user_id: ID!, generate_new: Boolean, send_email: Boolean): ResetPinResponse!

  """
  Resend PIN code via email (generates new PIN).
  Used when user lost their PIN email.
  Note: Original PIN cannot be retrieved (it's hashed), so a new PIN is generated.
  """
  resendPinCode(user_id: ID!): ResendPinResponse!

  """
  Verify user's PIN code for secure operations.
  Used for authentication before sensitive actions like refunds or manager overrides.
  """
  verifyPinCode(user_id: ID!, pin_code: String!, action: String!, location_id: ID!): PinVerifyResponse!

  """
  Register a new organization in the SSP ecosystem.
  Creates the initial organization entity for a new business client.
  """
  registerOrganization(input: RegisterOrganizationInput!): SSPOrganization!

  """
  Complete organization onboarding process.
  Finalizes organization setup with required business information and settings.
  """
  onboardOrganization(input: OnboardOrganizationInput!): OnboardOrganizationPayload

  """
  Create a new location for an organization.
  Establishes a physical restaurant location with basic settings.
  """
  createSSPLocation(input: SSPLocationInput!): SSPLocation

  """
  Create multiple locations in a single operation.
  Efficient bulk creation for organizations expanding to multiple locations.
  """
  batchCreateSSPLocation(inputs: [SSPLocationInput!]!): [SSPLocation!]!

  """
  Update an existing location's information.
  Modify location details, settings, or configuration.
  """
  updateSSPLocation(id: ID!, input: SSPLocationInput!): SSPLocation

  """
  Delete a location from the system.
  Permanently removes a location and associated data.
  """
  deleteSSPLocation(id: ID!): Boolean

  """
  Create a collection of locations for grouped management.
  Organize locations into logical groups for easier administration.
  """
  createSSPLocCollection(input: SSPLocCollInput!): SSPLocCollection

  """
  Update a location collection's details.
  Modify collection properties and location assignments.
  """
  updateSSPLocCollection(id: ID!, input: SSPLocCollInput!): SSPLocCollection

  """
  Delete a location collection.
  Remove collection grouping while preserving individual locations.
  """
  deleteSSPLocCollection(id: ID!): Boolean

  """
  Create or update location configuration settings.
  Manages location-specific operational parameters and preferences.
  """
  upsertConfigurationLocation(input: UpsertConfigurationInput!): SSPConfigurationLocation

  """
  Create or update check/invoice design templates.
  Customizes the appearance and layout of customer receipts and invoices.
  """
  upsertCheckInvoiceDesign(location_id: ID!, location_coll_id: ID, template_type: TemplateTypeInput!, input: CheckDesignInput!): SSPCheckDesign

  """
  Create a new tax rule for locations.
  Defines how taxes are calculated and applied to orders.
  """
  createTaxRule(input: SSPTaxRuleInput!): SSPTaxRule!

  """
  Update an existing tax rule.
  Modify tax calculation parameters and conditions.
  """
  updateTaxRule(id: ID!, input: SSPTaxRuleInput!): SSPTaxRule!

  """
  Delete a tax rule from the system.
  Remove tax rule while preserving historical tax data.
  """
  deleteTaxRule(id: ID!): Boolean!

  """
  Create a custom tax configuration.
  Define custom tax types beyond standard sales tax.
  """
  createCustomTax(input: CreateCustomTaxInput!): SSPTax

  """
  Add tax configuration to a specific location.
  Apply tax rules to individual restaurant locations.
  """
  addLocationTax(input: LocationTaxInput!): SSPLocationTax!

  """
  Update location-specific tax settings.
  Modify tax configuration for individual locations.
  """
  updateLocationTax(id: ID!, input: LocationTaxInput!): SSPLocationTax!

  """
  Remove tax configuration from a location.
  Disable tax application for specific locations.
  """
  removeLocationTax(id: ID!): Boolean!

  """
  Create a Stripe Express account for a location.
  Sets up payment processing capabilities through Stripe Connect.
  """
  createStripeExpressAccount(locationId: ID!, refreshUrl: String!, returnUrl: String!): StripeOnboardingResponse!

  """
  Refresh Stripe onboarding link for incomplete setup.
  Generates new onboarding URL when previous one expires or fails.
  """
  refreshStripeOnboardingLink(locationId: ID!, refreshUrl: String!, returnUrl: String!): StripeOnboardingResponse!

  """
  Generate Stripe Dashboard access link for location owners.
  Provides direct access to Stripe payment analytics and settings.
  """
  createStripeDashboardLink(locationId: ID!): StripeDashboardResponse!

  """
  Create a Stripe Terminal Location for Tap to Pay functionality.
  This is required before using Tap to Pay on iPhone/Android.
  Prerequisites: Location must have completed Stripe Connect onboarding.
  """
  createStripeTerminalLocation(locationId: ID!): StripeTerminalLocationResponse!

  """
  Initiate Clover OAuth onboarding flow.
  Returns authorization URL to redirect merchant for Clover account connection.
  """
  initiateCloverOnboarding(locationId: ID!): CloverOnboardingResponse!

  """
  Set the active payment provider for a location.
  Switches between Stripe and Clover for payment processing.
  """
  setActivePaymentProvider(locationId: ID!, provider: String!): SetActiveProviderResponse!

  """
  Disconnect Clover from a location.
  Clears Clover credentials and switches to Stripe if available.
  """
  disconnectClover(locationId: ID!): SetActiveProviderResponse!

  """
  Set the Clover terminal connection mode for a location.
  Mode can be 'cloud' (Cloud Pay Display) or 'local' (REST Pay Display).
  """
  setCloverTerminalMode(locationId: ID!, mode: String!): SetTerminalModeResponse!

  """
  Link Uber Eats account to location for delivery integration.
  Connects restaurant location with Uber Eats delivery platform.
  """
  linkUberEatsAccount(locationId: ID!, authCode: String!): LinkUberEatsAccountResponse

  """
  Accept an incoming Uber Eats order.
  Notifies Uber Eats that the restaurant has accepted the order and will begin preparing it.
  """
  acceptUberEatsOrder(locationId: ID!, orderId: String!, reason: String): UberEatsOrderResponse

  """
  Deny/reject an incoming Uber Eats order.
  Notifies Uber Eats that the restaurant cannot fulfill this order with a reason.
  """
  denyUberEatsOrder(locationId: ID!, orderId: String!, reason: String!, reasonCode: String): UberEatsOrderResponse

  """
  Update Uber Eats order status (preparing or ready for pickup).
  Notifies Uber Eats and the delivery driver of the order's current status.
  """
  updateUberEatsOrderStatus(locationId: ID!, orderId: String!, status: String!): UberEatsOrderResponse

  """
  Generate pre-signed URLs for menu image uploads.
  Enables secure direct upload of menu images to S3 storage.
  """
  generatePresignedUrls(files: [SSPMenuImageFileInput!]!): [S3PresignedUrlResponse!]!

  """
  Process uploaded menu images and extract menu data.
  Analyze menu images using AI to automatically generate menu structure.
  
  Parameters:
  - s3Keys: Array of S3 keys from generatePresignedUrls
  - locationId: Location ID (required unless existingMenuId is provided)
  - locCollId: Location collection ID (required unless existingMenuId is provided)
  - menuName: Optional name to force all images into one new menu with this name
  - existingMenuId: Optional ID of existing menu to add items to (mutually exclusive with menuName)
  """
  processMenuImages(s3Keys: [String!]!, locationId: ID, locCollId: ID, menuName: String, existingMenuId: ID): SSPMenuDataResponse!

  """
  Create a new menu for a location or collection.
  Establishes a menu container for organizing menu items and categories.
  Note: Setting scheduling fields requires 'manage_menu_schedule' ability.
  Fixed version: Uses custom resolver to properly handle location_coll_id.
  """
  createSSPMenu(input: CreateSSPMenuInput!): SSPMenu

  """
  Update an existing menu's details.
  Modify menu properties, name, description, or settings.
  Note: Setting scheduling fields requires 'manage_menu_schedule' ability.
  Note: Updating collection-scoped menus requires 'manage_collection_menus' permission.
  Fixed version: Uses custom resolver to properly handle location_coll_id.
  """
  updateSSPMenu(id: ID!, input: CreateSSPMenuInput!): SSPMenu

  """
  Delete a menu from the system.
  Remove menu and optionally associated items and categories.
  
  Context-aware deletion:
  - If location_id is provided: Only allows deletion of menus scoped to that specific location
  - If location_coll_id is provided: Only allows deletion of menus scoped to that specific collection
  - Collection-scoped menus CANNOT be deleted from location views
  - Location-scoped menus CANNOT be deleted from collection views
  
  Note: Deleting collection-scoped menus requires 'manage_collection_menus' permission.
  """
  deleteSSPMenu(input: DeleteMenuEntityInput!): Boolean

  """
  Create a new menu item.
  Add food/drink items with pricing, description, and options.
  """
  createSSPMenuItem(input: CreateSSPMenuItemInput!): SSPMenuItem

  """
  Update an existing menu item.
  Modify item details, pricing, availability, or specifications.
  Note: Updating collection-scoped items requires 'manage_collection_menu_items' permission.
  """
  updateSSPMenuItem(id: ID!, input: CreateSSPMenuItemInput!): SSPMenuItem

  """
  Delete a menu item.
  Remove item from all menus while preserving order history.
  
  Context-aware deletion:
  - If location_id is provided: Only allows deletion of items scoped to that specific location
  - If location_coll_id is provided: Only allows deletion of items scoped to that specific collection
  - Collection-scoped items CANNOT be deleted from location views
  - Location-scoped items CANNOT be deleted from collection views
  
  Note: Deleting collection-scoped items requires 'manage_collection_menu_items' permission.
  """
  deleteSSPMenuItem(input: DeleteMenuEntityInput!): Boolean

  """
  Create a menu category for organizing items.
  Group related menu items into logical categories.
  """
  createSSPMenuCategory(input: CreateSSPMenuCategoryInput!): SSPMenuCategory

  """
  Update a menu category's information.
  Modify category name, description, or display order.
  Note: PREDEFINED categories cannot be updated.
  Note: Updating collection-scoped categories requires 'manage_collection_categories' permission.
  """
  updateSSPMenuCategory(id: ID!, input: CreateSSPMenuCategoryInput!): SSPMenuCategory

  """
  Delete a menu category.
  Remove category while preserving or reassigning contained items.
  
  Context-aware deletion:
  - If location_id is provided: Only allows deletion of categories scoped to that specific location
  - If location_coll_id is provided: Only allows deletion of categories scoped to that specific collection
  - Collection-scoped categories CANNOT be deleted from location views
  - Location-scoped categories CANNOT be deleted from collection views
  
  Note: PREDEFINED categories cannot be deleted.
  Note: Deleting collection-scoped categories requires 'manage_collection_categories' permission.
  """
  deleteSSPMenuCategory(input: DeleteMenuEntityInput!): Boolean

  """
  Attach menu item to one or more menus.
  Make items available across multiple menu configurations.
  """
  attachItemToMenu(itemId: ID!, menuIds: [ID!]!): ItemResponse

  """
  Remove menu item from specified menus.
  Control item availability across different menu contexts.
  """
  detachItemFromMenu(itemId: ID!, menuIds: [ID!]!): ItemResponse

  """
  Assign menu item to categories.
  Organize items within menu structure for better navigation.
  """
  attachItemToCategory(itemId: ID!, categoryIds: [ID!]!): ItemResponse

  """
  Remove menu item from categories.
  Adjust item categorization within menu structure.
  """
  detachItemFromCategory(itemId: ID!, categoryIds: [ID!]!): ItemResponse

  """
  Create a new customization template.
  Define reusable customization options (e.g., "Extra Cheese", "No Onions")
  that can be attached to multiple menu items.
  """
  createCustomizationTemplate(input: CreateCustomizationTemplateInput!): CustomizationTemplateResponse!

  """
  Update an existing customization template.
  Changes will affect all menu items using this template.
  """
  updateCustomizationTemplate(id: ID!, input: UpdateCustomizationTemplateInput!): CustomizationTemplateResponse!

  """
  Delete a customization template.
  Will be detached from all menu items before deletion.
  """
  deleteCustomizationTemplate(input: DeleteCustomizationTemplateInput!): CustomizationTemplateResponse!

  """
  Attach a customization template to a menu item.
  Optionally override the default price for this specific item.
  """
  attachCustomizationTemplateToItem(input: AttachCustomizationTemplateInput!): CustomizationTemplateResponse!

  "Detach a customization template from a menu item."
  detachCustomizationTemplateFromItem(input: DetachCustomizationTemplateInput!): CustomizationTemplateResponse!

  """
  Update the pivot data for a menu item - customization template association.
  Modify price_override, is_default, or sort_order.
  """
  updateMenuItemCustomizationTemplate(input: UpdateMenuItemCustomizationTemplateInput!): CustomizationTemplateResponse!

  """
  Bulk attach a customization template to multiple menu items.
  Can target items by IDs, category, or menu.
  """
  bulkAttachCustomizationTemplate(input: BulkAttachCustomizationTemplateInput!): BulkAttachCustomizationTemplateResponse!

  """
  Bulk detach a customization template from multiple menu items.
  Can target items by IDs, category, or menu.
  """
  bulkDetachCustomizationTemplate(input: BulkDetachCustomizationTemplateInput!): BulkAttachCustomizationTemplateResponse!

  """
   Deprecated: Use `assignUserToSection` instead.
  This will be removed after migration to SSPSectionAssignment is complete.
  """
  assignUserToTable(userId: ID!, tableId: ID!): SSPTableAssignment @deprecated(reason: "Use assignUserToSection(input: AssignSectionInput!) instead.")

  """
   Deprecated: Use `unassignUserFromSection` instead.
  This will be removed after migration to SSPSectionAssignment is complete.
  """
  unassignUserFromTable(id: ID!): Boolean @deprecated(reason: "Use unassignUserFromSection instead.")

  """
  Create a new table in a restaurant location.
  Add dining tables with capacity and positioning information.
  """
  createTable(locationId: ID!, input: CreateTableInput!): SSPTable

  """
  Edit an existing table's properties.
  Modify table capacity, name, or layout positioning.
  """
  editTable(locationId: ID!, id: ID!, input: EditTableInput!): SSPTable

  """
  Remove a table from the location.
  Delete table while preserving associated order history.
  """
  removeTable(locationId: ID!, id: ID!): Boolean

  """
  Register a new NFC tag to a table.
  Captures the hardware UID and associates it with a specific table.
  Generates the URL to be written to the tag.
  """
  registerNFCTag(input: RegisterNFCTagInput!): NFCTag!

  """
  Update an NFC tag's status.
  Use to mark tags as lost, damaged, or deactivated.
  """
  updateNFCTagStatus(input: UpdateNFCTagStatusInput!): NFCTag!

  """
  Reassign an NFC tag to a different table.
  Updates the tag's table association and regenerates the written URL.
  """
  reassignNFCTag(input: ReassignNFCTagInput!): NFCTag!

  """
  Delete an NFC tag (soft delete).
  Removes the tag from active use while preserving scan history.
  """
  deleteNFCTag(id: ID!): Boolean!

  """
  Scan and verify an NTAG 424 DNA tag from the Flutter app.
  Used by staff to verify a DNA tag before associating it with a table.
  
  The staff member scans the tag URL (e.g., /t?uid=...&ctr=...&mac=...)
  and this mutation verifies the MAC signature using the location's SDM key.
  
  Returns tag info if valid, or creates a new unassociated tag record.
  """
  scanNFCTagDNA(input: ScanNFCTagDNAInput!): ScanNFCTagDNAResult!

  """
  Associate a verified DNA tag with a table.
  The tag must have been previously scanned and verified via scanNFCTagDNA.
  """
  associateNFCTagDNA(input: AssociateNFCTagDNAInput!): NFCTag!

  """
  Claim an NFC tag from inventory and assign it to a table.
  The tag must exist in the nfc_tag_inventory table (imported via GoToTags CSV).
  The table must belong to the user's organization.
  
  This mutation:
  1. Looks up the tag UID in the inventory
  2. Creates an NFCTag record with the user's organization
  3. Soft-deletes the inventory record (preserving purchase history)
  """
  claimNFCTag(input: ClaimNFCTagInput!): NFCTag!

  """
  Create a visual layout for restaurant location.
  Define floor plan with table positioning and spatial arrangement.
  """
  createLocationLayout(locationId: ID!, input: LocationLayoutInput!): LocationLayout

  """
  Update an existing location layout.
  Modify floor plan design and table arrangements.
  """
  updateLocationLayout(id: ID!, input: LocationLayoutInput!): LocationLayout

  """
  Add table positioning to a layout.
  Place tables within the floor plan with coordinates and orientation.
  """
  addTableToLayout(layoutId: ID!, input: TableLayoutInput!): TableLayout

  """
  Delete a location layout.
  Remove floor plan while preserving table definitions.
  """
  deleteLocationLayout(id: ID!): Boolean

  """
  Create invitation for new team member.
  Send email invitation with role and location access permissions.
  
  Either `role` (system role) OR `customRoleId` must be provided, but not both.
  - Use `role` for system roles like WAIT_STAFF, LOCATION_MANAGER, etc.
  - Use `customRoleId` for custom roles created by your organization.
  """
  createInvitation(email: String!, role: AssignableRoles, customRoleId: ID, collections: [Int], locations: [Int]): String

  """
  Accept and consume a team invitation.
  Complete registration process using invitation code.
  """
  consumeInvitation(code: String!, email: String!): String

  """
  Update existing team member details.
  Modify member role, permissions, or location access.
  """
  updateMember(input: UpdateMemberInput!): UserWithRolesAndLocations!

  """
  Remove team member from organization.
  Revoke access and remove user from all locations.
  """
  removeMember(input: RemoveMemberInput!): RemoveMemberPayload!

  """
  Cancel pending invitation before acceptance.
  Invalidate invitation link and prevent registration.
  """
  cancelInvitation(input: CancelInvitationInput!): CancelInvitationPayload!

  """
  Resend invitation to team member.
  Generate new invitation link and send notification email.
  """
  resendInvitation(input: ResendInvitationInput!): ResendInvitationPayload!

  """
  Delete invitation record from system.
  Permanently remove invitation data and access codes.
  """
  deleteInvitation(input: DeleteInvitationInput!): DeleteInvitationPayload!

  """
  Create a new order for a table by table number.
  Start new dining order with items, waiter assignment, and party size.
  """
  createOrder(locationID: ID!, tableNumber: String!, waiterName: String!, partySize: Int!, restaurant: String!, orderItems: [OrderItemInput!]!, customerID: ID): CreateOrderResponse!

  """
  Create a new order for a specific table ID.
  Alternative creation method using table entity reference.
  """
  createOrderForTable(locationID: ID!, tableID: ID!, waiterName: String!, partySize: Int!, restaurant: String!, orderItems: [OrderItemInput!]!): CreateOrderResponse!

  """
  Create multiple orders in bulk for different tables.
  Efficient batch creation for high-volume order processing.
  """
  createOrdersForTables(locationID: ID!, orders: [OrderInput!]!): CreateBulkOrderResponse!

  """
  Update order priority and kitchen instructions.
  Modify order processing parameters and special instructions.
  """
  updateSSPTableOrder(orderId: String!, priority: TableOrderPriority, kitchen_instructions: JSON): SSPTableOrder

  """
  Add new items to an existing order.
  Append additional menu items to active orders.
  Accessible by authenticated staff or guests with valid order token.
  Guests can only add items to their own authenticated order.
  """
  addItemsToOrder(orderId: String!, items: [OrderItemInput!]!): AddItemsToOrderResponse!

  """
  Remove items from an existing order.
  Delete specific items from active orders before kitchen preparation.
  Accessible by authenticated staff or guests with valid order token.
  Guests can only remove items from their own order and only before submission.
  """
  removeItemsFromOrder(orderId: String!, itemIds: [Int!]!): RemoveItemsFromOrderResponse!

  """
  Update quantity of specific order item.
  Adjust item quantities in active orders.
  Accessible by authenticated staff or guests with valid order token.
  Guests can only modify items on their own order and only before submission.
  """
  updateOrderItemQuantity(orderId: String!, itemId: ID!, quantity: Int!): UpdateOrderItemQuantityResponse!

  """
  Submit guest order items to the kitchen.
  Guest-accessible endpoint for finalizing their added items.
  Only allows submission if order is in editable state and items haven't been sent.
  Does NOT require serverId - defaults to self-service (waiter_id=0).
  Guests can only submit items on their authenticated order.
  """
  submitGuestOrder(orderId: String!): SubmitOrderResponse!

  """
  Update multiple item quantities in single operation.
  Efficient bulk quantity updates for order modifications.
  """
  batchUpdateOrderItemQuantities(orderId: String!, items: [BatchOrderItemQuantityInput!]!): BatchUpdateOrderItemQuantitiesResponse!

  """
  Update order status in kitchen workflow.
  Progress order through preparation, ready, served states.
  """
  updateOrderStatus(orderId: String!, status: SSPOrderStatus!): UpdateOrderStatusResponse!

  """
  Update status for multiple orders simultaneously.
  Bulk status changes for kitchen workflow management.
  """
  batchUpdateOrderStatus(input: [UpdateOrderStatusInput!]!): BatchUpdateOrderStatusResponse!

  """
  Update status of items within order lists.
  Track preparation progress for individual menu items.
  """
  updateItemListStatus(input: UpdateItemListStatusInput!): UpdateItemListStatusPayload

  """
  Assign order to server/waiter.
  Used when an order is first created or needs initial server assignment.
  """
  assignOrderToServer(orderId: String!, serverId: ID!): AssignOrderToServerResponse!

  """
  Void an order after kitchen preparation or with partial payment.
  Requires manager approval (PIN) due to financial/inventory impact.
  
  Use this for: COOKING, SERVED, PROCESSING, PARTIALLY_PAID orders.
  For pre-kitchen orders, use cancelOrder instead (no manager needed).
  For fully paid orders, use refundOrder instead.
  """
  voidOrder(orderId: ID!, voidReason: String!, managerId: ID, managerPin: String): VoidOrderResponse!

  """
  Process refund for paid order through Stripe PaymentIntent.
  Support partial/full refunds with manager approval and PIN validation.
  Handles Stripe Connect account processing and transaction logging.
  """
  refundOrder(orderId: ID!, refundAmount: Float!, refundReason: String, managerId: ID, managerPin: String): SSPTableOrder!

  """
  Apply discount to an entire order.
  Supports percentage or fixed amount discounts.
  Requires manager approval for restricted users.
  """
  applyOrderDiscount(orderId: ID!, discountType: DiscountType!, discountValue: Float!, reason: String, managerId: ID, managerPin: String): ApplyDiscountResponse!

  """
  Apply discount to a specific item in an order.
  Supports percentage or fixed amount discounts.
  Requires manager approval for restricted users.
  """
  applyItemDiscount(orderId: ID!, itemId: Int!, discountType: DiscountType!, discountValue: Float!, reason: String, managerId: ID, managerPin: String): ApplyDiscountResponse!

  """
  Remove discount from an order.
  Clears all discount values and recalculates totals.
  """
  removeOrderDiscount(orderId: ID!): ApplyDiscountResponse!

  """
  Remove discount from a specific item in an order.
  Restores the item to its original price and clears discount tracking fields.
  Requires APPROVE_DISCOUNTS permission or manager override with PIN.
  """
  removeItemDiscount(orderId: ID!, itemId: Int!, managerId: ID, managerPin: String): ApplyDiscountResponse!

  """
  Cancel an order BEFORE it reaches the kitchen.
  No manager approval required since no food prepared and no financial impact.
  
  Use this for: CREATED, EDITABLE, PENDING orders only.
  For orders already in kitchen or paid, use voidOrder instead (requires manager).
  """
  cancelOrder(orderId: String!, reason: String): CancelOrderResponse!

  """
  Merge two orders into single combined order.
  Consolidate separate orders for same table or party.
  """
  mergeOrders(primaryOrderId: String!, secondaryOrderId: String!): MergeOrdersResponse!

  """
  Split order into multiple separate orders.
  Divide single order for separate payment or service.
  """
  splitOrder(orderId: String!, splitDetails: [SplitOrderDetailInput!]!): SplitOrderResponse!

  """
  Submit order to kitchen for preparation.
  Finalize order and begin kitchen workflow processing.
  tableId is optional for to-go, phone, or other non-table orders.
  """
  submitOrder(orderId: String!, tableId: ID, serverId: ID!): SubmitOrderResponse!

  """
  Move an order to a different table.
  Use this to transfer an order from one table to another, or to assign a to-go order to a table.
  Pass null for newTableId to convert a dine-in order to a to-go order.
  """
  moveOrderToTable(orderId: String!, newTableId: ID): MoveOrderToTableResponse!

  """
  Update remaining amount due on order.
  Adjust payment balance for partial payment processing.
  """
  updateOrderRemainingAmount(unique_orderid: String!, remaining_amount: Float!, paymentType: Int, name: String, sessionID: String!): Boolean

  """
  Increase remaining amount due on order.
  Add charges or adjust order total upward.
  """
  increaseOrderRemainingAmount(unique_orderid: String!, amount: Float!): Boolean

  """
  Decrease remaining amount due on order.
  Apply credits or adjust order total downward.
  """
  decreaseOrderRemainingAmount(unique_orderid: String!, amount: Float!): Boolean

  """
  Update selected items for payment session.
  Track which items customer is paying for in split billing.
  """
  updateOrderSelectedItems(unique_orderid: String!, sessionID: String!, selectedItems: [Int]!): Boolean

  """
  Create payment session for order.
  Initialize customer payment flow with session tracking.
  """
  CreateOrderJSONSession(unique_orderid: String!, name: String!, sessionID: String!): Boolean

  """
  Create Stripe PaymentIntent for order payment.
  Initialize secure payment processing through Stripe Connect.
  Supports tips, multiple payment methods, and partial payments.
  
  When breakdown is provided, server verifies all amounts match its calculations
  to prevent client-side amount manipulation. Strongly recommended for security.
  
  Error codes on verification failure:
  - SUBTOTAL_MISMATCH, TAX_MISMATCH, SERVICE_CHARGE_MISMATCH, TOTAL_MISMATCH
  - ORDER_MODIFIED (multiple fields differ - order was updated, please refresh)
  - NEGATIVE_TIP, EXCEEDS_REMAINING_BALANCE
  """
  CreateOrderPaymentIntent(
    unique_orderid: String!
    amount: Float!
    currency: String!
    sessionID: String!
    tipAmount: Float
    paymentType: Int
    paymentMethodTypes: [String!]
    locationID: ID!

    """
    Optional payment breakdown for server-side verification.
    When provided, server verifies all amounts match its calculations.
    Strongly recommended for security.
    """
    breakdown: PaymentBreakdownInput
  ): PaymentIntentResponse

  """
  Record a manual payment for an order.
  Used by waiters to mark orders as paid with cash, check, or other non-card methods.
  Creates a transaction record and updates the order's remaining balance.
  """
  recordManualPayment(input: RecordManualPaymentInput!): RecordManualPaymentResponse!

  """
  Create payment intent for virtual terminal manual entry.
  Allows managers/waiters to manually process credit cards via Stripe widget.
  PCI-compliant: SSP never stores or processes card details directly.
  
  When orderId is provided with breakdown, full server-side verification is performed
  (same as CreateOrderPaymentIntent). When orderId is provided without breakdown,
  only validates that base payment doesn't exceed remaining balance.
  """
  createManualPaymentIntent(
    amount: Float!
    currency: String!
    locationID: ID!
    orderId: ID
    employeeID: ID
    tipAmount: Float
    customerEmail: String
    customerName: String
    description: String
    paymentMethodTypes: [String!]

    """
    Optional payment breakdown for server-side verification.
    When provided with orderId, verifies all amounts match server calculations.
    Same verification as CreateOrderPaymentIntent.
    """
    breakdown: PaymentBreakdownInput
  ): PaymentIntentResponse

  """
  Confirm payment intent for virtual terminal.
  Note: Typically auto-confirmed by Stripe Elements.
  Use for manual confirmation scenarios only.
  """
  confirmManualPaymentIntent(paymentIntentId: String!, locationID: ID!): PaymentConfirmationResponse

  """
  Cancel payment intent for virtual terminal.
  Used when transaction is abandoned before completion.
  """
  cancelManualPaymentIntent(paymentIntentId: String!, locationID: ID!, cancellationReason: String): PaymentCancellationResponse

  """
  Refund a manual payment (full or partial).
  Used for customer service scenarios like returns or order corrections.
  Supports partial refunds by specifying an amount, or full refund if amount is omitted.
  """
  refundManualPayment(paymentIntentId: String!, locationID: ID!, amount: Float, reason: String, employeeID: ID): PaymentRefundResponse

  """
  Add new printer job to queue.
  Schedule printing tasks for receipts, kitchen orders, or reports.
  """
  addPrinterJob(input: AddPrinterJobInput!): SSPPrinterJob!

  """
  Update existing printer job configuration.
  Modify job type, priority, or printing parameters.
  """
  updatePrinterJob(printerJobId: ID!, jobType: String!): SSPPrinterJob!

  """
  Delete printer job from queue.
  Cancel scheduled print tasks before execution.
  """
  deletePrinterJob(printerJobId: ID!): Boolean!

  """
  Authenticate printer with security passcode.
  Verify printer access credentials for secure printing.
  """
  authenticatePrinterPasscode(passcode: String!): AuthResult!

  """
  Update printer configuration and settings.
  Modify printer properties, connection details, or print settings.
  """
  updatePrinter(locationId: ID!, printerId: ID!, input: SSPPrinterInput!): SSPPrinter!

  """
  Remove printer from location.
  Delete printer configuration and stop print job routing.
  """
  deletePrinter(locationId: ID!, printerId: ID!): Boolean!

  """
   Deprecated: Use 'sendPrintRequest2' instead.
  Send simple print request to specified printer.
  """
  sendPrintRequest(printerId: ID!, content: String!): PrintRequestResponse @deprecated(reason: "This mutation is deprecated and will be removed in a future release. Use 'sendPrintRequest2' instead.")

  """
  Send structured print request with payload.
  
  This mutation supports unified routing to both printer types:
  - RabbitMQ printers (via PrinterManagement desktop app)
  - Star CloudPRNT printers (direct HTTP polling, no PC required)
  
  The backend automatically detects the printer type based on the printerId
  and routes the job accordingly. For CloudPRNT printers, PDF content is
  automatically converted to PNG for compatibility.
  
  Returns a jobToken for CloudPRNT printers (useful for tracking job status).
  """
  sendPrintRequest2(printerId: ID!, payload: PrintRequestInput!): PrintRequestResponse

  """
  Create a new customer record.
  Used for phone orders, catering, or manual entry.
  Requires: create_customers permission
  """
  createCustomer(input: CreateCustomerInput!): SSPOrderCustomer!

  """
  Update an existing customer record.
  Requires: update_customers permission
  """
  updateCustomer(input: UpdateCustomerInput!): SSPOrderCustomer!

  """
  Delete a customer record (soft delete).
  Requires: delete_customers permission
  Note: This soft-deletes the customer but preserves order history.
  """
  deleteCustomer(id: ID!): SSPOrderCustomer!

  "Merge two customer records, transferring all orders and data to the primary customer."
  mergeCustomers(primary_id: ID!, secondary_id: ID!): SSPOrderCustomer!

  "Attach or detach a customer from an existing order (for delivery/takeout orders)."
  updateOrderCustomer(orderID: ID!, customerID: ID): SSPTableOrder!

  "Update the party size (number of guests) for an existing order."
  updateOrderPartySize(orderID: ID!, partySize: Int!): SSPTableOrder!

  """
  Initiate OAuth connection to Uber Eats.
  Returns an authorization URL that the user should visit to grant access.
  """
  connectUberEats(input: ConnectUberEatsInput): ConnectUberEatsResponse!

  """
  Disconnect from Uber Eats and revoke access.
  This will stop syncing orders from Uber Eats.
  """
  disconnectUberEats(input: DisconnectUberEatsInput!): DisconnectUberEatsResponse!

  """
  Configure visibility of a single analytics field for a specific role.
  
  Requires: manage_analytics_visibility permission (typically for managers)
  
  The roleId parameter accepts multiple formats:
  - Numeric Spatie role ID: "6"
  - Role name string: "location_manager", "wait_staff"
  - Custom role with prefix: "custom:42"
  
  Examples:
  ```graphql
  # Using role name (recommended)
  mutation {
    updateAnalyticsFieldVisibility(input: {
      roleId: "location_manager"
      fieldName: "shift_summary.total_sales"
      isVisible: false
    }) {
      id
      is_visible
    }
  }
  
  # Using custom role
  mutation {
    updateAnalyticsFieldVisibility(input: {
      roleId: "custom:42"
      fieldName: "shift_summary.tips_earned"
      isVisible: true
    }) {
      id
      is_visible
    }
  }
  ```
  """
  updateAnalyticsFieldVisibility(input: AnalyticsFieldVisibilityInput!): AnalyticsFieldVisibility

  """
  Configure visibility of multiple fields at once for a role.
  More efficient for UI that shows a full configuration page.
  
  Requires: manage_analytics_visibility permission
  
  The roleId parameter accepts multiple formats:
  - Numeric Spatie role ID: "6"
  - Role name string: "location_manager", "wait_staff"
  - Custom role with prefix: "custom:42"
  
  Examples:
  ```graphql
  # Using role name (recommended)
  mutation {
    updateBulkAnalyticsFieldVisibility(input: {
      roleId: "wait_staff"
      fields: [
        { fieldName: "shift_summary.total_sales", isVisible: false },
        { fieldName: "shift_summary.tips_earned", isVisible: true }
      ]
    }) {
      id
      field_name
      is_visible
    }
  }
  
  # Using custom role with location-specific settings
  mutation {
    updateBulkAnalyticsFieldVisibility(input: {
      roleId: "custom:42"
      locationId: "5"
      fields: [
        { fieldName: "analytics.team_comparison", isVisible: false }
      ]
    }) {
      id
      field_name
      is_visible
      location_id
    }
  }
  ```
  """
  updateBulkAnalyticsFieldVisibility(input: BulkFieldVisibilityInput!): [AnalyticsFieldVisibility!]!

  """
  Create a support session to access a customer organization.
  
  **SUPPORT_ADMIN ONLY**
  
  This creates a time-limited session that:
  - Logs entry to transaction_logs (customer-visible)
  - Sends email notification to organization admins
  - Validates Jira ticket (if provided and enabled)
  - Creates complete audit trail
  - Switches database context to customer organization
  
  The session is stored in Laravel session and detected by middleware.
  All subsequent requests will be in the context of the customer organization.
  """
  createSupportSession(input: CreateSupportSessionInput!): CreateSupportSessionPayload!

  """
  End a support session.
  
  **SUPPORT_ADMIN ONLY**
  
  If sessionId is provided, ends that specific session (must belong to current user).
  If sessionId is omitted, ends the currently focused session (backwards compatible).
  
  This will:
  - Mark session as ended
  - Calculate session statistics
  - Log exit to transaction_logs (customer-visible)
  - Send summary email to organization admins
  - Post summary to Jira ticket (if configured)
  - Clear focused session if it was the one being ended
  
  The session is removed from Laravel session.
  """
  endSupportSession(
    """
    Optional session ID to end.
    If not provided, ends the currently focused session.
    """
    sessionId: ID
  ): EndSupportSessionPayload!

  """
  Switch focus to a different active support session.
  
  **SUPPORT_ADMIN ONLY**
  
  This changes which organization context is active without ending
  the previous session. Allows agents to maintain multiple concurrent
  sessions and switch between them as needed.
  
  The session must:
  - Belong to the current user
  - Be currently active (not ended or expired)
  
  After switching, all subsequent requests will be in the context
  of the newly focused organization.
  """
  switchSupportSession(
    "The session ID to switch focus to"
    sessionId: ID!
  ): SwitchSupportSessionPayload!

  """
  Send a print request to a CloudPRNT printer.
  The job will be queued and the printer will retrieve it on next poll.
  
  For PDF content, the server will automatically convert to PNG
  for compatibility with all Star CloudPRNT printers.
  """
  sendCloudPrintRequest(cloudPrinterId: ID!, payload: CloudPrintPayloadInput!): CloudPrintResponse!

  """
  Update a CloudPRNT printer's configuration.
  Set alias, job types, paper width, or DPI.
  """
  updateCloudPrinter(id: ID!, input: UpdateCloudPrinterInput!): CloudPrinter

  """
  Delete a CloudPRNT printer.
  This will also delete all pending print jobs for the printer.
  """
  deleteCloudPrinter(id: ID!): CloudPrintResponse!

  """
  Cancel a pending cloud print job.
  Only jobs with PENDING status can be cancelled.
  """
  cancelCloudPrintJob(jobToken: String!): CloudPrintResponse!

  """
  Create or update kitchen capacity configuration (SSP Manager)
  Staff only - requires JWT authentication and manage_kitchen_capacity permission.
  """
  upsertKitchenCapacityConfig(input: KitchenCapacityConfigInput!): KitchenCapacityConfigResponse!

  """
  Update manual kitchen load override (SSP Kitchen/KDS)
  Staff only - requires JWT authentication and override_kitchen_load permission.
  """
  updateKitchenLoadOverride(input: KitchenLoadOverrideInput!): KitchenLoadOverrideResponse!

  """
  Remove manual override and return to auto-calculation
  Staff only - requires JWT authentication and override_kitchen_load permission.
  """
  clearKitchenLoadOverride(locationId: ID!, stationCategoryValue: Int): KitchenLoadOverrideResponse!

  """
  Capture a snapshot of current kitchen load for analytics (Internal/Cron)
  Staff only - requires JWT authentication and manage_kitchen_capacity permission.
  """
  captureKitchenLoadSnapshot(locationId: ID!): KitchenLoadSnapshotResponse!

  "Submit new plugin integration"
  submitPluginIntegration(input: SubmitPluginIntegrationInput!): PluginIntegration!

  "Update plugin integration"
  updatePluginIntegration(id: ID!, input: UpdatePluginIntegrationInput!): PluginIntegration!

  "Submit plugin for review"
  submitPluginForReview(id: ID!): PluginIntegration!

  "Publish plugin (requires approval)"
  publishPlugin(id: ID!): PluginIntegration!

  "Unpublish plugin"
  unpublishPlugin(id: ID!): PluginIntegration!

  "Delete plugin"
  deletePlugin(id: ID!): Boolean!

  "Install plugin for current organization"
  installPlugin(input: InstallPluginInput!): InstallPluginResponse!

  "Uninstall plugin from current organization"
  uninstallPlugin(installation_id: ID!): UninstallPluginResponse!
}

"Auto-generated Permissions enum via 'php artisan export:permissions-graphql-enum'"
enum Permissions {
  """
  Add Items to Order
  Allows adding menu items to existing orders.
  Useful when customers order additional items after the initial order.
  """
  ADD_ITEMS_TO_ORDER

  """
  Add Tables to Layouts
  Allows placing tables into floor plan layouts.
  Essential for building and organizing dining area configurations.
  """
  ADD_TABLE_TO_LAYOUT

  """
  Adjust Clock Entries
  Allows modifying clock-in/out times for corrections.
  Important for fixing mistakes or handling special situations.
  """
  ADJUST_CLOCK_ENTRY

  """
  Adjust Order Remaining Amount
  Allows manually adjusting the remaining amount due on an order.
  Typically used for corrections, discounts, or special situations.
  """
  ADJUST_ORDER_REMAINING_AMOUNT

  """
  Allow Third-Party Integrations
  Allows connecting external services and integrations to your account.
  Use this to enable features like delivery platforms or accounting software.
  """
  ALLOW_INTEGRATIONS

  """
  Approve Cash Drawer Variance
  Allows approving cash drawer variances (overages/shortages).
  Manager-level permission for reconciliation.
  """
  APPROVE_CASH_DRAWER_VARIANCE

  """
  Approve Discounts
  Allows applying and approving discounts on orders and items.
  Required to apply percentage or fixed amount discounts without manager override.
  Staff without this permission can still apply discounts with manager approval.
  """
  APPROVE_DISCOUNTS

  """
  Approve Flagged Clock Entries
  Allows approving time entries that were flagged for review.
  Manager permission for handling time clock exceptions.
  """
  APPROVE_FLAGGED_CLOCK_ENTRY

  """
  Approve Table Transfers
  Allows approving table transfer requests from other staff.
  Important for maintaining control over table assignments.
  """
  APPROVE_TABLE_TRANSFER

  """
  Assign Location Groups to Team Members
  Allows assigning location groups (collections) to team members.
  Collections group multiple locations together for easier management.
  """
  ASSIGN_COLLECTIONS_TO_MEMBER

  """
  Assign Custom Roles to Team Members
  Allows assigning your organization's custom roles to team members.
  This gives staff the specific combination of permissions defined in the custom role.
  """
  ASSIGN_CUSTOM_ROLE

  """
  Assign Locations to Team Members
  Allows assigning specific restaurant locations to team members.
  This determines which locations a staff member can access and manage.
  """
  ASSIGN_LOCATIONS_TO_MEMBER

  """
  Assign Orders
  Allows assigning orders to specific staff members.
  Helps track which server is responsible for which tables or orders.
  """
  ASSIGN_ORDERS

  """
  Assign Accounting Role
  Allows granting Accounting access to team members.
  Accounting staff can view financial reports and manage billing information.
  """
  ASSIGN_ROLE_ACCOUNTING

  """
  Assign Cashier Role
  Allows granting Cashier access to team members.
  Cashiers can process payments and manage cash drawer operations.
  """
  ASSIGN_ROLE_CASHIER

  """
  Assign Chain Manager Role
  Allows granting Chain Manager access to team members.
  Chain Managers can oversee multiple locations and manage location-level staff.
  """
  ASSIGN_ROLE_CHAIN_MANAGER

  """
  Assign Floor Manager Role
  Allows granting Floor Manager access to team members.
  Floor Managers oversee day-to-day floor operations and can manage tables and orders.
  """
  ASSIGN_ROLE_FLOOR_MANAGER

  """
  Assign Kitchen Staff Role
  Allows granting Kitchen Staff access to team members.
  Kitchen Staff can view and update order preparation status.
  """
  ASSIGN_ROLE_KITCHEN_STAFF

  """
  Assign Location Manager Role
  Allows granting Location Manager access to team members.
  Location Managers can manage staff and operations for specific locations.
  """
  ASSIGN_ROLE_LOCATION_MANAGER

  """
  Assign Organization Admin Role
  Allows granting the highest level of access (Organization Administrator) to team members.
  This role has full control over all locations, collections, and settings within the organization.
  """
  ASSIGN_ROLE_ORGANIZATION_ADMIN

  """
  Assign Wait Staff Role
  Allows granting Wait Staff access to team members.
  Wait Staff can take orders, manage tables, and process payments.
  """
  ASSIGN_ROLE_WAIT_STAFF

  """
  Assign Staff to Shifts
  Allows assigning team members to work specific shifts.
  Essential for building and managing work schedules.
  """
  ASSIGN_USER_TO_SHIFT

  """
  Assign Staff to Tables
  Allows assigning servers or staff members to specific tables.
  Essential for managing table sections and server responsibilities.
  """
  ASSIGN_USER_TO_TABLE

  """
  Attach Items to Menu Categories
  Allows adding menu items to specific categories.
  Helps organize items into appropriate sections like appetizers or desserts.
  """
  ATTACH_MENU_CATEGORY_ITEM

  """
  Attach Menu Items
  Allows linking menu items to menus or categories.
  Useful for organizing items across different menu sections.
  """
  ATTACH_MENU_ITEM

  """
  Authenticate Printers
  Allows connecting and authenticating physical printers to the system.
  Required for initial printer setup and configuration.
  """
  AUTHENTICATE_PRINTER

  """
  Batch Update Order Status
  Allows updating the status of multiple orders at once.
  Useful for marking multiple orders as ready or completed simultaneously.
  """
  BATCH_UPDATE_ORDER_STATUS

  """
  Cancel Clock Entries
  Allows removing invalid or erroneous clock entries.
  Use when entries were created by mistake.
  """
  CANCEL_CLOCK_ENTRY

  """
  Cancel Invitations
  Allows canceling pending invitations that haven't been accepted yet.
  Use when invitation was sent in error or candidate declined.
  """
  CANCEL_INVITATION

  """
  Cancel Orders
  Allows canceling orders before or during preparation.
  Use when customers change their mind or there are issues with the order.
  """
  CANCEL_ORDERS

  """
  Change Email Address
  Allows changing your account email address.
  Important for maintaining accurate contact information.
  """
  CHANGE_EMAIL

  """
  Change Password
  Allows updating your account password.
  Essential for maintaining account security.
  """
  CHANGE_PASSWORD

  """
  Clock In
  Allows recording the start of a work shift.
  Essential for staff to log their working hours.
  """
  CLOCK_IN

  """
  Clock Out
  Allows recording the end of a work shift.
  Required for completing time tracking entries.
  """
  CLOCK_OUT

  """
  Close Cash Drawer
  Allows closing a cash drawer session with a counted closing amount.
  Required for staff who handle cash transactions.
  """
  CLOSE_CASH_DRAWER

  """
  Complete Onboarding Steps
  Allows marking onboarding tasks as completed.
  Used during the initial setup process for new team members.
  """
  COMPLETE_ONBOARDING_STEP

  """
  Configure Payment Provider
  Allows connecting and configuring payment providers (Stripe Connect, Clover).
  This permission is required to set up payment processing for locations.
  """
  CONFIGURE_PAYMENT_PROVIDER

  """
  Consume Invitations
  Allows accepting and processing invitations to join the organization.
  Used during the onboarding process for new team members.
  """
  CONSUME_INVITATION

  """
  Create Location Groups
  Allows creating new location groups (collections) to organize multiple restaurants together.
  Useful for grouping locations by region, brand, or management structure.
  """
  CREATE_COLLECTION

  """
  Create Customers
  Allows creating new customer records for phone orders, catering, or manual entry.
  Useful for capturing customer information for delivery and takeout orders.
  """
  CREATE_CUSTOMERS

  """
  Create Custom Roles
  Allows creating custom staff roles with specific permission combinations.
  Use this to define roles tailored to your restaurant's unique needs (e.g., "Barista", "Host").
  """
  CREATE_CUSTOM_ROLE

  """
  Create Custom Taxes
  Allows creating special or one-time tax rules.
  Useful for temporary taxes or special tax situations.
  """
  CREATE_CUSTOM_TAX

  """
  Create Invitations
  Allows sending invitations to new team members to join the organization.
  Essential for onboarding new staff members.
  """
  CREATE_INVITATION

  """
  Create Layouts
  Allows creating new floor plan layouts for restaurant locations.
  Essential for setting up different dining areas or service configurations.
  """
  CREATE_LAYOUT

  """
  Create Locations
  Allows adding new restaurant locations to your organization.
  Use this when opening new restaurants or adding existing ones to the system.
  """
  CREATE_LOCATION

  """
  Create Location Taxes
  Allows creating location-specific tax configurations.
  Essential for managing different tax rates across multiple locations.
  """
  CREATE_LOCATION_TAX

  """
  Create Menus
  Allows creating new menus for your restaurants (e.g., breakfast, lunch, dinner, drinks).
  Essential for organizing menu items by meal period or category.
  """
  CREATE_MENU

  """
  Create Menu Categories
  Allows creating new menu categories (e.g., Appetizers, Entrees, Desserts, Beverages).
  Essential for organizing menu items into logical groupings.
  """
  CREATE_MENU_CATEGORY

  """
  Create Menu Items
  Allows adding new dishes, drinks, or products to your menu catalog.
  Essential for building and expanding your menu offerings.
  """
  CREATE_MENU_ITEM

  """
  Create Orders
  Allows starting new customer orders and adding them to the system.
  Essential for wait staff and cashiers to serve customers.
  """
  CREATE_ORDERS

  """
  Create Order JSON Session
  Allows creating temporary order sessions for draft orders.
  Technical permission for managing in-progress order data.
  """
  CREATE_ORDER_JSON_SESSION

  """
  Create Order Payment Intent
  Allows initiating payment processing for orders.
  Required for accepting payments through integrated payment gateways.
  """
  CREATE_ORDER_PAYMENT_INTENT

  """
  Create PIN Code
  Allows setting up a new PIN code for quick login.
  Useful for staff who frequently use POS terminals.
  """
  CREATE_PIN_CODE

  """
  Create Printer Jobs
  Allows creating new print jobs for receipts, kitchen tickets, or reports.
  Essential for sending items to be printed.
  """
  CREATE_PRINTER_JOB

  """
  Create Shifts
  Allows creating new work shifts for scheduling staff.
  Essential for building employee schedules.
  """
  CREATE_SHIFT

  """
  Create Stripe Dashboard Link
  Allows generating secure links to access the Stripe payment dashboard.
  Useful for viewing payment analytics and managing payouts.
  """
  CREATE_STRIPE_DASHBOARD_LINK

  """
  Create Stripe Express Account
  Allows setting up a Stripe Express account for payment processing.
  Essential for accepting credit card payments at your locations.
  """
  CREATE_STRIPE_EXPRESS_ACCOUNT

  """
  Create Stripe Terminal Location
  Allows creating a Stripe Terminal location for Tap to Pay functionality.
  Required to enable Tap to Pay on iPhone/Android devices.
  """
  CREATE_STRIPE_TERMINAL_LOCATION

  """
  Create Tables
  Allows adding new tables to your restaurant floor plans.
  Essential for setting up dining areas and seating arrangements.
  """
  CREATE_TABLE

  """
  Create Tax Rules
  Allows creating new tax calculation rules for your organization.
  Essential for setting up sales tax, VAT, or other tax requirements.
  """
  CREATE_TAX_RULE

  """
  Delete Location Groups
  Allows removing location groups that are no longer needed.
  Note: Groups cannot be deleted if they still contain locations.
  """
  DELETE_COLLECTION

  """
  Delete Customers
  Allows soft-deleting customer records while preserving order history.
  Typically requires manager approval for data privacy compliance.
  """
  DELETE_CUSTOMERS

  """
  Delete Custom Roles
  Allows removing custom roles that are no longer needed.
  Note: Roles cannot be deleted if they are currently assigned to team members.
  """
  DELETE_CUSTOM_ROLE

  """
  Delete Images
  Allows removing images from the system.
  Use when images are outdated or no longer needed.
  """
  DELETE_IMAGE

  """
  Delete Invitations
  Allows removing invitation records from the system.
  Use for cleanup of old or invalid invitations.
  """
  DELETE_INVITATION

  """
  Delete Layouts
  Allows removing floor plan layouts that are no longer needed.
  Useful when restructuring restaurant spaces.
  """
  DELETE_LAYOUT

  """
  Delete Locations
  Allows removing locations from the system.
  Use with caution as this action may affect historical data and reporting.
  """
  DELETE_LOCATION

  """
  Delete Location Taxes
  Allows removing location-specific tax configurations.
  Use when locations close or tax requirements change.
  """
  DELETE_LOCATION_TAX

  """
  Delete Menus
  Allows removing menus that are no longer in use.
  Note: This may affect menu items and historical data.
  """
  DELETE_MENU

  """
  Delete Menu Categories
  Allows removing menu categories that are no longer needed.
  Note: Categories with items may need to be emptied first.
  """
  DELETE_MENU_CATEGORY

  """
  Delete Menu Items
  Allows removing menu items that are no longer offered.
  Note: This may affect historical orders and reporting.
  """
  DELETE_MENU_ITEM

  """
  Delete Printers
  Allows removing printers from the system.
  Use when decommissioning or replacing printer hardware.
  """
  DELETE_PRINTER

  """
  Delete Printer Jobs
  Allows removing print jobs from the queue.
  Use this to cancel unwanted or duplicate print requests.
  """
  DELETE_PRINTER_JOB

  """
  Delete Shifts
  Allows removing shifts from the schedule.
  Use when canceling shifts or cleaning up old schedules.
  """
  DELETE_SHIFT

  """
  Delete Tax Rules
  Allows removing tax rules that are no longer applicable.
  Use with caution as this affects financial calculations.
  """
  DELETE_TAX_RULE

  """
  Detach Items from Menu Categories
  Allows removing menu items from categories without deleting them.
  Useful for reorganizing menu structure.
  """
  DETACH_MENU_CATEGORY_ITEM

  """
  Detach Menu Items
  Allows removing menu items from menus or categories without deleting them.
  Helps with seasonal menu changes and item organization.
  """
  DETACH_MENU_ITEM

  """
  Disable Two-Factor Authentication
  Allows turning off two-factor authentication for your account.
  Use with caution as this reduces account security.
  """
  DISABLE_2FA

  """
  Edit Tables
  Allows modifying table properties such as number, capacity, and position.
  Use this to update floor plans and table configurations.
  """
  EDIT_TABLE

  """
  Enable Two-Factor Authentication
  Allows activating two-factor authentication for enhanced account security.
  Recommended for all users, especially those with elevated permissions.
  """
  ENABLE_2FA

  """
  Export Reports
  Allows downloading reports in various formats (CSV, PDF, Excel).
  Essential for external analysis and record-keeping.
  """
  EXPORT_REPORTS

  """
  Fetch All Printers
  Allows retrieving the complete list of configured printers.
  Essential for printer management and configuration.
  """
  FETCH_ALL_PRINTERS

  """
  Fetch Printers by Job Type
  Allows retrieving printers configured for specific job types (receipt, kitchen, etc.).
  Technical permission for routing print jobs to correct printers.
  """
  FETCH_PRINTERS_BY_JOB

  """
  Fetch Printer Passcode
  Allows retrieving printer authentication passcodes.
  Required for secure printer setup and pairing.
  """
  FETCH_PRINTER_PASSCODE

  """
  Generate PIN Code
  Allows generating a server-side unique PIN code for a user.
  Best practice for managers to create PINs to prevent collisions.
  """
  GENERATE_PIN_CODE

  """
  Generate Presigned URLs
  Allows creating secure, temporary URLs for image access.
  Technical permission for secure image delivery and downloads.
  """
  GENERATE_PRESIGNED_URLS

  """
  Link Uber Eats Account
  Allows connecting your restaurant to Uber Eats for delivery orders.
  Essential for enabling Uber Eats integration.
  """
  LINK_UBEREATS_ACCOUNT

  """
  Login with PIN Code
  Allows signing in using a PIN code instead of password.
  Convenient for quick staff login on shared devices.
  """
  LOGIN_WITH_PIN_CODE

  """
  Manage Analytics Field Visibility
  Allows configuring which analytics fields are visible to different roles.
  Managers use this to control what data wait staff can see in their analytics.
  Can configure visibility at organization-wide or location-specific levels.
  """
  MANAGE_ANALYTICS_VISIBILITY

  """
  Manage Billing
  Allows updating payment methods, billing information, and subscriptions.
  Essential for account owners to manage their subscription.
  """
  MANAGE_BILLING

  """
  Manage Cash Drawers
  Allows full management of cash drawers including closing others' drawers.
  Manager-level permission for cash drawer administration.
  """
  MANAGE_CASH_DRAWERS

  """
  Manage Clover Onboarding
  Allows initiating Clover OAuth flow and disconnecting Clover from locations.
  Essential for connecting restaurant locations to their Clover merchant accounts.
  """
  MANAGE_CLOVER_ONBOARDING

  """
  Manage Collection Menu Categories
  Allows editing and deleting menu categories that are shared across all locations in a collection.
  This permission is required to modify collection-scoped categories (location_coll_id set).
  Changes made to collection categories affect all restaurants in that collection.
  """
  MANAGE_COLLECTION_CATEGORIES

  """
  Manage Collection Menus
  Allows editing and deleting menus that are shared across all locations in a collection.
  This permission is required to modify collection-scoped menus (location_coll_id set).
  Changes made to collection menus affect all restaurants in that collection.
  """
  MANAGE_COLLECTION_MENUS

  """
  Manage Collection Menu Items
  Allows editing and deleting menu items that are shared across all locations in a collection.
  This permission is required to modify collection-scoped items (location_coll_id set).
  Changes made to collection items affect all restaurants in that collection.
  """
  MANAGE_COLLECTION_MENU_ITEMS

  """
  Manage Customers
  Allows advanced customer operations like merging duplicate records.
  Reserved for managers handling customer data quality.
  """
  MANAGE_CUSTOMERS

  """
  Manage Integrations
  Allows managing third-party integrations such as connecting, disconnecting, and configuring delivery platforms.
  Essential for setting up and maintaining integrations with services like Uber Eats.
  """
  MANAGE_INTEGRATIONS

  """
  Manage Kitchen Capacity
  Allows configuring kitchen capacity settings including load thresholds and time multipliers.
  Used by managers to optimize preparation time estimates based on kitchen workload.
  """
  MANAGE_KITCHEN_CAPACITY

  """
  Manage Location Staff
  Allows assigning and managing staff at specific locations.
  Important for controlling which staff can access each restaurant.
  """
  MANAGE_LOCATION_STAFF

  """
  Manage Menu Schedule
  Allows scheduling when menus are active or available.
  Essential for managing breakfast, lunch, dinner, and seasonal menus.
  """
  MANAGE_MENU_SCHEDULE

  """
  Manage NFC Tags
  Allows registering, updating, and deactivating NFC tags for tables.
  Required for setting up NFC-based table identification for guest ordering.
  """
  MANAGE_NFC_TAGS

  """
  Manage Orders
  Allows comprehensive management of orders including advanced operations and bulk actions.
  This is a high-level permission for managers who need full order system control.
  """
  MANAGE_ORDERS

  """
  Manage Organizations
  Allows administering organization settings and configuration.
  High-level permission for organization-wide management.
  """
  MANAGE_ORGANIZATIONS

  """
  Manage User Permissions
  Allows directly modifying user permissions without using roles.
  Advanced permission for granular access control.
  """
  MANAGE_USER_PERMISSIONS

  """
  Mark Feature As Seen
  Allows marking features as seen to remove the "new" indicator.
  Used when users acknowledge they've seen a new feature.
  """
  MARK_FEATURE_SEEN

  """
  Mark Release Note As Viewed
  Allows marking release notes as viewed.
  Used when users acknowledge they've read the release notes.
  """
  MARK_RELEASE_NOTE_VIEWED

  """
  View Own Profile
  Allows viewing your own user profile and information.
  Basic permission for accessing personal account details.
  """
  ME

  """
  Merge Orders
  Allows combining multiple orders into a single order.
  Useful when consolidating tables or combining party checks.
  """
  MERGE_ORDERS

  """
  Open Cash Drawer
  Allows opening a new cash drawer session with an opening amount.
  Required for staff who handle cash transactions.
  """
  OPEN_CASH_DRAWER

  """
  Override Kitchen Load
  Allows manually adjusting kitchen load multipliers from the KDS.
  Useful for temporarily overriding automatic calculations during rush periods or staff changes.
  """
  OVERRIDE_KITCHEN_LOAD

  """
  Process Menu Images
  Allows batch processing and optimization of menu item images.
  Useful for resizing, cropping, or optimizing images for display.
  """
  PROCESS_MENU_IMAGES

  """
  Refresh Stripe Onboarding
  Allows restarting or updating the Stripe account setup process.
  Useful when onboarding wasn't completed or needs updates.
  """
  REFRESH_STRIPE_ONBOARDING

  """
  Refund Orders
  Allows processing refunds for completed orders.
  Important for customer service and handling payment reversals.
  """
  REFUND_ORDERS

  """
  Remove Items from Order
  Allows removing items from orders before they're finalized.
  Use when customers change their mind or items are unavailable.
  """
  REMOVE_ITEMS_FROM_ORDER

  """
  Remove Team Members
  Allows removing team members from the organization.
  Use when staff members leave or access needs to be revoked.
  """
  REMOVE_MEMBER

  """
  Remove Tables
  Allows deleting tables from floor plans.
  Useful when restructuring dining areas or removing unused tables.
  """
  REMOVE_TABLE

  """
  Resend Invitations
  Allows sending invitation emails again to team members who didn't receive them.
  Helpful when invitations expire or get lost.
  """
  RESEND_INVITATION

  """
  Resend PIN Code
  Allows resending a PIN code via email to a user.
  Useful when staff members lose or forget their PIN and need it re-sent.
  """
  RESEND_PIN_CODE

  """
  Reset PIN Code
  Allows resetting a forgotten or compromised PIN code.
  Typically requires manager approval or identity verification.
  """
  RESET_PIN_CODE

  """
  Search Menu Categories
  Allows searching for menu categories by name or other criteria.
  Helps quickly find specific menu sections.
  """
  SEARCH_MENU_CATEGORIES

  """
  Search Menu Items
  Allows searching for menu items by name, description, or other criteria.
  Helps staff quickly find specific items when taking orders.
  """
  SEARCH_MENU_ITEMS

  """
  Send Print Requests
  Allows dispatching print jobs to physical printers.
  Required for printing receipts, kitchen tickets, and reports.
  """
  SEND_PRINT_REQUEST

  """
  Skip Onboarding
  Allows bypassing onboarding steps or the entire onboarding process.
  Useful for experienced users or when onboarding isn't needed.
  """
  SKIP_ONBOARDING

  """
  Split Orders
  Allows dividing a single order into multiple separate orders.
  Essential for splitting checks when customers want to pay separately.
  """
  SPLIT_ORDERS

  """
  Start Trial
  Allows initiating a free trial of premium features.
  Useful for testing features before committing to a paid plan.
  """
  START_TRIAL

  """
  Submit Orders
  Allows finalizing and sending orders to the kitchen for preparation.
  This commits the order and begins the fulfillment process.
  """
  SUBMIT_ORDERS

  """
  Switch Payment Provider
  Allows switching the active payment provider for a location between Stripe and Clover.
  Separate from configuration to control who can change which provider processes payments.
  """
  SWITCH_PAYMENT_PROVIDER

  """
  Transfer Tables
  Allows transferring table ownership from one server to another.
  Requires PIN verification for security and accountability.
  """
  TRANSFER_TABLE

  """
  Transfer Tables Without PIN
  Allows transferring tables without requiring PIN verification.
  Typically reserved for managers who can override normal security.
  """
  TRANSFER_TABLE_WITHOUT_PIN

  """
  Unassign Staff from Shifts
  Allows removing staff assignments from shifts.
  Use when schedules change or staff can't work assigned shifts.
  """
  UNASSIGN_USER_FROM_SHIFT

  """
  Unassign Staff from Tables
  Allows removing staff assignments from tables.
  Useful when ending shifts or reassigning table sections.
  """
  UNASSIGN_USER_FROM_TABLE

  """
  Undo Table Transfers
  Allows reversing table transfers and returning them to original server.
  Useful for correcting mistakes or handling disputes.
  """
  UNDO_TRANSFER

  """
  Update Location Groups
  Allows modifying existing location groups, including their name and settings.
  This helps maintain accurate organization of your restaurant locations.
  """
  UPDATE_COLLECTION

  """
  Update Customers
  Allows updating customer information such as contact details and addresses.
  Important for maintaining accurate customer records.
  """
  UPDATE_CUSTOMERS

  """
  Update Custom Roles
  Allows modifying existing custom roles, including changing their permissions.
  This lets you adjust roles as your operational needs evolve.
  """
  UPDATE_CUSTOM_ROLE

  """
  Update Images
  Allows replacing or modifying existing images in the system.
  Use this to refresh menu photos or update visual content.
  """
  UPDATE_IMAGE

  """
  Update Item List Status
  Allows changing the preparation status of individual items within an order.
  Helps kitchen staff track which items are being prepared or are ready.
  """
  UPDATE_ITEM_LIST_STATUS

  """
  Update Layouts
  Allows modifying existing floor plan layouts.
  Use this to adjust table positions or update dining area configurations.
  """
  UPDATE_LAYOUT

  """
  Update Locations
  Allows modifying location details such as name, address, hours, and configuration.
  This keeps location information accurate and up-to-date.
  """
  UPDATE_LOCATION

  """
  Update Location Taxes
  Allows modifying tax settings for specific locations.
  Use this to adjust local tax rates or tax rules.
  """
  UPDATE_LOCATION_TAX

  """
  Update Team Members
  Allows modifying team member information, roles, and assignments.
  Essential for managing staff details and access levels.
  """
  UPDATE_MEMBER

  """
  Update Team Member Status
  Allows changing a team member's account status (active, inactive, suspended).
  This controls whether a team member can access the system.
  """
  UPDATE_MEMBER_STATUS

  """
  Update Menus
  Allows modifying existing menus, including their name, availability, and settings.
  Use this to adjust menu offerings based on season or time of day.
  """
  UPDATE_MENU

  """
  Update Menu Categories
  Allows modifying existing menu categories including name and display order.
  Use this to refine menu organization and presentation.
  """
  UPDATE_MENU_CATEGORY

  """
  Update Menu Items
  Allows modifying existing menu items including name, price, description, and availability.
  Use this to keep menu information accurate and current.
  """
  UPDATE_MENU_ITEM

  """
  Update Orders
  Allows modifying order details, notes, and basic order information.
  Use this for staff who need to edit orders without full management capabilities.
  """
  UPDATE_ORDERS

  """
  Update Order Details
  Allows modifying order information such as customer notes or special requests.
  This helps ensure orders are prepared correctly.
  """
  UPDATE_ORDER_DETAILS

  """
  Update Order Item Quantity
  Allows changing the quantity of items in an order.
  Helpful for adjusting orders to match customer requests.
  """
  UPDATE_ORDER_ITEM_QUANTITY

  """
  Update Order Remaining Amount
  Allows updating the remaining balance on an order after partial payment.
  Useful for tracking split payments or deposits.
  """
  UPDATE_ORDER_REMAINING_AMOUNT

  """
  Update Order Selected Items
  Allows selecting specific items within an order for partial operations.
  Used when applying discounts or processing partial payments.
  """
  UPDATE_ORDER_SELECTED_ITEMS

  """
  Update Order Status
  Allows changing the status of orders (e.g., pending, preparing, ready, completed).
  Essential for tracking order progress through the kitchen and delivery.
  """
  UPDATE_ORDER_STATUS

  """
  Update PIN Code
  Allows changing your existing PIN code.
  Important for maintaining PIN security.
  """
  UPDATE_PIN_CODE

  """
  Update Printers
  Allows modifying printer settings and configurations.
  Use this to adjust printer behavior and assignments.
  """
  UPDATE_PRINTER

  """
  Update Printer Jobs
  Allows modifying existing print jobs or their status.
  Useful for managing print queue and priorities.
  """
  UPDATE_PRINTER_JOB

  """
  Update Shifts
  Allows modifying existing shift times, assignments, or details.
  Use this to adjust schedules as needs change.
  """
  UPDATE_SHIFT

  """
  Update Tax Rules
  Allows modifying existing tax rules and their rates.
  Use this when tax rates change or rules need adjustment.
  """
  UPDATE_TAX_RULE

  """
  Update Timeclock Settings
  Allows modifying time tracking rules and configuration.
  Important for setting overtime rules, rounding, and policies.
  """
  UPDATE_TIMECLOCK_SETTINGS

  """
  Update User Profile
  Allows modifying your basic profile information like name and preferences.
  Essential for maintaining accurate personal information.
  """
  UPDATE_USER_PROFILE

  """
  Update User Profile Extended
  Allows modifying extended profile fields and detailed information.
  Use for updating additional personal or professional details.
  """
  UPDATE_USER_PROFILE_EXT

  """
  Update User Settings
  Allows modifying your account settings and preferences.
  Useful for customizing your experience with the system.
  """
  UPDATE_USER_SETTINGS

  """
  Upgrade Plan
  Allows upgrading to a higher-tier subscription plan.
  Essential for accessing additional features and capacity.
  """
  UPGRADE_PLAN

  """
  Upload Images
  Allows uploading images for menu items, locations, or other content.
  Essential for adding visual content to enhance menus and marketing.
  """
  UPLOAD_IMAGE

  """
  Update Check/Invoice Design
  Allows modifying the design, layout, and branding of receipts and invoices.
  Essential for customizing customer-facing documents with your branding.
  """
  UPSERT_CHECK_INVOICE_DESIGN

  """
  Update Location Configuration
  Allows modifying location settings and operational parameters.
  Essential for configuring location-specific behavior and features.
  """
  UPSERT_LOCATION_CONFIGURATION

  """
  Verify Two-Factor Authentication
  Allows completing 2FA verification during login.
  Required when 2FA is enabled on your account.
  """
  VERIFY_2FA

  """
  Verify PIN Code
  Allows validating PIN codes for authentication or authorization.
  Used during login or sensitive operations requiring verification.
  """
  VERIFY_PIN_CODE

  """
  View Active Clock Entries
  Allows viewing currently active (clocked-in) staff members.
  Useful for seeing who is currently working.
  """
  VIEW_ACTIVE_CLOCK_ENTRIES

  """
  View All Taxes
  Allows viewing all tax rules and configurations across the organization.
  Helpful for tax management and compliance oversight.
  """
  VIEW_ALL_TAXES

  """
  View Analytics
  Allows viewing personal performance analytics and statistics.
  Includes team comparisons, revenue per hour, and detailed metrics.
  """
  VIEW_ANALYTICS

  """
  View Billing
  Allows viewing current subscription plan, invoices, and payment history.
  Helpful for tracking subscription costs and payment records.
  """
  VIEW_BILLING

  """
  View Cash Drawers
  Allows viewing all open cash drawers at a location.
  Used by managers to see who has open drawers.
  """
  VIEW_CASH_DRAWERS

  """
  View Cash Drawer History
  Allows viewing historical cash drawer records.
  Used for auditing and reconciliation.
  """
  VIEW_CASH_DRAWER_HISTORY

  """
  View Cash Drawer Summary
  Allows viewing cash drawer summary for EOD reconciliation.
  Shows totals and variances across all drawers for a day.
  """
  VIEW_CASH_DRAWER_SUMMARY

  """
  View Check Design
  Allows viewing the design and layout of receipts and invoices.
  Helpful for previewing how customer receipts will appear.
  """
  VIEW_CHECK_DESIGN

  """
  View Clock Logs
  Allows viewing historical time clock records.
  Helpful for reviewing work history and attendance.
  """
  VIEW_CLOCK_LOGS

  """
  View Clover Status
  Allows viewing the connection status and health of Clover payment integration.
  Helpful for monitoring payment gateway availability and merchant configuration.
  """
  VIEW_CLOVER_STATUS

  """
  View Location Groups
  Allows viewing the list of location groups and their associated locations.
  This helps understand how your restaurants are organized.
  """
  VIEW_COLLECTION

  """
  View Current Open Entry
  Allows viewing your own active clock-in session.
  Helps staff verify they're currently clocked in.
  """
  VIEW_CURRENT_OPEN_ENTRY

  """
  View Customers
  Allows viewing customer records and their order history.
  Essential for managing customer relationships and support.
  """
  VIEW_CUSTOMERS

  """
  View Custom Roles
  Allows viewing the list of custom roles and their associated permissions.
  This helps understand what custom roles exist in your organization.
  """
  VIEW_CUSTOM_ROLES

  """
  View End of Day Report
  Allows viewing daily sales summaries and closing reports.
  Critical for daily reconciliation and financial tracking.
  """
  VIEW_END_OF_DAY_REPORT

  """
  View End of Shift Report
  Allows viewing individual employee shift closeout reports.
  Used for server accountability, tip tracking, and cash drawer reconciliation.
  """
  VIEW_END_OF_SHIFT_REPORT

  """
  View Feature Discovery Status
  Allows viewing the feature discovery status including new features and release notes.
  Essential for users to see what's new in the application.
  """
  VIEW_FEATURE_DISCOVERY

  """
  View Flagged Clock Entries
  Allows viewing time entries that need manager review or approval.
  Important for handling unusual clock situations like missed clock-outs.
  """
  VIEW_FLAGGED_CLOCK_ENTRIES

  """
  View Invitations
  Allows viewing the list of pending and completed invitations.
  Helpful for tracking onboarding progress.
  """
  VIEW_INVITATIONS

  """
  View Item Sales Report
  Allows viewing sales reports showing which menu items are selling.
  Essential for understanding menu performance and popular items.
  """
  VIEW_ITEM_SALES_REPORT

  """
  View Kitchen Analytics
  Allows viewing historical kitchen load snapshots and analytics.
  Used by managers to analyze kitchen performance trends.
  """
  VIEW_KITCHEN_ANALYTICS

  """
  View Locations
  Allows viewing the list of restaurant locations and their details.
  This is essential for navigating and managing your restaurants.
  """
  VIEW_LOCATION

  """
  View Location Layout
  Allows viewing a specific floor plan layout for a location.
  Essential for understanding current table arrangements.
  """
  VIEW_LOCATION_LAYOUT

  """
  View Location Layouts
  Allows viewing all available floor plan layouts for a location.
  Helps browse different dining area configurations.
  """
  VIEW_LOCATION_LAYOUTS

  """
  View Location Settings
  Allows viewing location configuration and operational settings.
  Important for understanding location-specific behavior.
  """
  VIEW_LOCATION_SETTINGS

  """
  View Location Staff
  Allows viewing the list of staff members assigned to locations.
  Essential for understanding staffing at each restaurant.
  """
  VIEW_LOCATION_STAFF

  """
  View Location Taxes
  Allows viewing tax configurations for specific locations.
  Essential for understanding how taxes are calculated at each location.
  """
  VIEW_LOCATION_TAXES

  """
  View Team Member Capabilities
  Allows viewing what roles, locations, and permissions other team members have.
  Useful for understanding team structure and access levels.
  """
  VIEW_MEMBER_CAPABILITIES

  """
  View Menus
  Allows viewing the list of menus and their basic information.
  Essential for browsing available menus across your locations.
  """
  VIEW_MENUS

  """
  View Menu Categories
  Allows viewing the list of menu categories and their contents.
  Essential for navigating menu structure.
  """
  VIEW_MENU_CATEGORIES

  """
  View Menu Items
  Allows viewing the complete catalog of menu items and their details.
  Essential for browsing and selecting items for orders.
  """
  VIEW_MENU_ITEMS

  """
  View NFC Tags
  Allows viewing NFC tag information and scan history.
  Useful for monitoring NFC tag usage and troubleshooting.
  """
  VIEW_NFC_TAGS

  """
  View Onboarding Status
  Allows viewing onboarding progress and completion status.
  Helpful for tracking new staff member setup.
  """
  VIEW_ONBOARDING_STATUS

  """
  View Orders
  Allows viewing the list of orders and their current status.
  Essential for monitoring order flow and restaurant operations.
  """
  VIEW_ORDERS

  """
  View Order Details
  Allows viewing complete order information including items, pricing, and history.
  Important for order fulfillment and customer service.
  """
  VIEW_ORDER_DETAILS

  """
  View Paginated Menus
  Allows viewing menus in paginated format for better performance with large catalogs.
  Technical permission for efficient menu browsing.
  """
  VIEW_PAGINATED_MENUS

  """
  View Paginated Menu Categories
  Allows viewing menu categories in paginated format for better performance.
  Technical permission for efficient category browsing.
  """
  VIEW_PAGINATED_MENU_CATEGORIES

  """
  View Paginated Menu Items
  Allows viewing menu items in paginated format for better performance.
  Technical permission for efficient browsing of large catalogs.
  """
  VIEW_PAGINATED_MENU_ITEMS

  """
  View Payment Gateway Configuration
  Allows viewing payment gateway settings and integration details.
  Important for understanding payment processing setup.
  """
  VIEW_PAYMENT_GATEWAY_CONFIG

  """
  View Payment Provider Status
  Allows viewing unified payment provider status showing all configured providers.
  Helpful for understanding which payment options are available at each location.
  """
  VIEW_PAYMENT_PROVIDER_STATUS

  """
  View Printer Jobs
  Allows viewing the list of print jobs and their status.
  Helpful for monitoring print queue and troubleshooting.
  """
  VIEW_PRINTER_JOBS

  """
  View Release Notes
  Allows viewing release notes and update information.
  Helpful for users to stay informed about system updates.
  """
  VIEW_RELEASE_NOTES

  """
  View Sales Aggregates
  Allows viewing summarized sales data and analytics.
  Useful for business intelligence and trend analysis.
  """
  VIEW_SALES_AGGREGATES

  """
  View Section Assignments
  Allows viewing staff section assignments and coverage.
  Important for managing floor sections and staff scheduling.
  """
  VIEW_SECTION_ASSIGNMENTS

  """
  View Shift Details
  Allows viewing information about a specific shift.
  Helpful for understanding shift requirements and assignments.
  """
  VIEW_SHIFT

  """
  View Shifts
  Allows viewing the complete shift schedule.
  Essential for understanding staffing and coverage.
  """
  VIEW_SHIFTS

  """
  View Shift Assignments
  Allows viewing which staff members are assigned to which shifts.
  Important for understanding staffing coverage.
  """
  VIEW_SHIFT_ASSIGNMENTS

  """
  View Shift Summary
  Allows viewing personal shift performance summaries.
  Shows orders served, sales, tips, and hours for current or past shifts.
  """
  VIEW_SHIFT_SUMMARY

  """
  View Stripe Status
  Allows viewing the connection status and health of Stripe payment integration.
  Helpful for monitoring payment gateway availability.
  """
  VIEW_STRIPE_STATUS

  """
  View Tables
  Allows viewing the floor plan and list of tables in the restaurant.
  Essential for understanding seating capacity and table availability.
  """
  VIEW_TABLES

  """
  View Table Assignments
  Allows viewing which staff members are assigned to which tables.
  Helpful for understanding current table coverage and staff responsibilities.
  """
  VIEW_TABLE_ASSIGNMENTS

  """
  View Tax Diagnostics
  Allows viewing detailed tax calculation breakdowns and debugging information.
  Helpful for troubleshooting tax calculation issues.
  """
  VIEW_TAX_DIAGNOSTICS

  """
  View Tax Rules
  Allows viewing tax calculation rules and their details.
  Essential for understanding how taxes are calculated for orders.
  """
  VIEW_TAX_RULES

  """
  View Timeclock Settings
  Allows viewing time tracking configuration and rules.
  Helpful for understanding how time tracking works.
  """
  VIEW_TIMECLOCK_SETTINGS

  """
  View Timesheet Summaries
  Allows viewing summarized time and attendance reports.
  Essential for payroll processing and labor cost tracking.
  """
  VIEW_TIMESHEET_SUMMARIES

  """
  View Transaction Logs
  Allows viewing detailed logs of financial transactions.
  Important for auditing, troubleshooting, and compliance.
  """
  VIEW_TRANSACTION_LOGS

  """
  View Table Transfers
  Allows viewing the history of table transfers and their status.
  Helpful for tracking table ownership changes.
  """
  VIEW_TRANSFER

  """
  View Uber Eats Account
  Allows viewing your Uber Eats integration status and settings.
  Helpful for monitoring delivery platform connection.
  """
  VIEW_UBEREATS_ACCOUNT

  """
  View Users
  Allows viewing user information and details.
  Used for accessing staff member profiles and information.
  """
  VIEW_USERS

  """
  View Users by Location
  Allows viewing the list of staff members assigned to specific locations.
  Essential for understanding who works at each restaurant.
  """
  VIEW_USERS_BY_LOCATION

  """
  View User Permissions Matrix
  Allows viewing the complete permission grid showing who has what access.
  Helpful for auditing and understanding access control.
  """
  VIEW_USER_PERMISSIONS_MATRIX

  """
  View User Profile Extended
  Allows viewing detailed user profile information beyond basic details.
  Useful for accessing complete staff member information.
  """
  VIEW_USER_PROFILE_EXT

  """
  View User Settings
  Allows viewing user preferences and configuration settings.
  Helpful for understanding how users have configured their experience.
  """
  VIEW_USER_SETTINGS

  """
  View User Shift Assignments
  Allows viewing shifts assigned to specific team members.
  Helpful for checking individual schedules.
  """
  VIEW_USER_SHIFT_ASSIGNMENTS

  """
  Void Orders
  Allows voiding completed orders for corrections or errors.
  Typically requires manager approval and affects financial reporting.
  """
  VOID_ORDERS
}

"Category of a feature for organization and filtering."
enum FeatureCategory {
  "Onboarding step or setup task."
  ONBOARDING

  "Brand new feature added to the system."
  NEW_FEATURE

  "Enhancement or improvement to existing functionality."
  IMPROVEMENT

  "Beta feature available for early access."
  BETA
}

"Type of interaction a user can have with a feature."
enum FeatureInteractionType {
  "User has viewed/seen the feature announcement."
  SEEN

  "User dismissed the feature (won't show again)."
  DISMISSED

  "User completed the feature (e.g., finished onboarding task)."
  COMPLETED

  "User skipped the feature (may show again later)."
  SKIPPED
}

"Type of release for categorizing release notes."
enum ReleaseType {
  "Major release with significant new features or breaking changes."
  MAJOR

  "Minor release with new features and improvements."
  MINOR

  "Patch release with bug fixes."
  PATCH

  "Hotfix for critical issues."
  HOTFIX
}

"SSP Ecosystem product identifier."
enum SSPProduct {
  "SSP Manager (Back Office) web application."
  MANAGER

  "Waiter Web - browser-based POS for waitstaff."
  WAITER_WEB

  "Waiter Mobile - React Native mobile app for waitstaff."
  WAITER_MOBILE

  "Kitchen Display System."
  KITCHEN

  "Guest App (SPLT.ca) - customer-facing ordering."
  GUEST

  "Applies to all SSP products."
  ALL
}

"Placement of tour popover relative to the target element."
enum TourPlacement {
  "Above the element."
  TOP

  "Below the element."
  BOTTOM

  "To the left of the element."
  LEFT

  "To the right of the element."
  RIGHT

  "Auto-detect best placement."
  AUTO
}

"Kitchen load level indicating current busyness"
enum KitchenLoadLevel {
  "Low load - kitchen running smoothly"
  LOW

  "Medium load - kitchen getting busy"
  MEDIUM

  "High load - kitchen very busy"
  HIGH

  "Critical load - kitchen at maximum capacity"
  CRITICAL
}

"Type of legal document."
enum LegalDocumentType {
  "Privacy and security policy."
  PRIVACY_POLICY

  "Terms of service / conditions of use."
  TERMS_OF_SERVICE

  "Acceptable use policy."
  ACCEPTABLE_USE_POLICY

  "Cookie policy."
  COOKIE_POLICY

  "End User License Agreement."
  EULA
}

enum ReportType {
  "End of day report."
  EOD

  "Tax summary report."
  TAX_SUMMARY

  "Sales report."
  SALES

  "Transaction detail report - line-by-line breakdown of all orders."
  TRANSACTION_DETAIL

  "Gratuity and service charge report."
  GRATUITY

  "Staff performance report - individual server metrics."
  STAFF_PERFORMANCE

  "End of shift report - individual employee shift closeout."
  END_OF_SHIFT
}

enum ExportFormat {
  "Export as PDF."
  PDF

  "Export as CSV."
  CSV
}

enum TemplateTypeInput {
  "Template for table order checks (dining in)."
  CHECK

  "Template for invoices (e.g., catering, tax purposes)."
  INVOICE
}

enum TimeFormat {
  "12-hour time format (e.g., 1:30 PM)."
  TWELVE_HOUR

  "24-hour time format (e.g., 13:30)."
  TWENTY_FOUR_HOUR
}

enum DateFormat {
  "Year-month-day format (e.g., 2023-12-31)."
  YYYY_MM_DD

  "Month-day-year format (e.g., 12/31/2023)."
  MM_DD_YYYY

  "Day-month-year format (e.g., 31/12/2023)."
  DD_MM_YYYY
}

enum TableOrderType {
  "Order for dining in at the restaurant."
  DINE_IN

  "Order for takeout (alias: TAKEAWAY)."
  TAKE_OUT

  "Order for takeout (alias for TAKE_OUT, used in database)."
  TAKEAWAY

  "Order for delivery."
  DELIVERY

  "Order for pickup (maps to TAKEAWAY internally)."
  PICKUP
}

enum TableOrderPriority {
  "Normal priority order."
  NORMAL

  "Rush priority order."
  RUSH
}

enum ClockSource {
  "Clock-in via QR code."
  QR_CODE

  "Clock-in via mobile device."
  MOBILE

  "Clock-in overridden by admin."
  ADMIN_OVERRIDE
}

enum ClockFlagReason {
  "Clock entry outside geofence."
  OUT_OF_GEOFENCE

  "Clock entry outside allowed time window."
  OUT_OF_WINDOW

  "Clock entry for unscheduled shift."
  UNSCHEDULED

  "Clock entry device mismatch."
  DEVICE_MISMATCH

  "Clock entry manually edited."
  MANUAL_EDIT
}

enum SalesAggregateGroupBy {
  "Aggregate sales by hour."
  HOUR

  "Aggregate sales by day."
  DAY

  "Aggregate sales by week."
  WEEK

  "Aggregate sales by month."
  MONTH

  "Aggregate sales by year."
  YEAR
}

enum CompositionBehavior {
  "Taxes can stack with others."
  STACKABLE

  "Taxes are mutually exclusive."
  EXCLUSIVE

  "Taxes compound with others."
  COMPOUND
}

enum SSPTaxApplicableTo {
  "Tax applies globally."
  GLOBAL

  "Tax applies to a specific location."
  LOCATION

  "Tax applies to a specific item."
  ITEM

  "Tax applies to a category."
  CATEGORY
}

enum SocialProvider {
  "Google OAuth provider."
  GOOGLE

  "Facebook OAuth provider."
  FACEBOOK

  "Apple OAuth provider."
  APPLE

  "Twitter OAuth provider."
  TWITTER
}

"Categories of images used in the SSP ecosystem."
enum ImageCategory {
  "Restaurant or company branding logo."
  LOGO

  "Scanned or photographed physical menu."
  MENU_SCAN

  "Dish or drink photo shown to guests."
  MENU_ITEM
}

enum PaymentMethod {
  "Cash payment."
  CASH

  "Credit/debit card payment."
  CARD

  "Check payment."
  CHECK

  "Gift card payment."
  GIFT_CARD

  "Other payment method."
  OTHER
}

enum DiscountType {
  "Percentage discount (e.g., 10% off)."
  PERCENTAGE

  "Fixed amount discount (e.g., $5 off)."
  AMOUNT
}

"""
All restaurant roles including internal SSP roles.
Used for internal operations and support admin features.
"""
enum RestaurantRoles {
  "SSP Systems internal support team role (not assignable by customers)."
  SUPPORT_ADMIN

  "Administrator for the entire organization."
  ORGANIZATION_ADMIN

  "Manager for a chain of locations."
  CHAIN_MANAGER

  "Manager for a specific location."
  LOCATION_MANAGER

  "Floor manager for dining area supervision."
  FLOOR_MANAGER

  "Wait staff for serving customers."
  WAIT_STAFF

  "Kitchen staff for food preparation."
  KITCHEN_STAFF

  "Cashier for handling payments."
  CASHIER

  "Accounting staff for financial management."
  ACCOUNTING
}

"""
Customer-assignable roles. Excludes SUPPORT_ADMIN which is an internal SSP role.
Use this enum for customer-facing mutations like createInvitation and updateMember.
"""
enum AssignableRoles {
  "Administrator for the entire organization."
  ORGANIZATION_ADMIN

  "Manager for a chain of locations."
  CHAIN_MANAGER

  "Manager for a specific location."
  LOCATION_MANAGER

  "Floor manager for dining area supervision."
  FLOOR_MANAGER

  "Wait staff for serving customers."
  WAIT_STAFF

  "Kitchen staff for food preparation."
  KITCHEN_STAFF

  "Cashier for handling payments."
  CASHIER

  "Accounting staff for financial management."
  ACCOUNTING
}

enum EmployeeContext {
  "Employee is associated with a specific location."
  LOCATION

  "Employee is associated with a collection of locations."
  COLLECTION

  "Employee is associated with both location and collection."
  MIXED

  "Employee has no specific location or collection context."
  NONE
}

enum ShiftStatus {
  "Shift has been completed successfully."
  COMPLETED

  "Shift was canceled before completion."
  CANCELED

  "Shift was interrupted and not completed."
  INTERRUPTED
}

enum ClockEntryStatus {
  "Clock entry is open (user has not clocked out)."
  OPEN

  "Clock entry is closed (user has clocked out)."
  CLOSED

  "Clock entry is flagged for review (e.g., due to geofence issues)."
  FLAGGED
}

enum SSPLocationStatus {
  "Location is active and operational."
  ACTIVE

  "Location is closed permanently or temporarily."
  CLOSED

  "Location is pending setup or approval."
  PENDING

  "Location is under renovation and not operational."
  UNDER_RENOVATION
}

enum SSPLocCollectionStatus {
  "Location collection is active."
  ACTIVE

  "Location collection is closed."
  CLOSED

  "Location collection is pending setup."
  PENDING

  "Location collection has been merged with another."
  MERGED
}

enum SSPOrderStatus {
  "Order has been created but not yet processed."
  CREATED

  "Order is editable by staff or customer."
  EDITABLE

  "Order is being prepared in the kitchen."
  COOKING

  "Order has been served to the customer."
  SERVED

  "Order has been paid for."
  PAID

  "Order was canceled."
  CANCELLED

  "Order is pending processing."
  PENDING

  "Order is being processed."
  PROCESSING

  "Order has been fully completed."
  COMPLETED

  "Order processing failed."
  FAILED

  "Order was voided."
  VOIDED

  "Order payment was refunded."
  REFUNDED

  "Order was abandoned by the customer."
  ABANDONED

  "Order is partially paid."
  PARTIALLY_PAID
}

enum SSPTableStatus {
  "Table is available for seating."
  AVAILABLE

  "Table is currently occupied."
  OCCUPIED

  "Table is reserved for a future booking."
  RESERVED

  "Table is being cleaned."
  CLEANING

  "Table is under maintenance."
  MAINTENANCE

  "Table is out of service."
  OUT_OF_SERVICE
}

enum EmployeeStatus {
  "Employee is actively working."
  ACTIVE

  "Employee is inactive but still employed."
  INACTIVE

  "Employee has been terminated."
  TERMINATED

  "Employee is on leave."
  ON_LEAVE

  "Employee is suspended."
  SUSPENDED

  "Employee has retired."
  RETIRED

  "Employee is on probation."
  PROBATION
}

enum TableOrderItemStatus {
  "The item has been ordered but not yet processed."
  ORDERED

  "The item has been created in the system but not yet started in the kitchen."
  CREATED

  "The item is still editable and can be modified by the user or staff."
  EDITABLE

  "The item is being actively prepared in the kitchen."
  COOKING

  "The item is fully prepared and ready to be served."
  PREPARED

  "The item has been served to the customer."
  SERVED

  "The item has been paid for by the customer."
  PAID

  "The item was ordered but has since been cancelled."
  CANCELLED

  "The item order is pending and has not yet been processed or started."
  PENDING

  "The item is currently being processed in the system."
  PROCESSING

  "The item has been fully completed, including preparation and serving."
  COMPLETED

  "The item payment or processing has failed."
  FAILED

  "The payment for the item was declined."
  DECLINED

  "The payment for the item has been refunded."
  REFUNDED

  "The payment for the item was reversed."
  REVERSED

  "The item has been voided and will not be processed further."
  VOIDED

  "The item order was abandoned and not completed."
  ABANDONED

  "The status of the item is currently unknown."
  UNKNOWN

  "The item has been picked up by the customer for takeaway."
  PICKED_UP

  "The item has been delivered to the customer."
  DELIVERED

  "The item is on hold and temporarily paused from processing."
  ON_HOLD

  "The item has been confirmed by the customer or staff before processing."
  CONFIRMED

  "The item is out of stock and cannot be processed."
  OUT_OF_STOCK
}

"Steps in the onboarding process for a restaurant."
enum OnboardingStep {
  "User has registered but not yet completed setup."
  REGISTERED

  "User has completed profile setup."
  PROFILE_SETUP

  "Restaurant entity has been created."
  RESTAURANT_SETUP

  "Restaurant address has been configured."
  ADDRESS_SETUP

  "Restaurant tax setup has been completed."
  TAX_SETUP

  "Restaurant tables have been configured."
  TABLE_SETUP

  "Onboarding fully completed."
  COMPLETED
}

"Current status of a user account in the system."
enum UserStatus {
  "User is actively employed."
  ACTIVE

  "User is temporarily on leave."
  ON_LEAVE

  "User is no longer employed."
  TERMINATED
}

"Different subscription plans for restaurants using SSP."
enum SubscriptionPlan {
  "Free tier with limited features."
  PLAN_FREE

  "Business tier with full feature set."
  PLAN_BUSINESS

  "Enterprise tier with advanced features and support."
  PLAN_ENTERPRISE
}

enum CategoryTypes {
  "Category is predefined by the system."
  PREDEFINED

  "Category is user-defined."
  USER_DEFINED
}

enum TaxType {
  "Tax is predefined by the system."
  PREDEFINED

  "Tax is custom-defined by the user."
  CUSTOM
}

enum TableType {
  "Square-shaped table."
  SQUARE

  "Circular table."
  CIRCLE

  "Oval-shaped table."
  OVAL

  "Rectangular table."
  RECTANGLE

  "Standard table type."
  REGULAR

  "Bar seating."
  BAR

  "Booth seating."
  BOOTH

  "Outdoor seating."
  OUTDOOR

  "VIP table."
  VIP

  "Family-sized table."
  FAMILY

  "Communal table for group seating."
  COMMUNAL

  "Counter seating."
  COUNTER

  "Private room table."
  PRIVATE_ROOM

  "High-top table."
  HIGH_TOP

  "Low-top table."
  LOW_TOP

  "Table by the window."
  WINDOW_SIDE

  "Balcony table."
  BALCONY

  "Lounge seating."
  LOUNGE

  "Patio seating."
  PATIO

  "Service table."
  SERVICE

  "Cabana seating."
  CABANA

  "Foldable table."
  FOLDABLE

  "Standing table."
  STANDING

  "Tasting table."
  TASTING

  "Chef's table for special dining."
  CHEFS_TABLE
}

"Input for sending a print request to a CloudPRNT printer."
input CloudPrintPayloadInput {
  "Type of content being sent (pdf, png, raw)."
  type: String!

  "Base64 encoded content to print."
  content: String!

  "Job type classification (RECEIPT, KITCHEN, CHIT, BAR, LABEL)."
  jobType: String

  "Priority level (-1=low, 0=normal, 1=high, 2=urgent)."
  priority: Int
}

"Input for updating a CloudPRNT printer configuration."
input UpdateCloudPrinterInput {
  "User-friendly alias for the printer."
  alias: String

  "Job types this printer should handle."
  jobTypes: [String!]

  "Paper width in pixels."
  paperWidth: Int

  "Printer DPI resolution."
  dpi: Int
}

"Input types for customer data management"
input CreateCustomerInput {
  "Full name of the customer (required if first_name/last_name not provided)."
  name: String

  "First name of the customer."
  first_name: String

  "Last name of the customer."
  last_name: String

  "Email address of the customer."
  email: String

  "Phone number of the customer."
  phone: String

  "Delivery street address."
  delivery_address: String

  "Delivery city."
  delivery_city: String

  "Delivery state/province."
  delivery_state: String

  "Delivery postal/ZIP code."
  delivery_postal_code: String

  "Delivery country (defaults to 'US')."
  delivery_country: String

  "External customer ID from third-party platform."
  external_id: String

  "Source platform: ubereats, doordash, grubhub, ssppos, etc."
  external_source: String

  "Internal notes about the customer."
  notes: String

  "Flexible metadata field for custom data (JSON)."
  metadata: JSON
}

input UpdateCustomerInput {
  "Customer ID to update (required)."
  id: ID!

  "Full name of the customer."
  name: String

  "First name of the customer."
  first_name: String

  "Last name of the customer."
  last_name: String

  "Email address of the customer."
  email: String

  "Phone number of the customer."
  phone: String

  "Delivery street address."
  delivery_address: String

  "Delivery city."
  delivery_city: String

  "Delivery state/province."
  delivery_state: String

  "Delivery postal/ZIP code."
  delivery_postal_code: String

  "Delivery country."
  delivery_country: String

  "Internal notes about the customer."
  notes: String

  "Flexible metadata field for custom data (JSON)."
  metadata: JSON
}

input CustomerFilterInput {
  "Filter by customer name (partial match)."
  name: String

  "Filter by email (exact match)."
  email: String

  "Filter by phone (partial match)."
  phone: String

  "Filter by external source."
  external_source: String

  "Filter by external ID."
  external_id: String

  "Filter by repeat customer status."
  is_repeat_customer: Boolean
}

"Input for creating a new customization template."
input CreateCustomizationTemplateInput {
  "Name of the customization (required)."
  name: String!

  "Default price adjustment for this customization."
  price: Float = 0

  "Description of the customization."
  description: String

  "Type of customization."
  type: CustomizationTemplateType = addon

  "Whether this template is active."
  is_active: Boolean = true

  "Location ID (if location-specific). Either location_id or location_coll_id must be provided."
  location_id: Int

  "Location collection ID (if chain-wide). Either location_id or location_coll_id must be provided."
  location_coll_id: Int
}

"Input for updating an existing customization template."
input UpdateCustomizationTemplateInput {
  "Name of the customization."
  name: String

  "Default price adjustment for this customization."
  price: Float

  "Description of the customization."
  description: String

  "Type of customization."
  type: CustomizationTemplateType

  "Whether this template is active."
  is_active: Boolean
}

"Input for attaching a customization template to a menu item."
input AttachCustomizationTemplateInput {
  "ID of the menu item to attach the template to (required)."
  menu_item_id: ID!

  "ID of the customization template to attach (required)."
  customization_template_id: ID!

  "Override price for this specific menu item (null = use default template price)."
  price_override: Float

  "Whether this customization is pre-selected by default."
  is_default: Boolean = false

  "Sort order for displaying customizations."
  sort_order: Int = 0
}

"Input for detaching a customization template from a menu item."
input DetachCustomizationTemplateInput {
  "ID of the menu item to detach the template from (required)."
  menu_item_id: ID!

  "ID of the customization template to detach (required)."
  customization_template_id: ID!
}

"Input for bulk attaching a customization template to multiple menu items."
input BulkAttachCustomizationTemplateInput {
  "ID of the customization template to attach (required)."
  customization_template_id: ID!

  "List of menu item IDs to attach the template to."
  menu_item_ids: [ID!]

  "Category ID - attach template to all items in this category."
  category_id: ID

  "Menu ID - attach template to all items in this menu."
  menu_id: ID

  "Override price for all attached items (null = use default template price)."
  price_override: Float

  "Whether this customization is pre-selected by default."
  is_default: Boolean = false

  "Sort order for displaying customizations."
  sort_order: Int = 0
}

"Input for bulk detaching a customization template from multiple menu items."
input BulkDetachCustomizationTemplateInput {
  "ID of the customization template to detach (required)."
  customization_template_id: ID!

  "List of menu item IDs to detach the template from."
  menu_item_ids: [ID!]

  "Category ID - detach template from all items in this category."
  category_id: ID

  "Menu ID - detach template from all items in this menu."
  menu_id: ID
}

"Input for updating the pivot data of an existing menu item - customization template association."
input UpdateMenuItemCustomizationTemplateInput {
  "ID of the menu item (required)."
  menu_item_id: ID!

  "ID of the customization template (required)."
  customization_template_id: ID!

  "Override price for this specific menu item."
  price_override: Float

  "Whether this customization is pre-selected by default."
  is_default: Boolean

  "Sort order for displaying customizations."
  sort_order: Int
}

"Input for deleting a customization template with context awareness."
input DeleteCustomizationTemplateInput {
  "The ID of the template to delete (required)."
  id: ID!

  "The location context (if deleting from a location view)."
  location_id: ID

  "The collection context (if deleting from a collection view)."
  location_coll_id: ID
}

"Input for creating or updating a single restaurant location."
input SSPLocationInput {
  "Name of the location (required)."
  name: String!

  "Street address of the location."
  address: String

  "City where the location is situated."
  city: String

  "State or province of the location."
  state: String

  "Phone number for the location."
  phone_number: String

  "URL to the location or company logo image."
  logo_url: String

  "Postal or ZIP code."
  postal_code: String

  "Country code (ISO-3166)."
  country: String

  "Associated Location Collection ID (if part of a chain)."
  locCollID: Int

  "Current status of the location (e.g., ACTIVE, INACTIVE)."
  status: SSPLocationStatus

  """
  Behavior when NFC tag is scanned but no active order exists.
  Determines guest experience for self-seating vs full-service restaurants.
  """
  nfcNoOrderBehavior: NFCNoOrderBehavior

  """
  SDM File Read Key (Key 2) for NTAG 424 DNA tag verification.
  32-character hexadecimal string (e.g., 'DE43FCE728229976A8B7A87549D6DD25').
  All DNA tags for this location will use this key for signature verification.
  """
  nfcSdmKey: String

  """
  Whether this location accepts online orders (takeout, delivery).
  When true, customers can create orders via createDirectWebOrder mutation.
  """
  webOrderingEnabled: Boolean

  """
  Order types allowed for web ordering.
  Valid values: TAKEAWAY, DELIVERY.
  If empty, all non-DINE_IN types are allowed.
  """
  allowedWebOrderTypes: [TableOrderType!]
}

"Input for creating or updating a location collection (e.g., a restaurant chain)."
input SSPLocCollInput {
  "Name of the collection (required)."
  name: String!

  "Logo URL for the collection."
  logo: String

  "Brief description of the collection."
  description: String

  "Status of the collection (e.g., ACTIVE, INACTIVE)."
  status: SSPLocCollectionStatus
}

"Input for registering an organization with SSP."
input RegisterOrganizationInput {
  "Name of the organization (required)."
  name: String!

  "Subscription plan chosen for the organization (required)."
  plan: SubscriptionPlan!

  "Whether the organization is currently active."
  is_active: Boolean
}

"Input for describing the layout of a location (tables, floors, etc.)."
input LocationLayoutInput {
  "Serialized JSON or schema definition of the floor layout (required)."
  floorLayout: String!

  "Number of floors in the location (required)."
  numberOfFloors: Int!

  "List of table layouts per floor (required)."
  tableLayouts: [TableLayoutInput!]!
}

"Input for configuring default location settings."
input UpsertConfigurationInput {
  "Unique identifier of the location (required)."
  locationId: ID!

  "Currency code (e.g., USD, CAD) (required)."
  currency: String!

  "Timezone identifier (e.g., America/Toronto) (required)."
  timezone: String!

  "Default percentage service charge applied."
  defaultServiceCharge: Float

  "Minimum party size required for service charge to apply."
  serviceChargeMinPartySize: Int

  "Description shown for the service charge."
  serviceChargeDescription: String

  "Whether the location uses a reservation system."
  reservationSystem: Boolean

  "Whether tax is included in listed prices."
  taxIncluded: Boolean

  "Default tip percentage."
  defaultTip: Float

  "Whether tips are calculated after tax is applied."
  calculateTipAfterTax: Boolean

  "First suggested tip percentage."
  tipTier1: Float

  "Second suggested tip percentage."
  tipTier2: Float

  "Third suggested tip percentage."
  tipTier3: Float
}

"Generic input for defining a single location when onboarding."
input LocationInput {
  "Name of the location (required)."
  name: String!

  "Street address of the location."
  address: String

  "City where the location is situated."
  city: String

  "State or province of the location."
  state: String

  "Postal or ZIP code."
  postalCode: String

  "Country code (ISO-3166)."
  country: String

  "Phone number for the location."
  phoneNumber: String

  "URL to the location or company logo image."
  logoUrl: String

  "Status string (e.g., ACTIVE, INACTIVE)."
  status: String
}

"Generic input for defining a collection (chain or group of locations)."
input CollectionInput {
  "Name of the collection (required)."
  name: String!

  "Logo URL for the collection."
  logo: String

  "Brief description of the collection."
  description: String
}

"Input for onboarding a new organization with both a collection and a location."
input OnboardOrganizationInput {
  "Name of the organization (required)."
  orgName: String!

  "Chosen subscription plan (required)."
  subscriptionPlan: String!

  "Optional collection definition if this is a multi-location organization."
  collection: CollectionInput

  "Primary location information (required)."
  location: LocationInput!
}

"Input for creating a new menu item."
input CreateSSPMenuItemInput {
  "Name of the menu item (required)."
  name: String!

  "Detailed description of the item."
  description: String

  "URL or path to the items image."
  image: String

  "Base price of the item."
  price: Float

  "Whether the item is active in the system."
  is_active: Boolean

  "Whether the item is currently available for ordering."
  is_available: Boolean

  "Availability schedule (e.g., 'Lunch only')."
  availability: String

  "Preparation time in minutes."
  preparation_time: Int

  "Discount information (optional)."
  discounts: String

  "Allergen information (e.g., nuts, dairy)."
  allergens: String

  "Reward program information (optional)."
  rewards: String

  "Loyalty points required to redeem this item."
  loyalty_points: String

  "Loyalty points earned when purchasing this item."
  loyalty_points_earned: String

  "Customization options available for this item."
  customization_options: String

  "Other selectable options (serialized or structured data)."
  options: String

  "Available add-ons for the item."
  addons: String

  "Special instructions field for customers or staff."
  special_instructions: String

  "Whether the item is vegan-friendly."
  vegan: Boolean

  "Whether the item is vegetarian-friendly."
  vegetarian: Boolean

  "Whether the item is gluten-free."
  gluten_free: Boolean

  "Whether the item is certified halal."
  halal: Boolean

  "Whether the item is certified kosher."
  kosher: Boolean

  "Whether the item is organic."
  organic: Boolean

  "Whether the item is marked as spicy."
  spicy: Boolean

  "Whether the item is newly added to the menu."
  new: Boolean

  "Whether the item is popular among customers."
  popular: Boolean

  "Whether the item is recommended by the restaurant."
  recommended: Boolean

  "Ingredients list."
  ingredients: String

  "Tags or keywords for the item (comma-separated or serialized)."
  tags: String

  "Nutritional information."
  nutritional_information: String

  "Link to an item presentation or preparation video."
  video: String

  "Translations for multilingual support."
  translations: String

  "Modifier groups attached to this item."
  modifiers: String

  "SEO title for search optimization."
  seo_title: String

  "SEO description for search optimization."
  seo_description: String

  "Version number for tracking changes."
  version: Int

  "Location ID this item belongs to."
  location_id: Int

  "Location collection ID (if item belongs to a chain)."
  location_coll_id: Int

  "Associated menu IDs for this item."
  menu_ids: [Int]

  "Associated category IDs for this item."
  category_ids: [Int]
}

"Input for creating a new menu category."
input CreateSSPMenuCategoryInput {
  "Name of the category (required)."
  name: String!

  "Image representing the category."
  image: String

  "Category description."
  description: String

  "Whether the category is active."
  is_active: Boolean

  "Sorting order of the category."
  sort_order: Int

  "Category type (e.g., FOOD, BEVERAGE, DESSERT)."
  cat_type: CategoryTypes

  "Parent category ID for hierarchical menus."
  parent_id: Int

  "SEO title for search optimization."
  seo_title: String

  "SEO description for search optimization."
  seo_description: String

  "Translations for multilingual support."
  translations: String

  "Version number for tracking changes."
  version: Int

  "Location ID this category belongs to."
  location_id: Int

  "Location collection ID (if part of a chain)."
  location_coll_id: Int
}

"Input for creating a new menu."
input CreateSSPMenuInput {
  "Name of the menu (required)."
  name: String!

  "Description of the menu."
  description: String

  "Image representing the menu."
  image: String

  "Whether the menu is active."
  is_active: Boolean

  "Type of menu (e.g., STANDARD, SPECIAL, SEASONAL)."
  menu_type: String

  "Availability schedule for the menu (e.g., 'Dinner only')."
  availability: String

  "General price range of the menu (e.g., '$$')."
  price_range: String

  "Special offers associated with the menu."
  special_offers: String

  "Dietary options highlighted in the menu."
  dietary_options: String

  "Allergen information across the menu."
  allergen_information: String

  "Nutritional information for menu items."
  nutritional_information: String

  "SEO title for search optimization."
  seo_title: String

  "SEO description for search optimization."
  seo_description: String

  "Translations for multilingual support."
  translations: String

  "Version number for tracking changes."
  version: Int

  "Location ID this menu belongs to."
  location_id: Int

  "Location collection ID (if part of a chain)."
  location_coll_id: Int

  "Type of schedule activation for this menu."
  schedule_type: MenuScheduleType

  "Start date for date-range scheduling (YYYY-MM-DD)."
  start_date: Date

  "End date for date-range scheduling (YYYY-MM-DD)."
  end_date: Date

  "Daily start time (HH:MM:SS format)."
  start_time: String

  "Daily end time (HH:MM:SS format)."
  end_time: String

  "Array of active days for recurring schedules."
  active_days: [DayOfWeek!]

  "Special dates with custom availability rules."
  special_dates: [MenuSpecialDateInput!]

  "Priority for overlapping menu schedules (higher = higher priority)."
  priority: Int

  "Whether to automatically activate/deactivate based on schedule."
  auto_activate: Boolean

  "Timezone for this menu's schedule (overrides location timezone)."
  schedule_timezone: String
}

"Input for special date configuration"
input MenuSpecialDateInput {
  "Date in YYYY-MM-DD format"
  date: String!

  "Whether menu is available on this date"
  is_available: Boolean!

  "Custom start time for this date"
  start_time: String

  "Custom end time for this date"
  end_time: String

  "Optional note about this special date"
  note: String
}

"Input for updating the status of one or more items in an order list."
input UpdateItemListStatusInput {
  "Unique identifier of the order being updated (required)."
  orderId: ID!

  "List of item statuses to update (required)."
  items: [ItemStatusUpdateInput!]!
}

"Input for updating the status of a single item in an order."
input ItemStatusUpdateInput {
  "Unique identifier of the order item (required)."
  itemId: ID!

  "New status for the item (required)."
  status: TableOrderItemStatus!
}

"Input for uploading or referencing a menu image file."
input SSPMenuImageFileInput {
  "Original file name of the uploaded image (required)."
  fileName: String!

  "MIME type of the uploaded image (required)."
  fileType: String!
}

"Input for uploading an image to the system."
input UploadImageInput {
  "Image file to be uploaded (required)."
  file: Upload!

  "Category of the image (e.g., LOGO, MENU_SCAN, MENU_ITEM) (required)."
  category: ImageCategory!

  "Associated location ID (required if category is LOGO or MENU_SCAN)."
  locationId: ID

  "Associated menu item ID (required if category is MENU_ITEM)."
  menuItemId: ID

  "Preferred image size (optional: 'small', 'medium', or 'large')."
  preferredSize: String
}

"""
Input for deleting menu entities (menus, items, categories) with context awareness.
Provides context about whether the operation is being performed from a location view
or collection view, enabling proper authorization and scope validation.
"""
input DeleteMenuEntityInput {
  "The ID of the entity to delete (required)."
  id: ID!

  """
  The location context (if deleting from a location view).
  When provided, the system will verify:
  - If the entity is collection-scoped, the deletion will be BLOCKED
  - If the entity is location-scoped to a different location, the deletion will be BLOCKED
  - Only entities scoped to this specific location can be deleted
  """
  location_id: ID

  """
  The collection context (if deleting from a collection view).
  When provided, the system will verify:
  - If the entity is location-scoped, the deletion will be BLOCKED
  - Only entities scoped to this specific collection can be deleted
  """
  location_coll_id: ID
}

"Input for creating a new order."
input OrderInput {
  "Table number associated with the order (required)."
  tableNumber: String!

  "Name of the waiter taking the order (required)."
  waiterName: String!

  "Number of guests at the table (required)."
  partySize: Int!

  "Name of the restaurant where the order is placed (required)."
  restaurant: String!

  "List of items included in the order (required)."
  orderItems: [OrderItemInput!]!
}

"Input for a single item within an order."
input OrderItemInput {
  "Unique identifier of the menu item (required)."
  menuItemId: ID!

  "Quantity of the menu item ordered (required)."
  quantity: Int!

  "Optional list of customizations applied to the item."
  customizations: [CustomizationInput]
}

"Input for a customization applied to an order item."
input CustomizationInput {
  "Name of the customization (required)."
  name: String!

  "Price adjustment for this customization (required)."
  price: Float!

  "Optional details describing the customization."
  details: String
}

"Input for splitting items between orders."
input SplitOrderDetailInput {
  "Unique identifier of the original order item being split (required)."
  itemId: ID!

  "Quantity of the item to move into the target order (required)."
  quantity: Int!

  "Target order ID to which the item quantity will be moved. If null, a new order will be created."
  targetOrderId: ID
}

"Input for updating the quantity of one or more order items in bulk."
input BatchOrderItemQuantityInput {
  "Unique identifier of the existing order item (optional)."
  itemId: ID

  "Unique identifier of the menu item (optional, if not using itemId)."
  menuItemId: ID

  "New quantity for the item (required)."
  quantity: Int!

  "Optional list of customizations applied to the item."
  customizations: [CustomizationInput]
}

"Input for updating the status of an order."
input UpdateOrderStatusInput {
  "Unique identifier of the order to update (required)."
  orderId: String!

  "New status of the order (required)."
  status: SSPOrderStatus!
}

"Input for transferring a table order to another waiter."
input TransferTableInput {
  tableOrderId: ID!
  recipientUserId: ID!
  note: String
  managerId: ID
  managerPin: String
}

"""
Input for recording a manual payment (cash, check, etc.).
Used by waiters to mark orders as paid with non-card payments.
"""
input RecordManualPaymentInput {
  "Unique order ID (unique_orderid, e.g., 'NJR732') (required)."
  orderId: ID!

  "Payment amount (required)."
  amount: Float!

  "Payment method used (required)."
  paymentMethod: PaymentMethod!

  "Tip amount collected (optional)."
  tipAmount: Float

  "ID of the employee recording the payment (required)."
  employeeId: ID!

  "Optional note about the payment."
  note: String
}

"""
Input for filtering reports by date, location, or server.

**Timezone handling:** Date inputs are interpreted in the location's configured timezone.
For example, "2024-01-15" for a Toronto location means midnight to 11:59 PM Eastern Time.
The backend converts these to UTC for querying.
"""
input ReportFilterInput {
  "Start date of the reporting period (required). Interpreted in the location's timezone."
  dateFrom: Date!

  "End date of the reporting period (required). Interpreted in the location's timezone."
  dateTo: Date!

  "Optional location filter."
  locationId: ID

  "Optional server (waiter/staff) filter."
  serverId: ID
}

"Input for configuring a payment gateway for a specific location."
input PaymentGatewayConfigInput {
  "Unique identifier of the location (required)."
  locationId: ID!

  "Name of the payment gateway (e.g., STRIPE, SQUARE)."
  gatewayName: String!

  "Serialized JSON configuration for the gateway."
  gatewayConfig: JSON!

  "Optional webhook configurations for payment events."
  webhooks: [WebhookConfigInput!]
}

"Input for defining a webhook tied to a payment gateway."
input WebhookConfigInput {
  "Target URL to receive webhook events (required)."
  url: String!

  "Event type to subscribe to (e.g., PAYMENT_SUCCEEDED)."
  eventType: String!
}

"Input for customizing the design of a printed/digital check (receipt)."
input CheckDesignInput {
  "Header customization settings."
  header: CheckDesignHeaderInput

  "Body customization settings."
  body: CheckDesignBodyInput

  "Footer customization settings."
  footer: CheckDesignFooterInput

  "Styling customization (fonts, colors, spacing)."
  style: CheckDesignStyleInput

  "Layout customization (margins, padding)."
  layout: CheckDesignLayoutInput
}

"Input for customizing the header section of a check."
input CheckDesignHeaderInput {
  "Override restaurant name displayed on the check."
  restaurantName: String

  "Override restaurant address displayed on the check."
  address: String

  "Whether to display the date."
  includeDate: Boolean

  "Whether to display the servers name."
  includeServerName: Boolean

  "Whether to display the invoice number."
  includeInvoiceNumber: Boolean

  "Whether to display the logo."
  showLogo: Boolean

  "Whether to display the number of guests."
  showNumberOfGuests: Boolean

  "Whether to display the table number."
  showTableNumber: Boolean

  "Whether to display the time."
  showTime: Boolean

  "Time format to use (e.g., 12h, 24h)."
  timeFormat: TimeFormat

  "Date format to use (e.g., MM/DD/YYYY)."
  dateFormat: DateFormat
}

"Input for customizing the body section of a check."
input CheckDesignBodyInput {
  "Whether to display an itemized list of ordered items."
  showItemizedList: Boolean

  "Whether to display the subtotal."
  showSubtotal: Boolean

  "Whether to display discounts."
  showDiscounts: Boolean

  "Whether to display taxes."
  showTaxes: Boolean

  "Whether to display tips."
  showTip: Boolean

  "Whether to split taxes into multiple lines."
  splitTaxes: Boolean

  "Whether to show tax rates next to amounts."
  showTaxRate: Boolean
}

"Input for customizing the footer section of a check."
input CheckDesignFooterInput {
  "Whether to display the total amount."
  showTotalAmount: Boolean

  "Whether to display a QR code."
  showQrCode: Boolean

  "Custom thank-you message."
  thankYouMessage: String

  "Legal information or disclaimers."
  legalInfo: String

  "List of tax display configurations."
  taxes: [TaxDisplayInput]

  "Text displayed above the QR code."
  qrcodeTextAbove: String

  "Text displayed below the QR code."
  qrcodeTextBelow: String
}

"Input for defining how each tax should be displayed on the check."
input TaxDisplayInput {
  "Full tax name (e.g., 'Goods and Services Tax')."
  taxLN: String

  "Short tax name (e.g., 'GST')."
  taxSN: String

  "Unique tax identifier (UUID)."
  taxID: String

  "Whether to display the full tax name."
  displayFullName: Boolean

  "Whether to display the short tax name."
  displayShortName: Boolean

  "Whether to display the tax ID."
  displayTaxID: Boolean

  "Whether to display the tax as included in the total."
  taxValueIncluded: Boolean

  "Tax rate to display (e.g., '0.071' for 7.1%)."
  taxValueAdded: String

  "Official tax registration number."
  taxRegistrationNumber: String
}

"Input for customizing check styles (fonts, sizes, alignment, colors)."
input CheckDesignStyleInput {
  "Font family configuration for different sections."
  fontFamily: FontFamilyInput

  "Font size configuration for different sections."
  fontSize: FontSizeInput

  "Text alignment configuration for different sections."
  textAlign: TextAlignInput

  "Color configuration for different sections."
  colors: ColorsInput

  "Whether to show dividing lines in sections."
  dividers: DividersInput

  "Line spacing configuration for different sections."
  lineSpacing: LineSpacingInput
}

"Input for customizing check layout (margins, padding)."
input CheckDesignLayoutInput {
  "Margins to apply to the check layout."
  margins: String

  "Padding to apply inside the check layout."
  padding: String
}

"Font family customization for check sections."
input FontFamilyInput {
  header: String
  body: String
  total: String
  footer: String
}

"Font size customization for check sections."
input FontSizeInput {
  header: String
  body: String
  total: String
  footer: String
}

"Text alignment customization for check sections."
input TextAlignInput {
  header: String
  body: String
  total: String
  footer: String
}

"Color customization for check sections."
input ColorsInput {
  header: String
  body: String
  total: String
  footer: String
}

"Divider line visibility for check sections."
input DividersInput {
  header: Boolean
  body: Boolean
  total: Boolean
  footer: Boolean
}

"Line spacing customization for check sections."
input LineSpacingInput {
  header: String
  body: String
  total: String
  footer: String
}

"""
Client-provided payment breakdown for server-side verification.

All amounts should match the order's calculated values. The server will verify
these against its own calculations to prevent client-side amount manipulation.

When verification fails, the server returns specific error codes:
- SUBTOTAL_MISMATCH: Subtotal doesn't match server calculation
- TAX_MISMATCH: Tax total doesn't match
- SERVICE_CHARGE_MISMATCH: Service charge doesn't match
- DISCOUNT_MISMATCH: Discount amount doesn't match
- TOTAL_MISMATCH: Final total doesn't match
- ORDER_MODIFIED: Multiple fields differ (order was updated, please refresh)
- NEGATIVE_TIP: Tip amount is negative
- EXCEEDS_REMAINING_BALANCE: Payment amount exceeds remaining balance
"""
input PaymentBreakdownInput {
  """
  Sum of all item subtotals (excluding cancelled/voided items).
  This should match the order's sub_total field.
  """
  subtotal: Float!

  """
  Total tax amount across all items.
  This should match the order's tax_total field.
  """
  taxTotal: Float!

  """
  Service charge amount (if applicable).
  Only required if the order has a service charge applied.
  """
  serviceCharge: Float

  """
  Client-added tip amount. Must be non-negative.
  This is the tip the customer is adding at payment time.
  Note: Restaurant-added tips are calculated separately on the server.
  """
  tip: Float

  """
  Discount amount applied to the order.
  This should match the order's discount_amount field.
  """
  discountAmount: Float

  """
  Final total amount calculated as:
  subtotal + taxTotal + serviceCharge + tip - discountAmount
  
  This must match the server's calculation within a 1 cent tolerance.
  """
  total: Float!
}

"Input for registering a new printer in the system."
input AddPrinterInput {
  "Name of the printer (required)."
  name: String!

  "Location ID where the printer is installed (required)."
  locationId: ID!

  "Optional organization ID if the printer is tied to an organization."
  organizationId: ID

  "Printer socket name (used for identification)."
  sockName: String

  "Printer IP address (used for network printers)."
  sockIp: String

  "Printer port number (used for network printers)."
  sockPort: Int

  "List of job types the printer supports (e.g., RECEIPT, KITCHEN, BAR)."
  jobs: [String]
}

"Input for associating a printer with a specific print job type."
input AddPrinterJobInput {
  "Location ID where the printer is installed (required)."
  locationId: ID!

  "Unique identifier of the printer (required)."
  printerId: ID!

  "Type of job the printer handles (e.g., RECEIPT, KITCHEN)."
  jobType: String!
}

"Input for configuring or updating printer details."
input SSPPrinterInput {
  "Optional alias for easier identification (e.g., 'Kitchen Printer')."
  alias: String

  "Name of the printer."
  name: String

  "Printer socket name."
  sockName: String

  "Printer IP address."
  sockIp: String

  "Printer port number."
  sockPort: Int
}

"""
Input for sending a print request to a specific printer.
Supports both RabbitMQ-based printers (via PrinterManagement app) and
Star CloudPRNT printers (direct HTTP polling).
"""
input PrintRequestInput {
  "Type of print content: html, pdf, raw, or png."
  type: String!

  "Target printer by name (must match registered printer for RabbitMQ printers)."
  printer_name: String!

  "Content to print (raw text, HTML, or base64-encoded PDF/PNG)."
  content: String!

  "Optional job type classification for routing (RECEIPT, KITCHEN, CHIT, BAR, LABEL)."
  job_type: String
}

"Input for creating a new section in a restaurant location."
input CreateSectionInput {
  "Unique identifier of the location (required)."
  locationId: ID!

  "Name of the section (required)."
  name: String!

  "Display order for sorting sections."
  displayOrder: Int

  "Whether the section is currently active."
  isActive: Boolean
}

"Input for updating an existing section."
input UpdateSectionInput {
  "Unique identifier of the section being updated (required)."
  id: ID!

  "New name of the section."
  name: String

  "Updated display order."
  displayOrder: Int

  "Whether the section is active."
  isActive: Boolean
}

"Input for assigning a user to a section or table during a shift."
input AssignSectionInput {
  "Unique identifier of the location (required)."
  locationId: ID!

  "Optional section being assigned."
  sectionId: ID

  "Optional table being assigned."
  tableId: ID

  "Unique identifier of the user being assigned (required)."
  userId: ID!

  "Optional shift identifier if tied to a scheduled shift."
  shiftId: ID

  "Optional shift date if not tied to a shift ID."
  shiftDate: Date

  "Assignment start time."
  startAt: DateTime

  "Assignment end time."
  endAt: DateTime

  "Role label for the assignment (e.g., 'Primary Waiter')."
  roleLabel: String

  "Whether this assignment is the users primary role (default: true)."
  isPrimary: Boolean = true

  "Relative weight of the assignment for load balancing (default: 100)."
  weight: Int = 100
}

"Input for editing an existing table."
input EditTableInput {
  "Name or label of the table (e.g., 'Table 1')."
  name: String

  "Number of seats available at the table."
  number_of_seats: Int

  "Current status of the table (e.g., AVAILABLE, OCCUPIED)."
  status: String

  "Serialized reservation information for the table."
  reservation_info: String

  "Types of table (e.g., SQUARE, ROUND)."
  table_type: [TableType]

  "Accessibility notes (e.g., wheelchair accessible)."
  accessibility: String

  "Minimum spend required at the table."
  minimum_spend: Float

  "Additional notes about the table."
  special_notes: String

  "Timestamp or string when the table was last cleaned."
  last_cleaned: String
}

"Input for reservation details associated with a table."
input ReservationInfoInput {
  "Date and time of the reservation."
  reservationTime: DateTime

  "Name of the customer making the reservation."
  customerName: String
}

"Input for creating a new table in a location."
input CreateTableInput {
  "Name or label of the table (required)."
  name: String!

  "Number of seats available at the table (required)."
  number_of_seats: Int!

  "Initial status of the table (required)."
  status: SSPTableStatus!

  "Serialized reservation information."
  reservation_info: String

  "Types of table (e.g., SQUARE, ROUND)."
  table_type: [TableType]

  "Accessibility notes (e.g., wheelchair accessible)."
  accessibility: String

  "Minimum spend required at the table."
  minimum_spend: Float

  "Additional notes about the table."
  special_notes: String

  "Timestamp or string when the table was last cleaned."
  last_cleaned: String
}

"Input for defining the layout of a table within a floor plan."
input TableLayoutInput {
  "Name or label of the table (required)."
  name: String!

  "Location identifier or reference (required)."
  location: String!

  "Number of seats at the table (required)."
  numberOfSeats: Int!

  "X-coordinate position on the floor plan (required)."
  positionX: Float!

  "Y-coordinate position on the floor plan (required)."
  positionY: Float!

  "Floor number where the table is located (required)."
  floorNumber: Int!

  "Shape of the table (e.g., 'CIRCLE', 'SQUARE')."
  shape: String!

  "Size descriptor of the table (e.g., 'SMALL', 'LARGE')."
  size: String!
}

"Input for creating a custom (user-defined) tax."
input CreateCustomTaxInput {
  "Full name of the tax (e.g., 'Goods and Services Tax')."
  name: String!

  "Short name or abbreviation of the tax (e.g., 'GST')."
  name_short: String!

  "Numeric rate of the tax (e.g., 0.13 for 13%)."
  rate: Float!

  "String representation of the tax rate (optional)."
  rate_str: String

  "Whether the tax is included in listed prices (required)."
  is_included: Boolean!

  "Country where this tax applies (ISO-3166 code)."
  country: String

  "Region or province where this tax applies."
  region: String

  "Administrative area or city where this tax applies."
  admin_area: String
}

"Input for associating an existing tax with a specific location."
input LocationTaxInput {
  "Unique identifier of the SSP location (required)."
  s_s_p_location_id: ID!

  "Unique identifier of the SSP tax (required)."
  s_s_p_tax_id: ID!

  "Tax registration number for the location (optional)."
  tax_reg_id: String

  "Custom display name for the tax (optional)."
  custom_tax_name: String

  "Custom rate override for the tax (optional)."
  custom_rate: Float

  "Whether the tax is active for this location (required)."
  is_active: Boolean!

  "How this tax behaves when composed with others (stacking/compounding)."
  composition_behavior: CompositionBehavior
}

"Filter input for querying or matching tax rules."
input TaxRuleFilterInput {
  "Menu item ID if the rule applies to a specific item."
  item_id: ID

  "Category ID if the rule applies to a menu category."
  category_id: ID

  "Location ID if the rule is location-specific."
  location_id: ID

  "Whether the rule marks the item/category as tax exempt."
  is_exempt: Boolean

  "Priority of this rule relative to others."
  priority: Int

  "Start date when the rule becomes effective."
  start_date: DateTime

  "End date when the rule expires."
  end_date: DateTime
}

"Input for creating or updating a tax rule in the system."
input SSPTaxRuleInput {
  "Tax ID that this rule is associated with (required)."
  tax_id: ID!

  "Menu item ID if this rule applies to a specific item."
  item_id: ID

  "Category ID if this rule applies to a menu category."
  category_id: ID

  "Location ID if this rule applies only at a specific location."
  location_id: ID

  "Start date when the rule becomes effective."
  start_date: DateTime

  "End date when the rule expires."
  end_date: DateTime

  "Minimum quantity threshold for this rule to apply."
  quantity_min: Int

  "Maximum quantity threshold for this rule to apply."
  quantity_max: Int

  "Priority of the rule (higher priority overrides lower ones)."
  priority: Int

  "Whether this rule marks the target as tax exempt."
  is_exempt: Boolean

  "Scope of applicability for this rule (GLOBAL, LOCATION, CATEGORY, ITEM)."
  scope: SSPTaxApplicableTo

  "Optional ID of another rule this one overrides."
  overrides_rule_id: ID
}

"Input for recording a clock-in event."
input ClockInInput {
  "The location ID where the user is clocking in (required)."
  location_id: ID!

  "Latitude of the device at the time of clock-in (optional)."
  lat: Float

  "Longitude of the device at the time of clock-in (optional)."
  long: Float

  "Associated scheduled shift ID, if applicable."
  scheduled_shift_id: ID

  "Unique fingerprint of the device used for clock-in."
  device_fingerprint: String

  "Manager approval code, used for inline override (optional)."
  manager_approval_code: String
}

"Input for recording a clock-out event."
input ClockOutInput {
  "The location ID where the user is clocking out (required)."
  location_id: ID!

  "Latitude of the device at the time of clock-out (optional)."
  lat: Float

  "Longitude of the device at the time of clock-out (optional)."
  long: Float

  "Status of the shift at clock-out (e.g., COMPLETED, CANCELLED)."
  status: ShiftStatus

  "Unique fingerprint of the device used for clock-out."
  device_fingerprint: String

  "Manager approval code, used for inline override (optional)."
  manager_approval_code: String
}

"Settings for timeclock behavior and validation rules."
input TimeclockSettingsInput {
  "Radius in meters for geofence validation (optional)."
  geofenceRadiusMeters: Int

  "Require geofence validation when clocking out."
  requireGeofenceOnClockOut: Boolean

  "Minutes before scheduled shift start that clock-in is allowed."
  clockInWindowBeforeMin: Int

  "Minutes after scheduled shift start that clock-in is allowed."
  clockInWindowAfterMin: Int

  "Whether ad-hoc clock-ins (without a scheduled shift) are allowed."
  allowAdHocClockIn: Boolean

  "Minutes for rounding rule (e.g., 15-min increments)."
  roundingRuleMin: Int

  "Whether to bind a shift to a specific device."
  bindDeviceForShift: Boolean
}

"""
Input for defining a work shift.

**Timezone:** DateTime inputs (start_time, end_time) should be provided as ISO 8601
DateTime strings. These are stored and processed in the location's configured timezone.
"""
input ShiftInput {
  "The location ID where the shift takes place (required)."
  location_id: ID!

  "Title or label for the shift (optional)."
  title: String

  "Role assigned for this shift (e.g., SERVER, MANAGER)."
  role: String

  "Start time of the shift (required). Provide as ISO 8601 DateTime."
  start_time: DateTime!

  "End time of the shift (required). Provide as ISO 8601 DateTime."
  end_time: DateTime!
}

"Input for assigning a shift to a user."
input ShiftAssignmentInput {
  "The shift ID being assigned (required)."
  shift_id: ID!

  "The user ID assigned to this shift (required)."
  user_id: ID!

  "Optional note for the assignment (e.g., coverage details)."
  note: String
}

"""
Input representing either a specific shift or a custom timespan.

**Timezone:** DateTime inputs (startAt, endAt) should be provided as ISO 8601 DateTime strings.
These are processed in the location's configured timezone.
"""
input TimespanOrShiftInput {
  "Unique token provided by the client for correlating entries."
  key: String!

  "Shift ID if referencing a scheduled shift."
  shiftId: ID

  "Custom start datetime if not referencing a shift. Provide as ISO 8601 DateTime."
  startAt: DateTime

  "Custom end datetime if not referencing a shift. Provide as ISO 8601 DateTime."
  endAt: DateTime
}

"""
Input for adjusting an existing clock entry.

**Timezone:** DateTime inputs should be provided as ISO 8601 DateTime strings.
These are processed in the location's configured timezone.
"""
input AdjustClockEntryInput {
  "Revised clock-in time (optional). Provide as ISO 8601 DateTime."
  clock_in_time: DateTime

  "Revised clock-out time (optional). Provide as ISO 8601 DateTime."
  clock_out_time: DateTime

  "Reason for adjustment (required)."
  note: String!
}

"Input for bulk importing shifts from CSV data."
input BulkShiftImportInput {
  """
  CSV content as a string. Expected columns:
  location_id, title, role, start_time, end_time, employee_email
  """
  csvContent: String!

  "Whether to skip the first row as a header (default: true)."
  skipHeader: Boolean

  "If true, validate only without creating records (default: false)."
  dryRun: Boolean
}

"""
Input for initiating Uber Eats OAuth connection.
Includes optional parameters for customizing the connection.
"""
input ConnectUberEatsInput {
  "Restaurant location ID to connect this Uber Eats account to"
  location_id: ID!

  "Callback URL to redirect to after OAuth completion (optional, uses default if not provided)"
  callback_url: String

  "Additional metadata to store with the connection"
  metadata: JSON
}

"Input for disconnecting from Uber Eats."
input DisconnectUberEatsInput {
  "ID of the connection to disconnect"
  connection_id: ID!

  "Reason for disconnection (optional, for logging)"
  reason: String
}

"Input for registering a new user account."
input RegisterInput {
  "Full name of the user (required)."
  name: String!

  "Primary email address (required)."
  email: String!

  "Optional username (used if your system supports unique usernames)."
  username: String

  "Password chosen by the user (required)."
  password: String!

  "Confirmation of the password (required)."
  password_confirmation: String!

  "Referral code used for registration, if provided."
  referral_code: String
}

"Input for updating a basic user profile."
input UserProfile {
  "Updated name of the user."
  name: String

  "Updated email address."
  email: String

  "Updated username."
  username: String
}

"Extended profile fields for a user."
input UserProfileExtInput {
  "Unique user ID (required)."
  id: ID!

  "Street address of the user."
  address: String

  "City of residence."
  city: String

  "State or province."
  state: String

  "Postal or ZIP code."
  postal_code: String

  "Country code (ISO-3166)."
  country: String

  "Phone number of the user."
  phone_number: String

  "Personal or business website URL."
  website: String

  "Additional notes about the user."
  notes: String
}

"Input for deleting an invitation."
input DeleteInvitationInput {
  "Invitation code to delete."
  code: String

  "Email address associated with the invitation."
  email: String
}

"Input for resending an invitation."
input ResendInvitationInput {
  "Invitation code to resend."
  code: String

  "Email address associated with the invitation."
  email: String
}

"Input for canceling an invitation."
input CancelInvitationInput {
  "Unique identifier of the invitation to cancel (required)."
  invitationCode: ID!
}

"Input for removing a member from a restaurant or organization."
input RemoveMemberInput {
  "Unique identifier of the user being removed (required)."
  userId: ID!
}

"""
Input for updating a member's roles, collections, locations, or status.

For role assignment, you can use:
- `newRoles` for system roles (WAIT_STAFF, LOCATION_MANAGER, etc.)
- `newCustomRoleIds` for custom roles created by your organization

Both can be provided together to assign a mix of system and custom roles.
"""
input UpdateMemberInput {
  "Unique identifier of the user being updated (required)."
  userId: ID!

  "Context in which the employee operates (required)."
  context: EmployeeContext!

  "Updated list of system roles assigned to the user (e.g., WAIT_STAFF, LOCATION_MANAGER)."
  newRoles: [AssignableRoles]

  "Updated list of custom role IDs to assign to the user."
  newCustomRoleIds: [ID]

  "Updated list of collections the user has access to."
  newCollections: [ID]

  "Updated list of locations the user has access to."
  newLocations: [ID]

  "Updated user status (e.g., ACTIVE, ON_LEAVE, TERMINATED)."
  status: UserStatus
}

"Input for resetting a user password."
input ResetPasswordInput {
  "Email address of the account (required)."
  email: String!

  "Password reset token (required)."
  token: String!

  "New password (required)."
  password: String!

  "Confirmation of the new password (required)."
  password_confirmation: String!

  "Two-factor authentication code (optional)."
  two_factor_code: String
}

"Input for updating user-specific settings."
input UpdateUserSettingsInput {
  "Unique identifier of the user (required)."
  user_id: ID!

  "Enable or disable dark mode UI preference."
  dark_mode: Boolean

  "Enable or disable training mode for guided tutorials."
  training_mode: Boolean
}

"Input for changing a user's email address."
input ChangeEmailInput {
  "Current password (used to confirm identity)."
  currentPassword: String!

  "New email address to set."
  newEmail: String!
}

input RegisterWithOrganizationInput {
  name: String!
  email: String!
  password: String!
  password_confirmation: String!
  orgName: String!
  subscriptionPlan: SubscriptionPlan! = PLAN_FREE
  location: LocationInput
  collection: CollectionInput
}

input SocialLoginInput {
  provider: SocialProvider!
  accessToken: String!
  authCode: String
  idToken: String
  invitationCode: String
}

input LinkSocialAccountInput {
  provider: SocialProvider!
  accessToken: String!
  authCode: String
  idToken: String
}

"""
Summary of a waiter's current or past shift performance.
Includes orders served, sales, tips, and hours worked.
"""
type ShiftSummary {
  "The shift being summarized."
  shift: Shift

  "Clock entry for this shift."
  clockEntry: ClockInOut

  "Clock-in time for the shift."
  clockInTime: DateTime

  "Clock-out time (null if still clocked in)."
  clockOutTime: DateTime

  "Total hours worked in this shift."
  hoursWorked: Float!

  "Number of orders served during this shift."
  ordersServed: Int!

  "Total sales amount for this shift."
  totalSales: Float

  "Total tips earned during this shift."
  tipsEarned: Float

  "Revenue generated per hour worked."
  revenuePerHour: Float

  "Average order value during this shift."
  avgOrderValue: Float

  "Number of orders served per hour."
  ordersPerHour: Float

  "Tip rate as percentage of total sales."
  tipRate: Float
}

"Comparison of an employee's performance against team averages."
type TeamComparison {
  "Employee's average order value."
  avgOrderValue: Float!

  "Team's average order value."
  teamAvgOrderValue: Float!

  "Percentage difference from team average."
  avgOrderValueDelta: Float!

  "Employee's customer rating (if available)."
  customerRating: Float

  "Team's average customer rating."
  teamAvgRating: Float

  "Percentage difference in rating."
  ratingDelta: Float

  "Employee's orders per hour."
  ordersPerHour: Float!

  "Team's average orders per hour."
  teamOrdersPerHour: Float!

  "Percentage difference in orders per hour."
  ordersPerHourDelta: Float!
}

"""
Summary of customer feedback and ratings.
Note: This may be populated from external services or future feedback system.
"""
type GuestFeedback {
  "Average rating from customers."
  averageRating: Float!

  "Total number of reviews received."
  totalReviews: Int!

  "Percentage of positive feedback."
  positivePercentage: Float!
}

"Detailed performance statistics for a waiter over a time period."
type DetailedStatistics {
  "Total tips earned."
  tipsEarned: Float!

  "Revenue generated per hour worked."
  revenuePerHour: Float!

  "Customer feedback sentiment (percentage)."
  customerFeedback: Float

  "Tip rate as percentage of sales."
  tipRate: Float!
}

"""
Comprehensive analytics for a waiter over a specified time period.
Includes personal stats, team comparisons, and guest feedback.
"""
type WaiterAnalytics {
  "The employee whose analytics are being displayed."
  employee: SSPUser!

  "Time period start."
  periodStart: DateTime!

  "Time period end."
  periodEnd: DateTime!

  "Total tips earned in the period."
  tipsEarned: Float

  "Total number of orders served."
  ordersServed: Int!

  "Total sales generated."
  totalSales: Float

  "Total hours worked."
  hoursWorked: Float!

  "Team comparison statistics."
  teamComparison: TeamComparison

  "Guest feedback summary."
  guestFeedback: GuestFeedback

  "Detailed statistics."
  detailedStatistics: DetailedStatistics

  "List of individual shifts in this period."
  shifts: [ShiftSummary!]!
}

"Defines the time period for analytics aggregation."
enum AnalyticsTimePeriod {
  "Current shift only."
  CURRENT_SHIFT

  "Today (all shifts combined)."
  TODAY

  "This week."
  THIS_WEEK

  "This month."
  THIS_MONTH

  "Custom date range (requires startDate and endDate)."
  CUSTOM
}

type BusinessCheckoutResponse {
  checkoutUrl: String!
  sessionId: String!
}

type BillingPortalResponse {
  portalUrl: String!
}

type SubscriptionStatus {
  plan: String!
  effectivePlan: String!
  status: String!
  isOnTrial: Boolean!
  trialDaysRemaining: Int
  trialExpired: Boolean!
  hasBillingIssues: Boolean!
  limits: OrganizationLimits!
}

type OrganizationLimits {
  maxLocations: Int
  maxEmployees: Int
  allowMultipleCollections: Boolean!
  allowThirdPartyGateways: Boolean!
}

type Invoice {
  id: String!
  number: String!
  amountDue: Float!
  amountPaid: Float!
  currency: String!
  hostedInvoiceUrl: String!
  status: String!
  createdAt: DateTime!
}

"Cash drawer session for tracking cash during an employee's shift."
type CashDrawer {
  id: ID!
  location: SSPLocation!
  user: SSPUser!
  clockInOut: ClockInOut

  "Drawer status: OPEN or CLOSED."
  status: CashDrawerStatus!

  "When the drawer was opened."
  openedAt: DateTime!

  "When the drawer was closed (null if still open)."
  closedAt: DateTime

  "Cash counted when opening the drawer."
  openingAmount: Float!

  "Cash counted when closing the drawer."
  closingAmount: Float

  "Expected cash based on transactions (opening + cash sales - cash refunds)."
  expectedCash: Float

  "Variance between counted and expected (positive = over, negative = short)."
  variance: Float

  "Note added when opening the drawer."
  openingNote: String

  "Note added when closing the drawer."
  closingNote: String

  "Manager who approved variance (if any)."
  approvedBy: SSPUser

  "When variance was approved."
  approvedAt: DateTime

  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CashDrawerStatus {
  "Drawer is currently open and active."
  OPEN

  "Drawer has been closed and reconciled."
  CLOSED
}

"Input for opening a cash drawer."
input OpenCashDrawerInput {
  "Location where the drawer is being opened."
  locationId: ID!

  "Initial cash amount in the drawer."
  openingAmount: Float!

  "Optional note (e.g., 'Starting float from safe')."
  note: String

  "Optional link to clock-in record."
  clockInOutId: ID
}

"Input for closing a cash drawer."
input CloseCashDrawerInput {
  "ID of the drawer to close."
  drawerId: ID!

  "Counted cash amount in the drawer."
  closingAmount: Float!

  "Optional closing note."
  note: String
}

"Summary of cash drawer for a shift or day."
type CashDrawerSummary {
  "Total cash at start of period."
  openingTotal: Float!

  "Total cash at end of period."
  closingTotal: Float!

  "Total expected based on transactions."
  expectedTotal: Float!

  "Total variance (positive = over, negative = short)."
  totalVariance: Float!

  "Number of drawers with variances."
  drawersWithVariance: Int!

  "Individual drawer records."
  drawers: [CashDrawer!]!
}

"Status of a cloud printer connection."
enum CloudPrinterStatus {
  "Printer is awaiting initial configuration."
  PENDING

  "Printer is online and polling for jobs."
  ONLINE

  "Printer has stopped polling (offline)."
  OFFLINE

  "Printer reported an error."
  ERROR
}

"Status of a cloud print job."
enum CloudPrintJobStatus {
  "Job is queued and waiting for printer to poll."
  PENDING

  "Job content was sent to the printer."
  SENT

  "Printer is currently printing the job."
  PRINTING

  "Job was successfully printed."
  COMPLETED

  "Job failed to print."
  FAILED

  "Job expired before being printed."
  EXPIRED
}

"Priority levels for print jobs."
enum CloudPrintJobPriority {
  "Low priority, processed after normal jobs."
  LOW

  "Normal priority (default)."
  NORMAL

  "High priority, processed before normal jobs."
  HIGH

  "Urgent priority, processed immediately."
  URGENT
}

"Type of print content."
enum CloudPrintContentType {
  "PDF document (will be converted to PNG)."
  PDF

  "PNG image (native CloudPRNT format)."
  PNG

  "Raw text."
  RAW
}

"""
Represents a Star printer connected via CloudPRNT protocol.
These printers poll the server directly via HTTP, without requiring
the PrinterManagement desktop application.
"""
type CloudPrinter {
  "Unique identifier of the cloud printer."
  id: ID!

  "MAC address of the printer (unique identifier from Star)."
  macAddress: String!

  "Serial number of the printer."
  serialNumber: String

  "Location this printer belongs to."
  locationId: ID!

  "Organization this printer belongs to."
  organizationId: ID!

  "Printer model (e.g., TSP100, mC-Print3)."
  printerModel: String

  "Firmware version of the printer."
  firmwareVersion: String

  "User-friendly name for the printer."
  alias: String

  "Current connection status."
  status: CloudPrinterStatus!

  "Last time the printer polled for jobs."
  lastPollAt: String

  "When the printer was first registered."
  registeredAt: String

  "Paper width in pixels."
  paperWidth: Int!

  "Printer DPI resolution."
  dpi: Int!

  "Job types this printer handles (e.g., RECEIPT, KITCHEN)."
  jobTypes: [String!]

  "Whether the printer is currently online (based on recent polling)."
  isOnline: Boolean!

  "Display name (alias or model or MAC)."
  displayName: String!

  "Timestamp when the printer was created."
  createdAt: String!

  "Timestamp when the printer was last updated."
  updatedAt: String!
}

"Represents a print job queued for a CloudPRNT printer."
type CloudPrintJob {
  "Unique identifier of the print job."
  id: ID!

  "Token used by the printer to retrieve the job."
  jobToken: String!

  "Printer this job is assigned to."
  cloudPrinterId: ID!

  "Type of job (e.g., RECEIPT, KITCHEN)."
  jobType: String

  "MIME type of the content."
  contentType: String!

  "Current status of the job."
  status: CloudPrintJobStatus!

  "Priority level of the job."
  priority: Int!

  "When the job expires if not printed."
  expiresAt: String

  "When the job was sent to the printer."
  sentAt: String

  "When the job was completed."
  completedAt: String

  "Error message if job failed."
  errorMessage: String

  "Timestamp when the job was created."
  createdAt: String!

  "Timestamp when the job was last updated."
  updatedAt: String!
}

"Response from cloud print operations."
type CloudPrintResponse {
  "Overall status of the operation."
  status: String!

  "Message providing details about the result."
  message: String!

  "Token for the created print job (if applicable)."
  jobToken: String

  "ID of the created print job (if applicable)."
  jobId: ID
}

"Response from initiating Clover onboarding."
type CloverOnboardingResponse {
  "URL to redirect merchant for OAuth authorization."
  authorizationUrl: String!

  "Human-readable message."
  message: String!
}

"Clover connection status for a location."
type CloverConnectStatus {
  "Whether Clover is connected and credentials are valid."
  connected: Boolean!

  "Current status: NOT_CONNECTED, CONNECTED, TOKEN_EXPIRED, TOKEN_INVALID, ERROR."
  status: String!

  "Clover merchant ID."
  merchantId: String

  "Merchant business name from Clover."
  merchantName: String

  "Merchant address from Clover."
  address: JSON

  "Whether the token is expiring soon (within 24 hours)."
  tokenExpiringSoon: Boolean

  "Error message if status is ERROR."
  error: String
}

"Response from setting active payment provider or disconnecting."
type SetActiveProviderResponse {
  "Whether the operation succeeded."
  success: Boolean!

  "Currently active provider after the operation."
  activeProvider: String

  "Human-readable message."
  message: String!
}

"Response from setting Clover terminal mode."
type SetTerminalModeResponse {
  "Whether the operation succeeded."
  success: Boolean!

  "Current terminal mode after the operation."
  terminalMode: String

  "Human-readable message."
  message: String!
}

"Unified payment provider status for a location."
type PaymentProviderStatus {
  "Currently active provider: stripe, clover, or null."
  activeProvider: String

  "Stripe configuration status."
  stripe: StripeProviderStatus

  "Clover configuration status."
  clover: CloverProviderStatus
}

"Stripe provider configuration status."
type StripeProviderStatus {
  "Whether Stripe Connect is configured."
  configured: Boolean!

  "Stripe Connect account ID."
  accountId: String

  "Stripe Terminal location ID."
  terminalLocationId: String
}

"Clover provider configuration status."
type CloverProviderStatus {
  "Whether Clover is configured."
  configured: Boolean!

  "Clover merchant ID."
  merchantId: String

  "Terminal connection mode: cloud or local."
  terminalMode: String

  "Whether the token is expiring soon."
  tokenExpiringSoon: Boolean

  "Connection status from verification."
  connectionStatus: String

  "Merchant name from Clover."
  merchantName: String
}

"""
Custom Role Type
Represents an organization-specific custom role with metadata
"""
type CustomRole {
  "Unique identifier for the custom role"
  id: ID!

  "Associated Spatie role ID"
  roleId: ID!

  "Organization this custom role belongs to"
  organizationId: ID!

  "User-friendly display name"
  displayName: String!

  "Description of what this role does"
  description: String

  "Hex color code for UI theming (#RRGGBB)"
  colorHex: String

  "Icon identifier for UI"
  icon: String

  "System role this custom role is based on"
  baseRole: RestaurantRoles

  "Calculated privilege level (lower = higher privilege)"
  privilegeLevel: Int!

  "User who created this custom role"
  createdBy: SSPUser!

  "User who last updated this custom role"
  updatedBy: SSPUser

  "Spatie role name (e.g., CUSTOM_ORG123_SENIOR_WAITER_a1b2c3)"
  roleName: String!

  "Permissions assigned to this custom role"
  permissions: [Permission!]!

  "When this custom role was created"
  createdAt: DateTime!

  "When this custom role was last updated"
  updatedAt: DateTime!
}

"""
Permission Type
Represents a single permission in the system
"""
type Permission {
  "Permission identifier"
  id: ID!

  "Permission name (e.g., 'create_orders')"
  name: String!

  "Guard name (typically 'jwt')"
  guardName: String!
}

"Custom Role Creation Response"
type CustomRoleResponse {
  "The created or updated custom role"
  customRole: CustomRole!

  "Success message"
  message: String!
}

"Custom Role Deletion Response"
type DeleteCustomRoleResponse {
  "Whether the deletion was successful"
  success: Boolean!

  "Success or error message"
  message: String!
}

"Input for creating a custom role"
input CreateCustomRoleInput {
  "Display name for the custom role (required)"
  displayName: String!

  "Description of the role"
  description: String

  "Hex color for UI (#RRGGBB)"
  colorHex: String

  "Icon identifier"
  icon: String

  "Base system role this is derived from"
  baseRole: RestaurantRoles

  "Array of permission names to assign to this role"
  permissions: [String!]!
}

"Input for updating a custom role"
input UpdateCustomRoleInput {
  "ID of the custom role to update"
  id: ID!

  "New display name"
  displayName: String

  "New description"
  description: String

  "New color hex"
  colorHex: String

  "New icon"
  icon: String

  "New base role"
  baseRole: RestaurantRoles

  "Updated permissions array"
  permissions: [String!]
}

"Custom roles list with pagination info"
type CustomRoleConnection {
  "List of custom roles"
  data: [CustomRole!]!

  "Total count of custom roles"
  total: Int!
}

"Customer data types for orders (delivery, takeout, third-party integrations)"
type SSPOrderCustomer {
  "Unique identifier for the customer record."
  id: ID!

  "Full name of the customer."
  name: String

  "First name of the customer."
  first_name: String

  "Last name of the customer."
  last_name: String

  "Email address of the customer."
  email: String

  "Phone number of the customer."
  phone: String

  "Delivery street address."
  delivery_address: String

  "Delivery city."
  delivery_city: String

  "Delivery state/province."
  delivery_state: String

  "Delivery postal/ZIP code."
  delivery_postal_code: String

  "Delivery country."
  delivery_country: String

  "Full formatted delivery address."
  full_delivery_address: String

  "Whether this customer has ordered more than once."
  is_repeat_customer: Boolean

  "Total number of orders placed by this customer."
  order_count: Int

  "Total amount spent by this customer across all orders."
  total_spent: Float

  "External customer ID from third-party platform (Uber Eats, DoorDash, etc.)."
  external_id: String

  "Source platform: ubereats, doordash, grubhub, ssppos, etc."
  external_source: String

  "Internal notes about the customer."
  notes: String

  "Flexible metadata field for custom data (JSON)."
  metadata: JSON

  "Raw source data from third-party webhooks (JSON)."
  source_data: JSON

  "Timestamp when the customer record was created."
  created_at: DateTime!

  "Timestamp when the customer record was last updated."
  updated_at: DateTime!

  "All table orders for this customer."
  table_orders: [SSPTableOrder!]!
}

"Customer analytics aggregated data"
type CustomerAnalytics {
  "Customer record."
  customer: SSPOrderCustomer!

  "Total number of orders."
  total_orders: Int!

  "Total amount spent across all orders."
  total_spent: Float!

  "Average order value."
  average_order_value: Float!

  "Date of first order."
  first_order_date: DateTime

  "Date of most recent order."
  last_order_date: DateTime

  "Breakdown by order type."
  orders_by_type: JSON!

  "Breakdown by external source."
  orders_by_source: JSON!

  "Recent orders (last 10)."
  recent_orders: [SSPTableOrder!]!
}

"Type of customization that can be applied to menu items."
enum CustomizationTemplateType {
  "Add-on customization (e.g., Extra Cheese)."
  addon

  "Modification to existing item (e.g., Well Done)."
  modification

  "Removal of an ingredient (e.g., No Onions)."
  removal

  "Substitution of one ingredient for another (e.g., Gluten-Free Bun)."
  substitution
}

"Represents a reusable customization template that can be associated with multiple menu items."
type SSPCustomizationTemplate {
  "Unique identifier of the customization template (required)."
  id: ID!

  "Name of the customization (required)."
  name: String!

  "Default price adjustment for this customization."
  price: Float!

  "Description of the customization."
  description: String

  "Type of customization."
  type: CustomizationTemplateType!

  "Whether this template is currently active."
  is_active: Boolean!

  "Associated location ID (if location-specific)."
  location_id: Int

  "Associated location collection ID (if chain-wide)."
  location_coll_id: Int

  "Location this template belongs to."
  location: SSPLocation

  "Location collection this template belongs to."
  locationCollection: SSPLocCollection

  "Menu items that use this customization template."
  menuItems: [SSPMenuItem!]!

  "Number of menu items using this template."
  menuItemsCount: Int!

  "Timestamp when the template was created."
  created_at: DateTime

  "Timestamp when the template was last updated."
  updated_at: DateTime
}

"Represents the pivot data when a customization template is attached to a menu item."
type MenuItemCustomizationTemplatePivot {
  "The customization template."
  template: SSPCustomizationTemplate!

  "Override price for this specific menu item (null = use default)."
  price_override: Float

  "Whether this customization is pre-selected by default."
  is_default: Boolean!

  "Sort order for displaying customizations."
  sort_order: Int!

  "Effective price (price_override if set, otherwise default price)."
  effective_price: Float!
}

"Represents a paginated response for customization templates."
type PaginatedSSPCustomizationTemplate {
  "List of customization templates in the current page (required)."
  data: [SSPCustomizationTemplate!]!

  "Current page number (required)."
  currentPage: Int!

  "Total number of pages (required)."
  totalPages: Int!

  "Total number of records (required)."
  totalCount: Int!
}

"Response type for customization template mutations."
type CustomizationTemplateResponse {
  "Whether the operation succeeded (required)."
  success: Boolean!

  "Optional response message."
  message: String

  "Customization template returned in the response (if any)."
  template: SSPCustomizationTemplate
}

"Response type for bulk attach/detach operations."
type BulkAttachCustomizationTemplateResponse {
  "Whether the operation succeeded (required)."
  success: Boolean!

  "Optional response message."
  message: String

  "Number of menu items affected."
  affectedCount: Int!
}

"""
Represents a feature in the SSP system that can be announced to users.
Used for "blue dot" notifications and feature discovery.
"""
type SSPFeature {
  "Unique identifier for the feature."
  id: ID!

  "Unique key for the feature (e.g., \"dark_mode\", \"table_layout_v2\")."
  key: String!

  "Display name for the feature."
  name: String!

  "Detailed description of the feature (supports markdown)."
  description: String

  "Category of the feature."
  category: FeatureCategory!

  "Which SSP product this feature belongs to."
  product: SSPProduct!

  "UI location path for highlighting (e.g., \"settings.appearance\")."
  uiLocation: String

  "Link to documentation or help article."
  documentationUrl: String

  "Version when the feature was released."
  releaseVersion: String

  "When the feature was released."
  releasedAt: DateTime

  "Whether this feature is new for the current user (not yet seen)."
  isNew: Boolean!

  "The current user's interaction with this feature, if any."
  userInteraction: SSPUserFeatureInteraction

  "Order in the feature tour (1, 2, 3...). Null if not part of tour."
  tourOrder: Int

  "Where to position the tour popover relative to the element."
  tourPlacement: TourPlacement

  "Custom CSS selector for the tour target (overrides uiLocation)."
  tourSelector: String

  "Custom title for the tour step (defaults to name if not set)."
  tourTitle: String

  "Custom description for the tour step (defaults to description if not set)."
  tourDescription: String
}

"Represents a user's interaction with a feature."
type SSPUserFeatureInteraction {
  "Unique identifier for the interaction."
  id: ID!

  "The feature that was interacted with."
  feature: SSPFeature!

  "Type of interaction."
  interactionType: FeatureInteractionType!

  "When the interaction occurred."
  interactedAt: DateTime!
}

"Represents release notes for a version of the SSP system."
type SSPReleaseNote {
  "Unique identifier for the release note."
  id: ID!

  "Semantic version string (e.g., \"2.5.0\")."
  version: String!

  "Which SSP product this release note is for."
  product: SSPProduct!

  "Title of the release."
  title: String!

  "Short summary of the release."
  summary: String!

  "Full content of the release notes (supports markdown)."
  content: String!

  "URL to full release notes on docs.ssppos.com."
  documentationUrl: String

  "Type of release."
  releaseType: ReleaseType!

  "When the release was published."
  releasedAt: DateTime!

  "Whether this release note has been viewed by the current user."
  isViewed: Boolean!

  "Features included in this release."
  features: [SSPFeature!]!
}

"""
Overall status of feature discovery for the current user.
Useful for showing badges and notifications.
"""
type FeatureDiscoveryStatus {
  "Count of features the user hasn't seen yet."
  unseenFeatureCount: Int!

  "List of new features the user hasn't seen."
  newFeatures: [SSPFeature!]!

  "Whether there are any unviewed release notes."
  hasUnviewedReleaseNotes: Boolean!

  "Count of unviewed release notes."
  unviewedReleaseNotesCount: Int!

  "The latest release note (may or may not be viewed)."
  latestReleaseNote: SSPReleaseNote
}

"Paginated list of release notes."
type SSPReleaseNotePaginator {
  "Paginated list of release notes."
  data: [SSPReleaseNote!]!

  "Pagination information."
  paginatorInfo: PaginatorInfo!
}

"""
Analytics Field Visibility Configuration

Allows managers to control which analytics fields are visible to different roles.
Supports organization-wide and location-specific settings.
"""
type AnalyticsFieldVisibility {
  "Unique identifier."
  id: ID!

  "Location this configuration applies to (null = organization-wide)."
  location_id: ID

  "Role ID (foreign key to roles table)."
  role_id: ID!

  "Field key (e.g., 'shift_summary.total_sales')."
  field_name: String!

  "Whether this field is visible to the role."
  is_visible: Boolean!

  "When this configuration was created."
  created_at: DateTime!

  "When this configuration was last updated."
  updated_at: DateTime!
}

"Input for configuring visibility of a single analytics field for a specific role."
input AnalyticsFieldVisibilityInput {
  "Location ID (null = organization-wide setting)."
  locationId: ID

  """
  Role identifier. Accepts multiple formats:
  - Numeric Spatie role ID (e.g., "6")
  - Role name string (e.g., "location_manager", "wait_staff")
  - Custom role with prefix (e.g., "custom:42")
  
  Custom roles are validated against the user's organization.
  """
  roleId: ID!

  "Field key (e.g., 'shift_summary.total_sales')."
  fieldName: String!

  "Whether this role can see this field."
  isVisible: Boolean!
}

"""
Input for configuring multiple fields at once for a role.
More efficient for UI that shows a full configuration page.
"""
input BulkFieldVisibilityInput {
  "Location ID (null = organization-wide)."
  locationId: ID

  """
  Role identifier. Accepts multiple formats:
  - Numeric Spatie role ID (e.g., "6")
  - Role name string (e.g., "location_manager", "wait_staff")
  - Custom role with prefix (e.g., "custom:42")
  
  Custom roles are validated against the user's organization.
  """
  roleId: ID!

  "Map of field names to visibility."
  fields: [FieldVisibilityMapping!]!
}

"Mapping of field name to visibility setting."
input FieldVisibilityMapping {
  "Field key (e.g., 'shift_summary.total_sales')."
  fieldName: String!

  "Whether this field should be visible."
  isVisible: Boolean!
}

"Available field that can be configured for visibility control."
type AvailableAnalyticsField {
  "Field key (e.g., 'shift_summary.total_sales')."
  key: String!

  "Human-readable label for the field."
  label: String!

  "Category/group this field belongs to."
  category: String!
}

"Kitchen capacity configuration for a location or station"
type KitchenCapacityConfig {
  "Unique identifier"
  id: ID!

  "Associated location"
  location: SSPLocation!

  "Associated organization"
  organization: SSPOrganization!

  "Station category value (null = all stations)"
  stationCategoryValue: Int

  "Station name (e.g., 'Grill', 'Fryer')"
  stationName: String

  "Load thresholds (number of items in COOKING status)"
  lowLoadThreshold: Int!

  mediumLoadThreshold: Int!
  highLoadThreshold: Int!

  "Time multipliers for each load level"
  lowLoadMultiplier: Float!

  mediumLoadMultiplier: Float!
  highLoadMultiplier: Float!
  criticalLoadMultiplier: Float!

  "Manual override settings"
  manualOverride: Boolean!

  manualMultiplier: Float
  overrideExpiresAt: DateTime

  "Status"
  isActive: Boolean!

  "Metadata"
  createdBy: SSPUser

  updatedBy: SSPUser
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Real-time kitchen load metrics"
type KitchenLoadStatus {
  "Location"
  locationId: ID!

  "Station identifier"
  stationCategoryValue: Int

  stationName: String

  "Current load metrics"
  itemsInQueue: Int!

  ordersInQueue: Int!
  averageWaitTimeSeconds: Int

  "Calculated status"
  loadLevel: KitchenLoadLevel!

  activeMultiplier: Float!

  "Whether manual override is active"
  manualOverride: Boolean!

  "Applied configuration"
  config: KitchenCapacityConfig

  "Last updated timestamp"
  lastUpdated: DateTime!
}

"Prep time estimate calculation result (for guests to see realistic ETAs)"
type PrepTimeEstimate {
  "Base preparation time from menu item (minutes)"
  basePrepTime: Int!

  "Adjusted preparation time with capacity multiplier (minutes)"
  adjustedPrepTime: Int!

  "Multiplier applied based on current kitchen load"
  capacityMultiplier: Float!

  "Current kitchen load level"
  kitchenLoadLevel: KitchenLoadLevel!

  "Estimated timestamp when item will be ready"
  estimatedReadyAt: DateTime!
}

"Kitchen station definition"
type KitchenStation {
  "Station category value (null = all stations)"
  stationCategoryValue: Int

  "Station name"
  stationName: String!

  "Whether this station has an active capacity config"
  hasConfig: Boolean!

  "Number of menu items assigned to this station"
  menuItemCount: Int!
}

"Historical kitchen load snapshot"
type KitchenLoadSnapshot {
  "Unique identifier"
  id: ID!

  "Location ID"
  locationId: ID!

  "Location"
  location: SSPLocation!

  "Organization"
  organization: SSPOrganization!

  "Station identifier"
  stationCategoryValue: Int

  stationName: String

  "Load metrics"
  itemsInQueue: Int!

  ordersInQueue: Int!
  averageWaitTimeSeconds: Int

  "Calculated status at snapshot time"
  loadLevel: KitchenLoadLevel!

  activeMultiplier: Float!

  "When snapshot was taken"
  snapshotAt: DateTime!
}

"Input for creating or updating kitchen capacity configuration"
input KitchenCapacityConfigInput {
  "Location ID (required)"
  locationId: ID!

  "Station category value (null = all stations)"
  stationCategoryValue: Int

  "Station name"
  stationName: String

  "Load thresholds"
  lowLoadThreshold: Int!
  mediumLoadThreshold: Int!
  highLoadThreshold: Int!

  "Time multipliers"
  lowLoadMultiplier: Float!
  mediumLoadMultiplier: Float!
  highLoadMultiplier: Float!
  criticalLoadMultiplier: Float!

  "Active status"
  isActive: Boolean
}

"Input for manual kitchen load override"
input KitchenLoadOverrideInput {
  "Location ID"
  locationId: ID!

  "Station category value (null = all stations)"
  stationCategoryValue: Int

  "Manual multiplier (1.0 = normal, 2.0 = double time)"
  manualMultiplier: Float!

  "How long override should last (minutes, null = until cleared)"
  durationMinutes: Int

  "Reason for override (optional)"
  reason: String
}

"Response for kitchen capacity config operations"
type KitchenCapacityConfigResponse {
  "Whether the operation succeeded"
  success: Boolean!

  "Optional message"
  message: String

  "The configuration"
  config: KitchenCapacityConfig
}

"Response for kitchen load override operations"
type KitchenLoadOverrideResponse {
  "Whether the operation succeeded"
  success: Boolean!

  "Optional message"
  message: String

  "Updated kitchen capacity configuration"
  config: KitchenCapacityConfig

  "Current load status"
  loadStatus: KitchenLoadStatus
}

"Response for kitchen load snapshot operations"
type KitchenLoadSnapshotResponse {
  "Whether the operation succeeded"
  success: Boolean!

  "Optional message"
  message: String

  "Captured snapshots"
  snapshots: [KitchenLoadSnapshot!]
}

"""
Represents a legal document served by the platform.
Legal documents are global (not tenant-specific) and publicly accessible.
"""
type LegalDocument {
  "Unique identifier."
  id: ID!

  "URL-friendly identifier (e.g., 'privacy-policy')."
  slug: String!

  "Human-readable title (e.g., 'Privacy & Security Policy')."
  title: String!

  "Short excerpt for list views (e.g., settings screens)."
  summary: String

  "Classification key (e.g., 'privacy-policy', 'terms-of-service')."
  documentType: String!

  "Semantic version (e.g., '1.0.0')."
  version: String!

  "Language code (e.g., 'en', 'fr')."
  locale: String!

  "Full document content in markdown format."
  content: String!

  "When this version becomes legally effective."
  effectiveAt: DateTime!

  "When this version was published."
  publishedAt: DateTime
}

"Represents a single restaurant or business location in the SSP ecosystem."
type SSPLocation {
  "Unique identifier of the location (required)."
  id: ID!

  "Name of the location (required)."
  name: String!

  "Street address of the location."
  address: String

  "City where the location is situated."
  city: String

  "State or province of the location."
  state: String

  "Postal or ZIP code."
  postal_code: String

  "Primary phone number for the location."
  phone_number: String

  "URL to the location's logo image."
  logo_url: String

  "Country code (ISO-3166)."
  country: String

  "Timezone of the location (IANA format, e.g., 'America/Toronto')."
  timezone: String

  "Organization ID that owns this location."
  organization_id: ID!

  "Organization that owns this location."
  organization: SSPOrganization

  "Layout definition for the location (tables, floors, etc.)."
  layout: LocationLayout

  "Associated location collection ID if part of a chain."
  s_s_p_loc_collection_id: Int

  "Associated profile with additional metadata."
  sspProfile: SSPProfile

  "List of tax rules applied to this location."
  taxRules: [SSPTaxRule!]!

  "Current status of the location (e.g., ACTIVE, INACTIVE)."
  status: SSPLocationStatus
}

"Represents a collection of locations (e.g., a restaurant chain)."
type SSPLocCollection {
  "Unique identifier of the collection (required)."
  id: ID!

  "Name of the collection (required)."
  name: String!

  "Logo representing the collection."
  logo: String

  "Brief description of the collection."
  description: String

  "List of locations associated with this collection."
  locations: [SSPLocation!]!

  "Status of the collection (e.g., ACTIVE, INACTIVE)."
  status: SSPLocCollectionStatus
}

"Lightweight representation of a location collection (without relations)."
type SSPLocationCollection {
  "Unique identifier of the collection (required)."
  id: ID!

  "Name of the collection (required)."
  name: String!

  "Logo representing the collection."
  logo: String

  "Brief description of the collection."
  description: String
}

"Represents the floor and table layout of a location."
type LocationLayout {
  "Unique identifier of the layout (required)."
  id: ID!

  "Identifier of the associated location (required)."
  location_id: ID!

  "Serialized JSON floor layout definition (required)."
  floor_layout: JSON!

  "Number of floors in the location (required)."
  number_of_floors: Int!

  "List of table layouts for this location (required)."
  tableLayouts: [TableLayout!]!
}

"Represents configuration settings for a specific location."
type SSPConfigurationLocation {
  "Unique identifier of the configuration (required)."
  id: ID!

  "Associated location ID (required)."
  location_id: ID!

  "Location that this configuration belongs to."
  location: SSPLocation

  "Currency code used by the location (e.g., 'USD')."
  currency: String!

  "Timezone of the location (IANA format, e.g., 'America/Toronto')."
  timezone: String!

  "Default percentage service charge applied."
  default_service_charge: Float

  "Minimum party size for applying service charge."
  service_charge_min_party_size: Int

  "Description for the service charge on checks."
  service_charge_description: String

  "Whether the location uses a reservation system (required)."
  reservation_system: Boolean!

  "Whether prices include tax (required)."
  tax_included: Boolean!

  "Default tip percentage applied."
  default_tip: Float

  "Whether to calculate tips after tax is applied."
  calculate_tip_after_tax: Boolean

  "First suggested tip percentage."
  tip_tier1: Float

  "Second suggested tip percentage."
  tip_tier2: Float

  "Third suggested tip percentage."
  tip_tier3: Float

  "Timestamp when the configuration was created (required)."
  created_at: DateTime!

  "Timestamp when the configuration was last updated (required)."
  updated_at: DateTime!
}

"""
Payload returned when onboarding a new organization, 
including the organization, its primary location, and optional collection.
"""
type OnboardOrganizationPayload {
  "Newly created organization (required)."
  organization: SSPOrganization!

  "Primary location created during onboarding (required)."
  location: SSPLocation!

  "Optional collection if the organization spans multiple locations."
  collection: SSPLocCollection
}

"""
Represents an organization (restaurant group, chain, or single restaurant)
within the SSP ecosystem.
"""
type SSPOrganization {
  "Unique numeric identifier of the organization (required)."
  id: ID!

  "Globally unique UUID identifier of the organization (required)."
  uuid: ID!

  "Name of the organization (required)."
  name: String!

  "Whether the organization is currently active (required)."
  is_active: Boolean!

  "Collections (restaurant groups or chains) that belong to this organization."
  collections: [SSPLocCollection!]

  "Locations (individual restaurants) that belong to this organization."
  locations: [SSPLocation!]

  "Users (staff, managers, admins) that belong to this organization."
  users: [SSPUser!]

  "Total count of locations belonging to this organization."
  locationsCount: Int!

  "Total count of users belonging to this organization."
  usersCount: Int!

  subscription_plan: String @deprecated(reason: "Use 'plan' field instead")
  plan: String
  trialStartedAt: DateTime
  trialEndsAt: DateTime
  trialConsumed: Boolean!
  stripeCustomerId: String
  stripeSubscriptionStatus: String
  hasBillingIssues: Boolean!
  limits: OrganizationLimits!
  isOnTrial: Boolean!
  trialDaysRemaining: Int
  trialExpired: Boolean!
  effectivePlan: String!
  subscriptionStatusDisplay: String!
}

type RegisterWithOrganizationPayload {
  "Authentication token for the newly registered user (required)."
  token: String!

  "The newly registered user (required)."
  user: SSPUser!

  "The organization the user belongs to (required)."
  organization: SSPOrganization!

  "The Collection the user is associated with."
  collection: SSPLocCollection

  "The Location the user is associated with."
  location: SSPLocation
}

"Represents a menu within a location or collection."
type SSPMenu {
  "Unique identifier of the menu (required)."
  id: ID!

  "Display ID for frontend references (optional)."
  display_id: Int

  "Name of the menu (required)."
  name: String!

  "Description of the menu."
  description: String

  "Image URL representing the menu."
  image: String

  "Whether the menu is currently active."
  is_active: Boolean

  "Type of menu (e.g., STANDARD, SEASONAL, SPECIAL)."
  menu_type: String

  "Availability schedule (JSON format)."
  availability: JSON

  "Price range descriptor for the menu (e.g., \"$$\")."
  price_range: String

  "Special offers associated with the menu (JSON)."
  special_offers: JSON

  "Dietary options highlighted in the menu (JSON)."
  dietary_options: JSON

  "Allergen information for menu items (JSON)."
  allergen_information: JSON

  "Nutritional information (JSON)."
  nutritional_information: JSON

  "SEO title for search engine optimization."
  seo_title: String

  "SEO description for search engine optimization."
  seo_description: String

  "Translations for multilingual support (JSON)."
  translations: JSON

  "Version number for tracking updates."
  version: Int

  "Associated location ID."
  location_id: Int

  "Associated location collection ID (if part of a chain)."
  location_coll_id: Int

  "Type of schedule activation for this menu."
  schedule_type: MenuScheduleType

  "Start date for date-range scheduling."
  start_date: Date

  "End date for date-range scheduling."
  end_date: Date

  "Daily start time (HH:MM:SS format)."
  start_time: String

  "Daily end time (HH:MM:SS format)."
  end_time: String

  "Array of active days for recurring schedules."
  active_days: [DayOfWeek!]

  "Special dates with custom availability rules."
  special_dates: [MenuSpecialDate!]

  "Priority for overlapping menu schedules (higher = higher priority)."
  priority: Int

  "Whether to automatically activate/deactivate based on schedule."
  auto_activate: Boolean

  "Timezone for this menu's schedule (overrides location timezone)."
  schedule_timezone: String

  "Check if menu is currently active based on schedule."
  is_currently_active: Boolean

  "Get availability schedule for the next N days."
  availability_schedule(days: Int = 7): [MenuDaySchedule!]

  "Number of items in this menu."
  itemsCount: Int
}

"Menu schedule type enum"
enum MenuScheduleType {
  "Menu is always available"
  ALWAYS

  "Menu is available within a specific date range"
  DATE_RANGE

  "Menu repeats on specific days/times each week"
  RECURRING

  "Menu is manually activated/deactivated only"
  MANUAL
}

"Day of week enum"
enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

"Special date configuration for a menu"
type MenuSpecialDate {
  "Date in YYYY-MM-DD format"
  date: String!

  "Whether menu is available on this date"
  is_available: Boolean!

  "Custom start time for this date"
  start_time: String

  "Custom end time for this date"
  end_time: String

  "Optional note about this special date"
  note: String
}

"Menu availability for a single day"
type MenuDaySchedule {
  "Date in YYYY-MM-DD format"
  date: String!

  "Day name (e.g., Monday)"
  day_name: String!

  "Whether menu is available on this day"
  is_available: Boolean!

  "Time slots when menu is available"
  time_slots: [TimeSlot!]!
}

"Time slot for menu availability"
type TimeSlot {
  "Start time in HH:MM:SS format"
  start: String!

  "End time in HH:MM:SS format"
  end: String!
}

"Represents a paginated response for menus."
type PaginatedSSPMenu {
  "List of menus in the current page (required)."
  data: [SSPMenu!]!

  "Current page number (required)."
  currentPage: Int!

  "Total number of pages (required)."
  totalPages: Int!

  "Total number of records (required)."
  totalCount: Int!
}

"Represents a menu category (e.g., Appetizers, Drinks)."
type SSPMenuCategory {
  "Unique identifier of the category (required)."
  id: ID!

  "Name of the category (required)."
  name: String!

  "Image representing the category."
  image: String

  "Description of the category."
  description: String

  "Whether the category is currently active."
  is_active: Boolean

  "Sorting order for categories."
  sort_order: Int

  "Category type (e.g., FOOD, BEVERAGE)."
  cat_type: CategoryTypes

  "Parent category ID (for hierarchical menus)."
  parent_id: Int

  "SEO title for search optimization."
  seo_title: String

  "SEO description for search optimization."
  seo_description: String

  "Translations for multilingual support (JSON)."
  translations: JSON

  "List of menu items in this category for a given location."
  menuItems(location_id: ID): [SSPMenuItem]

  "Tax rules (deprecated, use locationTaxRules instead)."
  taxRules: [SSPTaxRule!]! @deprecated(reason: "Use locationTaxRules instead")

  "Location-specific tax rules applied to this category."
  locationTaxRules(location_id: ID): [SSPTaxRule!]

  "Version number for tracking updates."
  version: Int
}

"Represents a paginated response for menu categories."
type PaginatedSSPMenuCategory {
  "List of categories in the current page (required)."
  data: [SSPMenuCategory!]!

  "Current page number (required)."
  currentPage: Int!

  "Total number of pages (required)."
  totalPages: Int!

  "Total number of records (required)."
  totalCount: Int!
}

"Represents a menu item (dish, beverage, etc.)."
type SSPMenuItem {
  "Unique identifier of the menu item (required)."
  id: ID!

  "Display ID for frontend references (optional)."
  display_id: Int

  "Name of the item (required)."
  name: String!

  "Description of the item."
  description: String

  "Image URL of the item."
  image: String

  "Price of the item."
  price: Float

  "Whether the item is active in the system."
  is_active: Boolean

  "Whether the item is available for ordering."
  is_available: Boolean

  "Availability schedule (JSON)."
  availability: JSON

  "Estimated preparation time in minutes."
  preparation_time: Int

  "Discount rules applied to the item (JSON)."
  discounts: JSON

  "Allergen information (JSON)."
  allergens: JSON

  "Rewards configuration (JSON)."
  rewards: JSON

  "Loyalty points required to redeem the item (JSON)."
  loyalty_points: JSON

  "Loyalty points earned per purchase (JSON)."
  loyalty_points_earned: JSON

  "Customization options for the item (JSON)."
  customization_options: JSON

  "Other selectable options (JSON)."
  options: JSON

  "Available add-ons (JSON)."
  addons: JSON

  "Special instructions for the item."
  special_instructions: String

  "Whether the item is vegan-friendly."
  vegan: Boolean

  "Whether the item is vegetarian-friendly."
  vegetarian: Boolean

  "Whether the item is gluten-free."
  gluten_free: Boolean

  "Whether the item is certified halal."
  halal: Boolean

  "Whether the item is certified kosher."
  kosher: Boolean

  "Whether the item is organic."
  organic: Boolean

  "Whether the item is marked as spicy."
  spicy: Boolean

  "Whether the item is newly added to the menu."
  new: Boolean

  "Whether the item is popular among customers."
  popular: Boolean

  "Whether the item is recommended by the restaurant."
  recommended: Boolean

  "Ingredients of the item (JSON)."
  ingredients: JSON

  "Tags or keywords for filtering (JSON)."
  tags: JSON

  "Nutritional information (JSON)."
  nutritional_information: JSON

  "Video link for preparation or marketing."
  video: String

  "Translations for multilingual support (JSON)."
  translations: JSON

  "Modifier groups applied to the item (JSON)."
  modifiers: JSON

  "SEO title for search engine optimization."
  seo_title: String

  "SEO description for search engine optimization."
  seo_description: String

  "Version number for tracking updates."
  version: Int

  "Associated location ID."
  location_id: Int

  "Associated location collection ID (if part of a chain)."
  location_coll_id: Int

  "Legacy single menu relation (deprecated)."
  menu_id: Int @deprecated(reason: "Use menus field instead")

  "Legacy single category relation (deprecated)."
  category_id: Int @deprecated(reason: "Use categories field instead")

  "Menus this item belongs to."
  menus: [SSPMenu!]!

  "Categories this item belongs to."
  categories: [SSPMenuCategory!]!

  "Tax rules applied to this menu item."
  taxRules: [SSPTaxRule!]!

  "Tax preview calculation for this item (per location and quantity)."
  taxPreview(location_id: ID, quantity: Int = 1): TaxPreviewSummary

  "Reusable customization templates associated with this item."
  customizationTemplates: [SSPCustomizationTemplate!]!

  "Only active customization templates for this item."
  activeCustomizationTemplates: [SSPCustomizationTemplate!]!
}

"Represents a paginated response for menu items."
type SSPMenuItemPagination {
  "List of menu items in the current page (required)."
  items: [SSPMenuItem!]!

  "Total number of menu items (required)."
  total: Int!

  "Current page number (required)."
  page: Int!

  "Number of items per page (required)."
  pageSize: Int!
}

"Response type for an item-related mutation."
type ItemResponse {
  "Whether the operation succeeded (required)."
  success: Boolean!

  "Optional response message."
  message: String

  "Menu item returned in the response (if any)."
  item: SSPMenuItem
}

"Payload returned after updating item list statuses."
type UpdateItemListStatusPayload {
  "Whether the update succeeded (required)."
  success: Boolean!

  "Optional response message."
  message: String

  "List of updated order list items."
  updatedItems: [SSPTableOrderListItem]
}

"Represents an item sale aggregation."
type ItemSale {
  "Name of the item (required)."
  name: String!

  "Total quantity sold (required)."
  total_quantity: Int!

  "Total revenue generated (required)."
  total_revenue: Float!
}

"Represents a line in an item sales report."
type ItemSalesReport {
  "POS identifier for the item (required)."
  posId: String!

  "Name of the item (required)."
  name: String!

  "Price of the item (required)."
  price: Float!

  "Quantity sold (required)."
  quantity: Int!

  "Gross sales amount (nullable)."
  grossSales: Float

  "Discount amount applied (nullable)."
  discountAmount: Float

  "Net sales amount (nullable)."
  netSales: Float

  "Category label of the item (required)."
  categoryLabel: String!
}

"Response type for menu-related data requests."
type SSPMenuDataResponse {
  "Whether the operation succeeded (required)."
  success: Boolean!

  "Optional response message."
  message: String

  "List of menus returned (optional)."
  menus: [SSPMenu!]

  "Number of items added (for extend operations)."
  addedCount: Int

  "Names of items skipped due to duplicates."
  skippedItems: [String!]
}

"Response type for selected items (e.g., multi-select actions)."
type SelectedItemsResponse {
  "Whether the operation succeeded (required)."
  success: Boolean!
}

"Status of an NFC tag registered to a table."
enum NFCTagStatus {
  "Tag is active and can be used for table resolution."
  ACTIVE

  "Tag has been reported lost."
  LOST

  "Tag is physically damaged and non-functional."
  DAMAGED

  "Tag has been manually deactivated."
  DEACTIVATED
}

"""
Behavior when an NFC tag is scanned but no active order exists for the table.
Configured per-location to match the restaurant's service style.
"""
enum NFCNoOrderBehavior {
  "Display a generic 'no active order' message."
  SHOW_ERROR

  "Prompt guest to request server to start an order."
  NOTIFY_STAFF

  "Navigate to menu view for browsing without order context."
  REDIRECT_MENU

  "Automatically create order for self-seating restaurants. Frontend should call createTableOrderFromNFC mutation."
  AUTO_CREATE_ORDER
}

"""
Status of an NFC tag resolution attempt.
Used for logging and analytics.
"""
enum NFCResolutionStatus {
  "Successfully resolved to an active order."
  RESOLVED

  "Table found but no active order exists."
  NO_ACTIVE_ORDER

  "Order was automatically created for self-seating restaurant."
  ORDER_AUTO_CREATED

  "NFC tag is not active (lost, damaged, deactivated)."
  TAG_INACTIVE

  "Table not found for given identifier."
  TABLE_NOT_FOUND

  "Location not found for given slug."
  LOCATION_NOT_FOUND

  "Organization not found for given slug."
  ORG_NOT_FOUND

  "DNA tag UID not found in database."
  TAG_NOT_FOUND

  "DNA tag MAC signature verification failed."
  INVALID_MAC

  "DNA tag counter indicates replay attack (counter not higher than last seen)."
  REPLAY_ATTACK

  "General error during resolution."
  ERROR
}

"Type of NFC tag technology used."
enum NFCTagType {
  "Legacy static URL tag (organization/location/table encoded in URL path)."
  STATIC

  "NTAG 424 DNA tag with Secure Dynamic Messaging (UID/counter/MAC in URL)."
  DNA
}

"""
Represents an NFC tag registered to a table.
NFC tags are physically attached to tables and contain a URL
that resolves to the active order for that table.

Supports two tag types:
- STATIC: Legacy tags with org/location/table in URL path
- DNA: NTAG 424 DNA tags with cryptographic signatures (uid/counter/mac in URL)
"""
type NFCTag {
  "Unique identifier of the NFC tag."
  id: ID!

  "Hardware NFC serial number (e.g., '04:AB:CD:12:34:56:80' or '040F67BA851B90' for DNA)."
  uid: String!

  "Type of NFC tag: STATIC (legacy) or DNA (NTAG 424 DNA with SDM)."
  tagType: NFCTagType!

  "The table this NFC tag is assigned to."
  table: SSPTable!

  "The location where this NFC tag is registered."
  location: SSPLocation!

  "URL written to the NFC tag."
  writtenUrl: String

  "Current status of the tag."
  status: NFCTagStatus!

  "Friendly name for the tag (e.g., 'Table 7 - window side')."
  label: String

  "When the tag was registered."
  registeredAt: DateTime!

  "User who registered the tag."
  registeredBy: SSPUser

  "Admin notes about the tag."
  notes: String

  "Last time the tag was scanned."
  lastScannedAt: DateTime

  "Last verified read counter for DNA tags (for anti-replay protection)."
  lastReadCounter: Int

  "When the tag record was created."
  createdAt: DateTime!

  "When the tag record was last updated."
  updatedAt: DateTime!
}

"Audit log entry for an NFC tag scan."
type NFCTagScan {
  "Unique identifier of the scan record."
  id: ID!

  "The NFC tag that was scanned (if found)."
  nfcTag: NFCTag

  "The location where the scan occurred."
  location: SSPLocation!

  "When the scan occurred."
  scannedAt: DateTime!

  "The order that was resolved, if any."
  resolvedOrder: SSPTableOrder

  "Result of the resolution attempt."
  resolutionStatus: NFCResolutionStatus!

  "Client IP address."
  ipAddress: String

  "Client user agent string."
  userAgent: String
}

"""
Result of an NFC 424 DNA tag resolution attempt.
Returned by the public resolveNFCTagDNA query.
This endpoint validates the cryptographic signature from NTAG 424 DNA tags.
"""
type NFCDNAResolutionResult {
  "Whether the resolution was successful."
  success: Boolean!

  "Resolution status code for logging and frontend handling."
  status: NFCResolutionStatus!

  "Whether an active order was found for the table."
  hasActiveOrder: Boolean!

  """
  The unique order ID for guest authentication.
  Use this with the AuthenticateGuestOrder mutation.
  """
  uniqueOrderId: String

  "The database ID of the resolved order."
  orderId: ID

  "The database ID of the table."
  tableId: ID

  "Display name of the table (e.g., 'Patio A1')."
  tableName: String

  "The table's local_id."
  tableLocalId: Int

  "The database ID of the location."
  locationId: ID

  "Display name of the location."
  locationName: String

  "Organization UUID."
  organizationUuid: String

  "Organization name."
  organizationName: String

  "What the frontend should do if no active order exists."
  nfcNoOrderBehavior: NFCNoOrderBehavior

  "First name of the assigned waiter (when order auto-created)."
  waiterFirstName: String

  "Human-readable message for display to guests."
  message: String
}

"""
Result of an NFC tag resolution attempt.
Returned by the public resolveNFCTag query.
"""
type NFCResolutionResult {
  "Whether the resolution was successful."
  success: Boolean!

  "Whether an active order was found for the table."
  hasActiveOrder: Boolean!

  """
  The unique order ID for guest authentication.
  Use this with the AuthenticateGuestOrder mutation.
  """
  uniqueOrderId: String

  "The database ID of the resolved order."
  orderId: ID

  "The database ID of the table."
  tableId: ID

  "Display name of the table (e.g., 'Patio A1')."
  tableName: String

  "The table's local_id that was in the URL."
  tableLocalId: Int

  "The database ID of the location."
  locationId: ID

  "Display name of the location."
  locationName: String

  "What the frontend should do if no active order exists."
  nfcNoOrderBehavior: NFCNoOrderBehavior

  "First name of the assigned waiter (when order auto-created)."
  waiterFirstName: String

  "Human-readable message for display to guests."
  message: String
}

"Input for registering a new NFC tag to a table."
input RegisterNFCTagInput {
  "Hardware NFC serial number (e.g., '04:AB:CD:12:34:56:80' for static, '040F67BA851B90' for DNA)."
  uid: String!

  "The ID of the table to assign the tag to."
  tableId: ID!

  "Type of NFC tag: STATIC (legacy, default) or DNA (NTAG 424 DNA with SDM)."
  tagType: NFCTagType

  """
  SDM File Read Key (Key 2) as 32-character hex string.
  Required for DNA tags, ignored for STATIC tags.
  This key is used to verify the CMAC signature from the tag.
  """
  sdmKey: String

  "Optional friendly name for the tag."
  label: String

  "Optional admin notes about the tag."
  notes: String
}

"Input for updating an NFC tag's status."
input UpdateNFCTagStatusInput {
  "The ID of the NFC tag to update."
  id: ID!

  "The new status for the tag."
  status: NFCTagStatus!
}

"Input for reassigning an NFC tag to a different table."
input ReassignNFCTagInput {
  "The ID of the NFC tag to reassign."
  id: ID!

  "The ID of the new table to assign the tag to."
  newTableId: ID!
}

"""
Input for scanning and verifying an NTAG 424 DNA tag from the Flutter app.
Staff scans the tag URL parameters to verify the tag before associating with a table.
"""
input ScanNFCTagDNAInput {
  "Tag UID as 14-character hex string (e.g., '040F67BA851B90')."
  uid: String!

  "Read counter as 6-character hex string (e.g., '000006')."
  ctr: String!

  "CMAC signature as 16-character hex string."
  mac: String!

  """
  Location ID where this tag will be used.
  Required to look up the location's SDM key for verification.
  """
  locationId: ID!
}

"Result of scanning and verifying an NTAG 424 DNA tag."
type ScanNFCTagDNAResult {
  "Whether the tag verification was successful."
  success: Boolean!

  "Error message if verification failed."
  message: String

  "The verified tag UID (normalized to uppercase, no separators)."
  uid: String

  "The read counter value."
  counter: Int

  "Whether this tag is already registered in the system."
  isRegistered: Boolean

  "If registered, the existing tag record."
  existingTag: NFCTag

  "If registered, whether it's already associated with a table."
  hasTableAssociation: Boolean
}

"Input for associating a verified DNA tag with a table."
input AssociateNFCTagDNAInput {
  "Tag UID as returned from scanNFCTagDNA."
  uid: String!

  "The ID of the table to assign the tag to."
  tableId: ID!

  "Optional friendly name for the tag."
  label: String

  "Optional admin notes about the tag."
  notes: String
}

"""
Input for claiming an NFC tag from inventory and assigning it to a table.
The tag must exist in the inventory and the table must belong to the user's organization.
"""
input ClaimNFCTagInput {
  "Tag UID from scanned tag (14 hex chars for DNA, e.g., '040F67BA851B90')."
  uid: String!

  "The ID of the table to assign the tag to."
  tableId: ID!

  "Optional friendly name for the tag."
  label: String
}

"""
Represents an unassigned NFC tag in inventory.
Tags are imported from GoToTags CSV and stored here until claimed
by an organization and assigned to a table.
"""
type NFCTagInventory {
  "Unique identifier of the inventory tag."
  id: ID!

  "Hardware NFC serial number (e.g., '040F67BA851B90')."
  uid: String!

  "Type of NFC tag: STATIC or DNA."
  tagType: String!

  "Chip type (e.g., 'NTAG424')."
  chipType: String

  "URL written to the NFC tag."
  writtenUrl: String

  "Whether the tag is write-locked."
  isLocked: Boolean!

  "Import notes."
  notes: String

  "When the tag was imported."
  importedAt: DateTime!

  "Supplier name (e.g., 'GoToTags')."
  supplier: String

  "Tag model (e.g., 'NTAG424 DNA TT')."
  model: String

  "Tag color (e.g., 'White')."
  color: String

  "Tag size (e.g., '30mm')."
  size: String

  "Unit cost."
  cost: Float

  "Purchase order reference."
  orderNumber: String

  "When the tag record was created."
  createdAt: DateTime!

  "When the tag record was last updated."
  updatedAt: DateTime!
}

"""
Result of an NFC-triggered order creation attempt.
Returned by the public createTableOrderFromNFC mutation.
"""
type NFCOrderCreationResult {
  "Whether the order creation was successful."
  success: Boolean!

  """
  The unique order ID for guest authentication.
  Use this with the AuthenticateGuestOrder mutation.
  """
  uniqueOrderId: String

  "The database ID of the created/existing order."
  orderId: ID

  "The database ID of the table."
  tableId: ID

  "Display name of the table (e.g., 'Patio A1')."
  tableName: String

  "The table's local_id that was in the URL."
  tableLocalId: Int

  "The database ID of the location."
  locationId: ID

  "Display name of the location."
  locationName: String

  "First name of the assigned waiter for guest UX (e.g., 'Maria')."
  waiterFirstName: String

  "Human-readable message for display to guests."
  message: String
}

"""
Result of a direct web order creation attempt.
Returned by the public createDirectWebOrder mutation.
"""
type DirectWebOrderResult {
  "Whether the order creation was successful."
  success: Boolean!

  """
  The unique order ID for guest authentication.
  Use this with the AuthenticateGuestOrder mutation.
  """
  uniqueOrderId: String

  "The database ID of the created order."
  orderId: ID

  "The database ID of the location."
  locationId: ID

  "Display name of the location."
  locationName: String

  "Order type that was set (TAKEAWAY or DELIVERY)."
  orderType: TableOrderType

  "Human-readable message for display to guests."
  message: String
}

"Represents a customization applied to an order or order item."
type SSPCustomization {
  "Unique identifier of the customization (required)."
  id: ID!

  "Name of the customization (required)."
  name: String!

  "Price adjustment for the customization (required)."
  price: Float!

  "Optional description of the customization."
  description: String

  "Order item this customization belongs to."
  item: SSPTableOrderItem

  "Table order this customization is linked to."
  order: SSPTableOrder
}

"""
Represents an item displayed in an order list view.
Used for lightweight table order summaries.
"""
type SSPTableOrderListItem {
  "Name of the menu item (required)."
  name: String!

  "Price of the item (required)."
  price: Float!

  "Internal item identifier (required)."
  iid: Int!

  "Point-of-sale identifier of the item (required)."
  pos_id: String!

  "Price formatted as a string (required)."
  priceStr: String!

  "Total price for this line item (required)."
  total: Float!

  "Formatted total string (required)."
  totalStr: String!

  "Current status of the order item (required)."
  status: TableOrderItemStatus!

  "Numeric category value (used for reporting)."
  categoryValue: Int!

  "Category label (e.g., 'Appetizers', 'Drinks')."
  categoryLabel: String!

  "Type of discount applied (PERCENTAGE or AMOUNT). Null if no discount."
  discountType: DiscountType

  "Original discount value (e.g., 10 for 10% or $10). Null if no discount."
  discountValue: Float

  "Calculated discount amount in currency. Null if no discount."
  discountAmount: Float

  "Reason for the discount (optional)."
  discountReason: String

  "Whether this item has a discount applied."
  hasDiscount: Boolean!

  "List of applied customizations."
  customizations: [SSPCustomization!]!

  "List of valid transitions for the item's status."
  validTransitions: [TableOrderItemStatus!]!

  "Base preparation time from menu item (minutes)."
  basePrepTime: Int

  "Adjusted preparation time based on kitchen capacity (minutes)."
  adjustedPrepTime: Int

  "Capacity multiplier applied when item was added."
  capacityMultiplier: Float

  "Kitchen load level when item was created."
  kitchenLoadLevel: KitchenLoadLevel

  "Estimated time when item will be ready."
  estimatedReadyAt: DateTime

  "When cooking actually started."
  cookingStartedAt: DateTime

  "When item was marked as prepared."
  preparedAt: DateTime

  "Timestamp when the item was created."
  created_at: DateTime

  "Timestamp when the item was last updated."
  updated_at: DateTime
}

"Represents a detailed table order item (grouped by quantity)."
type SSPTableOrderItem {
  "Unique identifier of the order item (required)."
  id: ID!

  "Associated table order ID (required)."
  s_s_p_table_order_id: Int!

  "Name of the menu item (required)."
  name: String!

  "Price of a single unit (required)."
  price: Float!

  "Quantity ordered (required)."
  quantity: Int!

  "Point-of-sale identifier of the item (required)."
  pos_id: String!

  "Price formatted as a string (required)."
  priceStr: String!

  "Total for this item (required)."
  total: Float!

  "Total formatted as a string (required)."
  totalStr: String!

  "Current status of the item (required)."
  status: String!

  "Numeric category value."
  categoryValue: Int!

  "Category label."
  categoryLabel: String!

  "Individual items in this group (each with their own discount info)."
  listItems: [SSPTableOrderListItem!]!

  "List of applied customizations."
  customizations: [SSPCustomization!]!

  "Timestamp when the item was created."
  created_at: DateTime

  "Timestamp when the item was last updated."
  updated_at: DateTime
}

"Represents a full table order."
type SSPTableOrder {
  "Globally unique identifier for the order (required)."
  unique_orderid: ID!

  "Internal database ID for the order (required)."
  id: Int!

  "Local (per-location) incremental ID."
  local_id: Int

  "External order ID string (required)."
  order_id: String!

  "Table number associated with the order (required)."
  table_number: String!

  "Name of the server assigned to this order (required)."
  server_name: String!

  "Size of the party (number of guests) (required)."
  party_size: Int!

  "Restaurant name associated with the order (required)."
  restaurant_name: String!

  "Subtotal before taxes and tips."
  sub_total: Float

  "Total including taxes and tips (required)."
  total: Float!

  "Associated location ID (required)."
  s_s_p_location_id: Int!

  "Serialized tax information."
  taxes_json: JSON

  "Serialized session data (e.g., guest session info)."
  session_json_data: JSON

  "Formatted total string."
  totalStr: String

  "Formatted subtotal string."
  subTotalStr: String

  "Remaining balance not yet paid."
  remaining_balance: Float

  "Formatted remaining balance string."
  remaining_balance_str: String

  "List of simplified order items."
  itemsList: [SSPTableOrderListItem!]!

  "Order status string."
  order_status: String!

  "List of customizations at the order level."
  customizations: [SSPCustomization!]!

  "Special instructions for the kitchen (JSON)."
  kitchen_instructions: JSON

  "Type of order (e.g., DINE_IN, TAKEOUT)."
  order_type: String!

  "Order priority string (e.g., NORMAL, RUSH)."
  priority: String!

  "Timestamp when the order was submitted."
  order_submitted_at: DateTime

  "Associated table for the order."
  table: SSPTable

  "Customer information for delivery/takeout orders (null for anonymous dine-in)."
  customer: SSPOrderCustomer

  "Timestamp when the order was last modified."
  modified_at: DateTime

  "Notes regarding modifications."
  modification_notes: String

  "Preparation time in minutes."
  prep_time: Int

  "Threshold time for triggering alerts."
  alert_threshold: Int

  "Timestamp when the order was bumped from the KDS."
  bumped_at: DateTime

  "Visual cue for alerts (e.g., color code)."
  visual_cue: String

  "Audio alert configuration."
  audio_alert: String

  """
  Timestamp when the order was created.
  Returned in the location's timezone with offset, e.g., `2024-01-15T14:30:00-05:00`.
  """
  created_at: DateTime

  """
  Timestamp when the order was last updated.
  Returned in the location's timezone with offset, e.g., `2024-01-15T14:30:00-05:00`.
  """
  updated_at: DateTime

  "Legacy QR code string (deprecated)."
  qrCode: String @deprecated(reason: "Use qrcode_url instead")

  "Permanent QR code URL for the order."
  qrcode_url: String

  "Sale transactions associated with this order."
  saleTransactions: [SSPSaleTransaction!]!

  "Service charge percentage applied (based on party size threshold)."
  service_charge_percentage: Float

  "Calculated service charge amount."
  service_charge_amount: Float

  "Description of the service charge (e.g., 'Gratuity for parties of 6+')."
  service_charge_description: String

  "Order-level discount percentage (e.g., 10 for 10% off)."
  discount_percentage: Float

  "Calculated order-level discount amount in currency."
  discount_amount: Float

  "Description/reason for the order-level discount."
  discount_description: String

  "Paginated list of detailed order items."
  items(
    "Limits number of fetched items."
    first: Int!

    "The offset from which items are returned."
    page: Int
  ): SSPTableOrderItemPaginator!
}

"Represents a sale transaction record (payment, refund, etc.)."
type SSPSaleTransaction {
  "Unique identifier for the transaction (required)."
  id: ID!

  "Total amount of the transaction (required)."
  total_amount: Float

  "Payment method used (e.g., CASH, CARD, CHECK)."
  payment_method: String

  "Status of the transaction (e.g., completed, pending, failed)."
  status: String!

  "Type of transaction (SALE, REFUND, VOID)."
  transaction_type: String

  "External transaction ID (e.g., Stripe PaymentIntent ID)."
  transaction_id: String

  "Tip amount included in this transaction."
  tip_amount: Float

  "Discount amount applied."
  discount_amount: Float

  "Tax amount charged."
  tax_amount: Float

  "Currency code (e.g., USD, CAD)."
  currency: String

  "Name of the server who processed the transaction."
  server_name: String

  "ID of the employee who processed the transaction."
  employee_id: ID

  "Customer name (deprecated, use customer relation)."
  customer_name: String

  "Customer email (deprecated, use customer relation)."
  customer_email: String

  "Reason for void (if transaction was voided)."
  void_reason: String

  "Reason for refund (if transaction was refunded)."
  refund_reason: String

  "Timestamp when the transaction occurred."
  created_at: DateTime

  "Stripe PaymentIntent ID (for card payments processed via Stripe)."
  stripe_payment_intent_id: String

  "Parent transaction ID (links refunds to their original sale)."
  parent_transaction_id: ID

  "Parent transaction (the original sale for a refund)."
  parentTransaction: SSPSaleTransaction

  "Child transactions (refunds for this sale)."
  refunds: [SSPSaleTransaction!]!

  "Associated table order."
  tableOrder: SSPTableOrder
}

"Response type for discount operations."
type ApplyDiscountResponse {
  "Whether the operation was successful."
  success: Boolean!

  "Updated order after discount application."
  order: SSPTableOrder

  "Updated item (for item-level discounts)."
  item: SSPTableOrderListItem

  "Type of discount applied."
  discountType: DiscountType

  "Value of the discount (percentage or amount)."
  discountValue: Float

  "Calculated discount amount in currency."
  discountAmount: Float

  "Previous discount amount (for remove operations)."
  previousDiscount: Float

  "Human-readable message about the operation."
  message: String
}

"Represents a paginated response for orders."
type OrderResult {
  "List of table orders (required)."
  data: [SSPTableOrder!]!

  "Total number of orders (required)."
  total: Int!

  "Current page number (required)."
  page: Int!

  "Page size (required)."
  pageSize: Int!
}

"Response for creating multiple orders in bulk."
type CreateBulkOrderResponse {
  "Overall status of the operation (required)."
  status: String!

  "List of results for each attempted order creation."
  results: [OrderResultBulk!]!
}

"Represents the result of one order in a bulk operation."
type OrderResultBulk {
  "Status of this order creation attempt (required)."
  status: String!

  "Created order ID (if successful)."
  orderID: ID

  "Message describing the outcome."
  message: String
}

"Response containing active orders for a specific table."
type ActiveOrdersForTable {
  "Unique identifier of the table (required)."
  tableId: ID!

  "List of active orders for the table (required)."
  orders: [SSPTableOrder!]!
}

type AddItemsToOrderResponse {
  "Status of the operation (required)."
  status: String!
}

type CreateOrderResponse {
  "Status of the operation (required)."
  status: String!

  "ID of the created order (required)."
  orderId: String!
}

type RemoveItemsFromOrderResponse {
  "Whether the removal succeeded (required)."
  success: Boolean!
}

type UpdateOrderItemQuantityResponse {
  "Whether the update succeeded (required)."
  success: Boolean!
}

type BatchUpdateOrderItemQuantitiesResponse {
  "Whether the bulk update succeeded (required)."
  success: Boolean!

  "Optional message about the operation result."
  message: String
}

type UpdateOrderStatusResponse {
  "Whether the update succeeded (required)."
  success: Boolean!

  "Message describing the update result."
  message: String

  "Order object after the status update."
  order: SSPTableOrder

  "Number of items that had their status cascaded due to the order status change."
  cascadedItems: Int
}

type BatchUpdateOrderStatusResponse {
  "Whether the bulk update succeeded (required)."
  success: Boolean!

  "Optional message about the bulk operation result."
  message: String

  "Individual responses for each order status update."
  results: [UpdateOrderStatusResponse!]!
}

type AssignOrderToServerResponse {
  "Whether the assignment succeeded (required)."
  success: Boolean!
}

type CancelOrderResponse {
  "Whether the cancel operation succeeded (required)."
  success: Boolean!

  "The cancelled order."
  order: SSPTableOrder

  "Success message."
  message: String
}

type VoidOrderResponse {
  "Whether the void operation succeeded (required)."
  success: Boolean!

  "The voided order."
  order: SSPTableOrder

  "Previous status before voiding."
  previousStatus: String

  "Name of the manager who approved the void."
  approvedBy: String
}

type MergeOrdersResponse {
  "Whether the merge succeeded (required)."
  success: Boolean!
}

type SplitOrderResponse {
  "Whether the split succeeded (required)."
  success: Boolean!

  "The source order after the split."
  order: SSPTableOrder

  "New orders created as a result of the split (when targetOrderId was null)."
  createdOrders: [SSPTableOrder!]
}

type SubmitOrderResponse {
  "Whether the submission succeeded (required)."
  success: Boolean!

  "Optional message about the submission result."
  message: String

  "Order object after submission."
  order: SSPTableOrder
}

type MoveOrderToTableResponse {
  "Whether the move succeeded."
  success: Boolean!

  "Message describing the result."
  message: String

  "The updated order with new table assignment."
  order: SSPTableOrder

  "The previous table ID (null if was a to-go order)."
  previousTableId: ID

  "The new table ID (null if converted to to-go order)."
  newTableId: ID
}

"Represents a transfer of responsibility for a table order from one waiter to another."
type SSPTableTransfer {
  id: ID!
  tableOrder: SSPTableOrder!
  fromUser: SSPUser!
  toUser: SSPUser!
  approver: SSPUser
  organization: SSPOrganization
  location: SSPLocation
  note: String
  undone_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

"Payload returned after a transfer or undo."
type TransferTablePayload {
  success: Boolean!
  message: String
  transfer: SSPTableTransfer
}

"Information about API version compatibility."
type ApiVersionInfo {
  "Current API version."
  current: String!

  "List of supported API versions."
  supported: [String!]!

  "List of deprecated API versions."
  deprecated: [String!]!

  "Breaking changes by version."
  breaking_changes: JSON!

  "When this information was last updated."
  last_updated: DateTime!
}

"Result of checking client compatibility with API."
type CompatibilityCheck {
  "Whether the client version is compatible."
  compatible: Boolean!

  "Status of the version (current, outdated, deprecated, unsupported, future)."
  status: String!

  "Message about the compatibility status."
  message: String!

  "Recommendation for the client."
  recommendation: String

  "Current API version."
  current_version: String!

  "Client version being checked."
  client_version: String!
}

type CheckInvoiceDesigns {
  "The design configuration for table order checks (e.g., dining in)."
  check: SSPCheckDesign

  "The design configuration for invoices (e.g., catering, tax purposes)."
  invoice: SSPCheckDesign
}

type SSPCheckDesign {
  "Unique identifier for the check design."
  id: ID!

  "The ID of the location associated with this design."
  location_id: ID!

  "The ID of the location collection, if applicable."
  location_coll_id: ID

  "The type of template (CHECK or INVOICE)."
  template_type: TemplateTypeInput!

  "Header configuration for the check or invoice."
  header: CheckDesignHeader

  "Body configuration for the check or invoice."
  body: CheckDesignBody

  "Footer configuration for the check or invoice."
  footer: CheckDesignFooter

  "Styling configuration (e.g., fonts, colors) for the check or invoice."
  style: CheckDesignStyle

  "Layout configuration (e.g., margins, padding) for the check or invoice."
  layout: CheckDesignLayout
}

type CheckDesignHeader {
  "Custom restaurant name to override the location name."
  restaurantName: String

  "Custom address to override the location address."
  address: String

  "Whether to include the date on the check/invoice."
  includeDate: Boolean

  "Whether to include the servers name."
  includeServerName: Boolean

  "Whether to include the invoice number."
  includeInvoiceNumber: Boolean

  "Whether to display the restaurant logo."
  showLogo: Boolean

  "Whether to show the number of guests."
  showNumberOfGuests: Boolean

  "Whether to show the table number."
  showTableNumber: Boolean

  "Whether to show the time of the transaction."
  showTime: Boolean

  "Time format (e.g., TWELVE_HOUR or TWENTY_FOUR_HOUR)."
  timeFormat: TimeFormat

  "Date format (e.g., YYYY_MM_DD or MM_DD_YYYY)."
  dateFormat: DateFormat
}

type CheckDesignBody {
  "Whether to display an itemized list of ordered items."
  showItemizedList: Boolean

  "Whether to show the subtotal before taxes and fees."
  showSubtotal: Boolean

  "Whether to show applied discounts."
  showDiscounts: Boolean

  "Whether to show taxes applied to the order."
  showTaxes: Boolean

  "Whether to show the tip amount."
  showTip: Boolean

  "Whether to split taxes into individual line items."
  splitTaxes: Boolean

  "Whether to display the tax rate(s)."
  showTaxRate: Boolean
}

type CheckDesignFooter {
  "Whether to show the total amount for the order."
  showTotalAmount: Boolean

  "Whether to display a QR code (e.g., for payment or feedback)."
  showQrCode: Boolean

  "Custom thank you message for customers."
  thankYouMessage: String

  "Legal information or disclaimers."
  legalInfo: String

  "List of taxes to display in the footer."
  taxes: [TaxDisplay]

  "Text displayed above the QR code."
  qrcodeTextAbove: String

  "Text displayed below the QR code."
  qrcodeTextBelow: String
}

type CheckDesignStyle {
  "Font family settings for different sections."
  fontFamily: FontFamily

  "Font size settings for different sections."
  fontSize: FontSize

  "Text alignment settings for different sections."
  textAlign: TextAlign

  "Color settings for different sections."
  colors: Colors

  "Divider settings for different sections."
  dividers: Dividers

  "Line spacing settings for different sections."
  lineSpacing: LineSpacing
}

type FontFamily {
  "Font family for the header section."
  header: String

  "Font family for the body section."
  body: String

  "Font family for the total amount section."
  total: String

  "Font family for the footer section."
  footer: String
}

type FontSize {
  "Font size for the header section."
  header: String

  "Font size for the body section."
  body: String

  "Font size for the total amount section."
  total: String

  "Font size for the footer section."
  footer: String
}

type TextAlign {
  "Text alignment for the header section (e.g., left, center, right)."
  header: String

  "Text alignment for the body section."
  body: String

  "Text alignment for the total amount section."
  total: String

  "Text alignment for the footer section."
  footer: String
}

type Colors {
  "Color for the header section (e.g., hex code)."
  header: String

  "Color for the body section."
  body: String

  "Color for the total amount section."
  total: String

  "Color for the footer section."
  footer: String
}

type Dividers {
  "Whether to include a divider for the header section."
  header: Boolean

  "Whether to include a divider for the body section."
  body: Boolean

  "Whether to include a divider for the total amount section."
  total: Boolean

  "Whether to include a divider for the footer section."
  footer: Boolean
}

type LineSpacing {
  "Line spacing for the header section."
  header: String

  "Line spacing for the body section."
  body: String

  "Line spacing for the total amount section."
  total: String

  "Line spacing for the footer section."
  footer: String
}

type CheckDesignLayout {
  "Margin settings for the check/invoice layout."
  margins: String

  "Padding settings for the check/invoice layout."
  padding: String
}

"Represents how a tax is displayed on checks or invoices."
type TaxDisplay {
  "Full tax name (e.g., 'Goods and Services Tax')."
  taxLN: String

  "Short tax name (e.g., 'GST')."
  taxSN: String

  "Unique tax identifier (e.g., UUID)."
  taxID: String

  "Whether to display the full tax name."
  displayFullName: Boolean

  "Whether to display the short tax name."
  displayShortName: Boolean

  "Whether to display the tax ID."
  displayTaxID: Boolean

  "Whether the tax value is included in prices."
  taxValueIncluded: Boolean

  "Tax value to display (e.g., '0.071' for 7.1%)."
  taxValueAdded: String

  "Tax registration number of the business."
  taxRegistrationNumber: String
}

type EndOfDayReport {
  "Net sales from all transactions (excludes taxes, fees)."
  netSales: Float!

  "Total service charges collected (automatic gratuity)."
  serviceChargeTotal: Float!

  "Total tax collected across transactions."
  taxCollected: Float!

  "Total revenue including net sales and taxes."
  totalRevenue: Float!

  "Total discount amount applied."
  discounts: Float!

  "Total amount of returns/refunds processed."
  returns: Float!

  "Total amount of voided transactions."
  voids: Float!

  "Total rounding amount applied to transactions."
  roundingTotal: Float!

  "Total training-related amounts (if applicable)."
  trainingTotal: Float!

  "Total voluntary tips collected (customer-added)."
  tipTotal: Float!

  "Tips collected via cash payment."
  cashTips: Float!

  "Tips collected via card payment."
  cardTips: Float!

  "Number of checks started during the period."
  checksBegun: Int!

  "Number of checks paid during the period."
  checksPaid: Int!

  "Number of outstanding (unpaid) checks."
  outstandingChecks: Int!

  "Number of voided checks."
  checkVoids: Int!

  "Total number of transactions processed."
  transactionCount: Int!

  "Average value of checks/orders."
  averageCheckValue: Float!

  "Number of dine-in orders."
  dineInCount: Int!

  "Total sales from dine-in orders."
  dineInTotal: Float!

  "Number of to-go orders."
  toGoCount: Int!

  "Total sales from to-go orders."
  toGoTotal: Float!

  "Number of delivery orders."
  deliveryCount: Int!

  "Total sales from delivery orders."
  deliveryTotal: Float!

  "Breakdown of payment methods and their totals."
  tenderMedia: [TenderMedia!]!

  "Detailed sales data for individual items."
  itemSales: [ItemSale!]!

  "Sales breakdown by order type (dine-in, takeout, delivery)."
  salesByOrderType: [OrderTypeSales!]!

  "Sales breakdown by category (food, beverage, etc.)."
  salesByCategory: [CategorySales!]!

  "Cash drawer summary for the day."
  cashDrawerSummary: CashDrawerSummary

  "Outstanding/unpaid orders at end of day."
  outstandingOrders: [OutstandingOrder!]!
}

"Sales breakdown by order type."
type OrderTypeSales {
  "Order type (TABLE_SERVICE, TAKEOUT, DELIVERY, etc.)."
  orderType: String!

  "Total sales for this order type."
  total: Float!

  "Number of orders of this type."
  count: Int!
}

"Sales breakdown by category."
type CategorySales {
  "Category name (e.g., Food, Beverage, Merchandise)."
  category: String!

  "Total sales for this category."
  total: Float!

  "Number of items sold in this category."
  count: Int!
}

"Outstanding/unpaid order summary."
type OutstandingOrder {
  "Order ID."
  orderId: String!

  "Table number (if applicable)."
  tableNumber: String

  "Server name."
  serverName: String

  "Outstanding balance."
  balance: Float!

  "Order creation time."
  createdAt: DateTime!
}

type TenderMedia {
  "Payment method (e.g., Visa, Mastercard)."
  method: String!

  "Total amount paid using this method."
  total: Float!
}

"""
End of Shift Report - Individual employee shift closeout summary.
Used for server accountability and cash drawer reconciliation.
"""
type EndOfShiftReport {
  "Employee who worked the shift."
  employee: SSPUser!

  "Shift start time (clock-in)."
  shiftStart: DateTime!

  "Shift end time (clock-out, null if still open)."
  shiftEnd: DateTime

  "Total hours worked."
  hoursWorked: Float!

  "Number of orders/tables served."
  ordersServed: Int!

  "Total sales processed by this server."
  totalSales: Float!

  "Total taxes collected."
  taxCollected: Float!

  "Total voluntary tips received."
  tipsReceived: Float!

  "Tips received via cash."
  cashTips: Float!

  "Tips received via card."
  cardTips: Float!

  "Service charges on this server's orders."
  serviceCharges: Float!

  "Total discounts applied."
  discountsApplied: Float!

  "Number of voids processed."
  voidsCount: Int!

  "Total amount voided."
  voidsAmount: Float!

  "Number of refunds processed."
  refundsCount: Int!

  "Total amount refunded."
  refundsAmount: Float!

  "Payment method breakdown."
  paymentBreakdown: [TenderMedia!]!

  "Cash drawer information (if applicable)."
  cashDrawer: CashDrawer

  "Average order value."
  averageOrderValue: Float!

  "Revenue per hour."
  revenuePerHour: Float!
}

type SalesAggregate {
  "Aggregated data value (e.g., total sales)."
  data: Float!

  "Label for the aggregation (e.g., category or series label)."
  label: String!

  "Date associated with the aggregation (ISO8601)."
  date: String!
}

type StripeConnectionTokenResponse {
  "Secret token for Stripe connection."
  secret: String!
}

type StripeConnectStatus {
  "Stripe account ID, if connected."
  stripeAccountId: String

  "Whether charges are enabled for the account."
  chargesEnabled: Boolean

  "Whether payouts are enabled for the account."
  payoutsEnabled: Boolean

  "Whether account details have been submitted."
  detailsSubmitted: Boolean

  "Current status of the Stripe account."
  status: String

  "Stripe Terminal Location ID (tml_xxx) for Tap to Pay functionality."
  stripeTerminalLocationId: String

  "Whether Terminal/Tap to Pay is ready (has terminal location configured)."
  terminalReady: Boolean
}

type StripeOnboardingResponse {
  "URL for Stripe onboarding process."
  onboardingUrl: String!

  "Whether webhooks were successfully registered for this location."
  webhooksRegistered: Boolean
}

type StripeDashboardResponse {
  "URL for accessing the Stripe dashboard."
  dashboardUrl: String!
}

type StripeTerminalLocationResponse {
  "Whether the operation was successful."
  success: Boolean!

  "The Stripe Terminal Location ID (tml_xxx)."
  terminalLocationId: String

  "Human-readable message about the result."
  message: String!
}

type SSPPaymentGatewayConfiguration {
  "Unique identifier for the payment gateway configuration."
  id: ID!

  "Location ID associated with the configuration."
  location_id: ID!

  "Name of the payment gateway (e.g., Stripe)."
  gateway_name: String!

  "Configuration details in JSON format."
  gateway_config: JSON!

  "Associated webhook configurations."
  webhooks: [WebhookConfig!]

  "Creation timestamp."
  createdAt: DateTime!

  "Last update timestamp."
  updatedAt: DateTime!
}

type WebhookConfig {
  "Unique identifier for the webhook configuration."
  id: ID!

  "URL for the webhook endpoint."
  url: String!

  "Type of event the webhook listens for."
  event_type: String!

  "Secret key for webhook authentication."
  secret: String!

  "Creation timestamp."
  createdAt: DateTime!

  "Last update timestamp."
  updatedAt: DateTime!
}

type PaymentIntentResponse {
  "Client secret for the payment intent."
  clientSecret: String!

  "Unique ID for the payment intent."
  paymentIntentID: String

  "Current status of the payment intent (requires_payment_method, requires_confirmation, requires_action, processing, succeeded, canceled)."
  status: String

  "Next action required for the payment intent (e.g., 3D Secure authentication)."
  nextAction: PaymentIntentNextAction
}

type PaymentIntentNextAction {
  "Type of action required (redirect_to_url, use_stripe_sdk, etc)."
  type: String!

  "URL to redirect to for authentication (if type is redirect_to_url)."
  redirectToUrl: String

  "Stripe SDK data for handling authentication (if type is use_stripe_sdk)."
  useStripeSDK: JSON
}

type PaymentConfirmationResponse {
  "Whether the confirmation was successful."
  success: Boolean!

  "Payment intent ID."
  paymentIntentId: String!

  "Current status of the payment intent."
  status: String!

  "Payment amount."
  amount: Float!

  "Payment currency."
  currency: String!

  "Message about the confirmation result."
  message: String!
}

type PaymentCancellationResponse {
  "Whether the cancellation was successful."
  success: Boolean!

  "Payment intent ID."
  paymentIntentId: String!

  "Current status of the payment intent."
  status: String!

  "Payment amount."
  amount: Float!

  "Payment currency."
  currency: String!

  "Reason for cancellation."
  cancellationReason: String

  "Message about the cancellation result."
  message: String!
}

type PaymentRefundResponse {
  "Whether the refund was successful."
  success: Boolean!

  "Refund ID from Stripe."
  refundId: String

  "Payment intent ID that was refunded."
  paymentIntentId: String!

  "Current status of the refund (succeeded, pending, failed, canceled)."
  status: String!

  "Refund amount."
  amount: Float!

  "Refund currency."
  currency: String!

  "Reason for refund."
  reason: String

  "Message about the refund result."
  message: String!
}

type SSPUberEatsIntegration {
  "UberEats store ID."
  storeId: String

  "Access token for UberEats API."
  accessToken: String

  "Refresh token for UberEats API."
  refreshToken: String

  "Expiration timestamp for the access token."
  tokenExpiresAt: String
}

type UberEatsIntegrationStatus {
  "Whether the UberEats account is linked."
  linked: Boolean!

  "UberEats store ID, null if not linked."
  storeId: String

  "Timestamp of the last successful sync, null if never synced."
  lastSync: String
}

type LinkUberEatsAccountResponse {
  "Status of the UberEats account linking attempt."
  status: String!

  "Message describing the outcome."
  message: String!

  "List of errors, if any."
  errors: [String!]
}

type UberEatsOrderResponse {
  "Whether the operation was successful."
  success: Boolean!

  "Message describing the outcome."
  message: String!

  "List of errors, if any."
  errors: [String!]
}

type S3PresignedUrlResponse {
  "Presigned URL for uploading to S3."
  url: String!

  "Key for the uploaded object in S3."
  key: String!
}

type ImageUrlPayload {
  "Preferred image URL (optimized size)."
  url: String!

  "Fallback image URLs (e.g., original sizes)."
  fallback: [String!]!
}

type UploadImagePayload {
  "Whether the image upload was successful."
  success: Boolean!

  "Details of the uploaded image."
  image: ImageUrlPayload!
}

type SSPOnboardingStatus {
  "Unique identifier for the onboarding status."
  id: ID!

  "User ID associated with the onboarding process."
  userId: ID!

  "Location ID, if applicable."
  locationId: ID

  "Current step in the onboarding process."
  step: OnboardingStep!

  "Timestamp when the onboarding was completed, if applicable."
  completedAt: DateTime
}

type TransactionLog {
  "Unique identifier for the transaction log entry."
  id: ID!

  "Type of action performed (e.g., CREATE, UPDATE, DELETE)."
  action: String!

  "Detailed description of the action."
  description: String!

  "User who performed the action."
  user: SSPUser

  "Type of model affected by the action."
  modelType: String

  "ID of the model affected by the action."
  modelId: ID

  "Additional data related to the action."
  data: JSON

  "Timestamp when the log entry was created."
  createdAt: DateTime
}

"Response for recording a manual payment."
type RecordManualPaymentResponse {
  "Whether the payment was recorded successfully."
  success: Boolean!

  "Message describing the outcome."
  message: String!

  "The updated order after payment."
  order: SSPTableOrder

  "The created transaction record."
  transaction: SSPSaleTransaction
}

"""
Metadata for a permission including name, title, description, and category.
This provides human-readable information about each permission for frontend display.
"""
type PermissionMetadata {
  "The permission name (e.g., 'create_orders', 'view_menu_items')"
  name: String!

  """
  Human-readable title for the permission (e.g., 'Create Orders', 'View Menu Items')
  Extracted from the first line of the permission's DocBlock comment.
  """
  title: String!

  """
  Detailed description explaining what the permission allows.
  Extracted from the permission's DocBlock comment.
  """
  description: String!

  """
  The category this permission belongs to (e.g., 'Order Management', 'Menu Management')
  Groups related permissions together for better organization and UI display.
  """
  category: String!
}

"""
Permissions grouped by category for easier frontend display.
This type groups related permissions together under their category name.
"""
type PermissionsByCategory {
  "The category name (e.g., 'Order Management', 'Menu Management')"
  category: String!

  "List of permissions that belong to this category"
  permissions: [PermissionMetadata!]!
}

"""
Response type for baseRolePermissions query.
Returns the default permissions for a base role template, filtered to only include
permissions the current user can grant (intersection with user's own permissions).
"""
type BaseRolePermissionsResponse {
  "The base role that was queried (e.g., 'WAIT_STAFF', 'LOCATION_MANAGER')"
  baseRole: RestaurantRoles!

  """
  List of permissions for this base role that the current user can grant.
  Filtered to only include permissions the requesting user has.
  """
  permissions: [PermissionMetadata!]!

  "Count of permissions returned (after filtering to user's available permissions)"
  permissionCount: Int!

  """
  Total number of permissions defined for this base role (before filtering).
  Useful for showing users how many permissions they cannot grant due to their own role.
  """
  totalBaseRolePermissions: Int!
}

"Status of a print request sent via RabbitMQ to PrinterManagement app."
enum PrintRequestStatus {
  "Job is queued and waiting to be printed."
  PENDING

  "Job was printed successfully."
  SUCCESS

  "Job failed with a general error."
  ERROR

  "Printer is out of paper."
  INSERT_PAPER

  "Printer is out of ink."
  OUT_OF_INK

  "Unknown error occurred."
  UNKNOWN
}

"""
Represents a print request sent to a RabbitMQ-based printer.
Used for monitoring job status from PrinterManagement app.
"""
type PrintRequest {
  "Unique identifier of the print request."
  id: ID!

  "The printer this request was sent to."
  printer: SSPPrinter

  "ID of the printer."
  printer_id: ID!

  "Name of the printer at time of request."
  printer_name: String!

  "Type of content (html, pdf, raw, png)."
  type: String!

  "Current status of the print request."
  status: PrintRequestStatus!

  "Feedback message from the printer (error details, etc)."
  feedback_message: String

  "When the request was created."
  created_at: DateTime!

  "When the request was last updated."
  updated_at: DateTime!
}

"Statistics for print requests."
type PrintRequestStats {
  "Total number of print requests."
  total: Int!

  "Number of pending requests."
  pending: Int!

  "Number of successful requests."
  success: Int!

  "Number of failed requests (all error types)."
  failed: Int!
}

"""
Unified print job for monitoring dashboard.
Combines both RabbitMQ (PrintRequest) and CloudPRNT (CloudPrintJob) jobs.
"""
type UnifiedPrintJob {
  "Unique identifier (prefixed with 'pr_' or 'cpj_' to distinguish type)."
  id: String!

  "Printer name or alias."
  printer_name: String!

  "Printer ID."
  printer_id: ID!

  "Type of printer: RABBITMQ or CLOUDPRNT."
  printer_type: String!

  "Content type (html, pdf, raw, png)."
  content_type: String!

  "Current status (normalized across both types)."
  status: String!

  "Error or feedback message if any."
  message: String

  "When the job was created."
  created_at: DateTime!

  "When the job was last updated."
  updated_at: DateTime
}

"Represents a temporary passcode for authenticating a printer."
type PrinterPasscodeResult {
  "Passcode string for authentication."
  passcode: String

  "Expiration timestamp of the passcode."
  expiresAt: String
}

"Represents a print job type associated with a printer."
type SSPPrinterJob {
  "Unique identifier of the printer job (required)."
  id: ID!

  "Associated printer ID (required)."
  printerId: ID!

  "Type of job handled by the printer (e.g., RECEIPT, KITCHEN)."
  jobType: String!
}

"Represents a printer registered in the SSP ecosystem."
type SSPPrinter {
  "Unique identifier of the printer (required)."
  id: ID!

  "Name of the printer (required)."
  name: String!

  "Associated location ID (required)."
  location_id: ID!

  "Optional alias for easier identification (e.g., 'Kitchen Printer')."
  alias: String

  "Printer socket name (used for identification)."
  sockName: String

  "Printer IP address (for network printers)."
  sockIp: String

  "Printer port number (for network printers)."
  sockPort: Int

  "List of jobs supported by this printer (required)."
  jobs: [SSPPrinterJob!]!

  "Certificate for secure connections (if applicable)."
  certificate: String

  "Private key for secure connections (if applicable)."
  privateKey: String

  "RabbitMQ queue name for receiving print jobs."
  rabbitmq_queue: String

  "Current status of the printer (e.g., ONLINE, OFFLINE)."
  status: String

  "Last time the printer checked in with the server."
  last_seen_at: String

  "Timestamp when the printer was created (required)."
  created_at: String!

  "Timestamp when the printer was last updated (required)."
  updated_at: String!

  "Supported paper length in millimeters (optional)."
  paper_length: Int

  "Supported paper width in millimeters (optional)."
  paper_width: Int

  "Horizontal DPI resolution of the printer (optional)."
  dpi_x: Int

  "Vertical DPI resolution of the printer (optional)."
  dpi_y: Int
}

"""
Represents the response to a print request.
Supports both RabbitMQ and CloudPRNT printers.
"""
type PrintRequestResponse {
  "Overall status of the print request (e.g., success, error)."
  status: String!

  "Message providing details about the print request result."
  message: String!

  "Job token for CloudPRNT printers (null for RabbitMQ printers)."
  jobToken: String
}

enum PrivacyRequestType {
  ACCESS
  RECTIFICATION
  ERASURE
  PORTABILITY
  RESTRICT
  WITHDRAW_CONSENT
  OBJECT
}

enum PrivacyRequestStatus {
  PENDING
  PROCESSING
  COMPLETED
  REJECTED
}

type PrivacyRequest {
  id: ID!
  user: SSPUser!
  requestType: PrivacyRequestType!
  status: PrivacyRequestStatus!
  description: String
  metadata: JSON
  requestedAt: DateTime!
  processedAt: DateTime
  processedBy: SSPUser
  adminNotes: String
  exportUrl: String
  exportExpiresAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserPrivacySettings {
  dataProcessingRestricted: Boolean!
  marketingConsent: Boolean!
  analyticsConsent: Boolean!
  consentUpdatedAt: DateTime
  deletionRequestedAt: DateTime
  scheduledDeletionAt: DateTime
}

type UserDataExport {
  user: UserBasicInfo!
  profile: UserProfileData
  settings: UserSettingsData
  locations: [LocationBasicInfo!]
  trustedDevices: [TrustedDeviceInfo!]
  privacyRequests: [PrivacyRequestInfo!]
  exportedAt: DateTime!
}

type UserBasicInfo {
  id: ID!
  name: String!
  email: String!
  username: String
  createdAt: DateTime!
  emailVerifiedAt: DateTime
}

type UserProfileData {
  phoneNumber: String
  address: String
  city: String
  state: String
  postalCode: String
  country: String
}

type UserSettingsData {
  language: String
  timezone: String
  currency: String
  notifications: JSON
}

type LocationBasicInfo {
  id: ID!
  name: String!
  role: String
}

type TrustedDeviceInfo {
  id: ID!
  deviceName: String
  lastUsedAt: DateTime
  createdAt: DateTime!
}

type PrivacyRequestInfo {
  id: ID!
  requestType: PrivacyRequestType!
  status: PrivacyRequestStatus!
  requestedAt: DateTime!
  processedAt: DateTime
}

type PrivacyRequestResponse {
  success: Boolean!
  message: String!
  request: PrivacyRequest
}

type DataExportResponse {
  success: Boolean!
  message: String!
  downloadUrl: String
  expiresAt: DateTime
}

type ConsentUpdateResponse {
  success: Boolean!
  message: String!
  settings: UserPrivacySettings!
}

type AccountDeletionResponse {
  success: Boolean!
  message: String!
  scheduledDeletionDate: DateTime
}

"Represents the assignment of a waiter to a table."
type SSPTableAssignment {
  "Unique identifier of the assignment (required)."
  id: ID!

  "The table that was assigned (required)."
  table: SSPTable!

  "The waiter/user assigned to the table (required)."
  waiter: SSPUser!

  "Timestamp when the waiter was assigned (required)."
  assignedAt: String!

  "Timestamp when the waiter was unassigned."
  unassignedAt: String

  "Formatted assigned timestamp (required)."
  assignedAtFormatted: String!

  "Formatted unassigned timestamp."
  unassignedAtFormatted: String
}

"Represents section or table assignment at a specific entry point."
type SectionAtEntry {
  "Unique key provided by the client (required)."
  key: String!

  "Source of assignment: 'SHIFT', 'INSTANT', or 'NONE'."
  source: String!

  "Section assigned to the entry (optional)."
  section: SSPSection

  "Table assigned to the entry (optional)."
  table: SSPTable

  "Whether this is the primary assignment for the user."
  isPrimary: Boolean

  "Relative weight for load balancing assignments."
  weight: Int

  "Optional assignment ID"
  assignmentId: ID
}

"Represents the assignment of a section, table, and user during a shift."
type SSPSectionAssignment {
  "Unique identifier of the section assignment (required)."
  id: ID!

  "Location ID where this assignment applies (required)."
  locationId: ID!

  "Section assigned in this record (optional)."
  section: SSPSection

  "Table assigned in this record (optional)."
  table: SSPTable

  "User assigned to this section/table (required)."
  user: SSPUser!

  "Shift ID if tied to a specific scheduled shift."
  shiftId: ID

  "Shift date (required if shiftId is not provided)."
  shiftDate: Date

  "Start time of the assignment."
  startAt: DateTime

  "End time of the assignment."
  endAt: DateTime

  "Role label for this assignment (e.g., 'Lead Waiter')."
  roleLabel: String

  "Whether this is the primary assignment for the user."
  isPrimary: Boolean

  "Relative weight for load balancing assignments (required)."
  weight: Int!
}

"Represents a service section within a restaurant (e.g., Patio, Bar)."
type SSPSection {
  "Unique identifier of the section (required)."
  id: ID!

  "Location ID where this section belongs (required)."
  locationId: ID!

  "Name of the section (required)."
  name: String!

  "Display order for sorting sections (required)."
  displayOrder: Int!

  "Whether the section is currently active (required)."
  isActive: Boolean!

  "Tables belonging to this section (required)."
  tables: [SSPTable!]!
}

"Represents a table layout within a location floor plan."
type TableLayout {
  "Unique identifier of the table layout (required)."
  id: ID!

  "Display name of the table (required)."
  name: String!

  "Location reference (required)."
  location: String!

  "Number of seats at the table (required)."
  number_of_seats: Int!

  "X position of the table in the layout (required)."
  position_x: Float!

  "Y position of the table in the layout (required)."
  position_y: Float!

  "Floor number where the table is placed (required)."
  floor_number: Int!

  "Shape of the table (e.g., 'CIRCLE', 'SQUARE') (required)."
  shape: String!

  "Size of the table (e.g., 'SMALL', 'LARGE') (required)."
  size: String!

  "Reference to the associated location layout (required)."
  location_layout_id: ID!
}

"Represents a physical table within a restaurant."
type SSPTable {
  "Unique identifier of the table (required)."
  id: ID!

  "Local ID incremented per location."
  local_id: Int

  "Name or label of the table (e.g., 'Table 1') (required)."
  name: String!

  "Number of seats at the table (required)."
  number_of_seats: Int!

  "Current status of the table (e.g., AVAILABLE, OCCUPIED) (required)."
  status: String!

  "Serialized reservation information."
  reservation_info: String

  "Type of table (e.g., 'ROUND', 'SQUARE')."
  table_type: String

  "Accessibility notes (e.g., wheelchair access)."
  accessibility: String

  "Minimum spend requirement for the table."
  minimum_spend: Float

  "Special notes about the table."
  special_notes: String

  "Timestamp or string when the table was last cleaned."
  last_cleaned: String

  "Layout information for the table (optional)."
  tableLayout: TableLayout

  "Orders historically associated with the table."
  orders: [SSPTableOrder]

  "Currently active orders for the table."
  activeOrders: [SSPTableOrder]

  "Location where the table belongs."
  location: SSPLocation

  "Section where the table belongs (optional)."
  section: SSPSection

  "Active NFC tag assigned to this table (if any)."
  nfcTag: NFCTag
}

"Paginated response for tables."
type SSPTablePagination {
  "List of tables in the current page (required)."
  tables: [SSPTable!]!

  "Total number of tables (required)."
  total: Int!

  "Current page number (required)."
  page: Int!

  "Number of tables per page (required)."
  pageSize: Int!
}

"Represents reservation details for a table."
type ReservationInfo {
  "Date and time of the reservation."
  reservationTime: DateTime

  "Name of the customer with the reservation."
  customerName: String
}

"Represents the result of a tax diagnostics check."
type TaxDiagnosticsReport {
  "Message describing the diagnostic result (required)."
  message: String!

  "Status of the diagnostic (e.g., SUCCESS, WARNING, ERROR) (required)."
  status: String!
}

"Represents a tax rule that applies to items, categories, or locations."
type SSPTaxRule {
  "Unique identifier of the tax rule (required)."
  id: ID!

  "Associated tax ID (required)."
  tax_id: ID!

  "Menu item ID this rule applies to (optional)."
  item_id: ID

  "Menu category ID this rule applies to (optional)."
  category_id: ID

  "Date and time when the rule starts applying."
  start_date: DateTime

  "Date and time when the rule ends applying."
  end_date: DateTime

  "Minimum quantity threshold for rule applicability."
  quantity_min: Int

  "Maximum quantity threshold for rule applicability."
  quantity_max: Int

  "Priority of this rule when multiple rules apply."
  priority: Int

  "Whether the tax is exempt under this rule."
  is_exempt: Boolean

  "Scope of the tax rule (GLOBAL, LOCATION, ITEM, CATEGORY)."
  scope: SSPTaxApplicableTo

  "ID of the rule that this one overrides (if applicable)."
  overrides_rule_id: ID

  "Location-specific tax this rule is associated with."
  locationTax: SSPLocationTax

  "Menu item this rule applies to."
  item: SSPMenuItem

  "Menu category this rule applies to."
  category: SSPMenuCategory

  "Location this rule applies to."
  location: SSPLocation

  "The rule that this one overrides."
  overridesRule: SSPTaxRule

  "Rules that override this rule (paginated)."
  overriddenByRules(first: Int, page: Int): SSPTaxRulePaginator!

  "Timestamp when the rule was created."
  created_at: DateTime

  "Timestamp when the rule was last updated."
  updated_at: DateTime
}

"Pagination object for SSPTaxRule."
type SSPTaxRulePaginator {
  "List of tax rules in the current page (required)."
  data: [SSPTaxRule!]!

  "Pagination metadata (required)."
  paginatorInfo: PaginatorInfo!
}

"Represents a base tax definition (e.g., VAT, GST, HST)."
type SSPTax {
  "Unique identifier of the tax (required)."
  id: ID!

  "Full name of the tax (required)."
  name: String!

  "Short code or abbreviation for the tax (required)."
  name_short: String!

  "Tax rate as a numeric value (required)."
  rate: Float!

  "Tax rate as a formatted string (e.g., '7.5%')."
  rate_str: String

  "Whether the tax is included in listed prices (required)."
  is_included: Boolean!

  "Country where the tax applies."
  country: String

  "Region or province where the tax applies."
  region: String

  "Administrative area or district (if applicable)."
  admin_area: String

  "Type of the tax (required)."
  tax_type: TaxType!

  "Effective start date for the tax definition."
  effective_from: DateTime

  "Effective end date for the tax definition."
  effective_to: DateTime

  "Timestamp when the tax was created."
  created_at: String

  "Timestamp when the tax was last updated."
  updated_at: String
}

"Represents a tax configuration associated with a specific location."
type SSPLocationTax {
  "Unique identifier of the location tax (required)."
  id: ID!

  "Location ID where this tax applies (required)."
  s_s_p_location_id: ID!

  "Tax ID linked to this location (required)."
  s_s_p_tax_id: ID!

  "Tax registration ID (optional)."
  tax_reg_id: String

  "Custom tax name override (optional)."
  custom_tax_name: String

  "Custom tax rate override (optional)."
  custom_rate: Float

  "Whether this tax configuration is active."
  is_active: Boolean

  "How this tax behaves in composition (STACKED, COMPOUNDED)."
  composition_behavior: CompositionBehavior

  "Reference to the base tax definition."
  tax: SSPTax

  "Reference to the location where the tax applies."
  location: SSPLocation

  "Paginated tax rules for this location tax."
  taxRules(first: Int! = 15, page: Int = 1): SSPTaxRulePaginator!

  "Timestamp when the location tax was created."
  created_at: String

  "Timestamp when the location tax was last updated."
  updated_at: String
}

"Represents an individual tax component applied to an order/item."
type TaxComponent {
  "Name of the tax (e.g., 'GST')."
  name: String!

  "Rate of the tax as a decimal (e.g., 0.075)."
  rate: Float!

  "Monetary amount of the tax applied."
  amount: Float!

  "Whether this component is exempt."
  isExempt: Boolean!
}

"Snapshot of a tax rule application for auditing/debugging."
type TaxRuleSnapshot {
  "Unique identifier of the rule (required)."
  rule_id: ID!

  "Associated tax ID (required)."
  tax_id: ID!

  "Tax rate applied (required)."
  rate: Float!

  "Name of the location tax used (required)."
  location_tax_name: String!

  "Scope of the rule (required)."
  scope: SSPTaxApplicableTo!

  "Whether the tax was exempt under this rule (required)."
  is_exempt: Boolean!

  "Timestamp when the rule was applied (required)."
  applied_on: DateTime!

  "List of overridden rule IDs."
  overridden_rule_ids: [ID!]

  "Priority of the applied rule (required)."
  priority: Int!
}

"Represents a tax preview summary for an order or item."
type TaxPreviewSummary {
  "Total tax amount (required)."
  total: Float!

  "List of individual tax components applied (required)."
  components: [TaxComponent!]!

  "Snapshot of rules applied during preview (required)."
  snapshot: [TaxRuleSnapshot!]!
}

"Paginated response for base taxes."
type PaginatedSSPTaxes {
  "List of taxes in the current page (required)."
  taxes: [SSPTax!]!

  "Total number of taxes (required)."
  total: Int!

  "Current page number (required)."
  page: Int!

  "Number of taxes per page (required)."
  pageSize: Int!
}

"Paginated response for location taxes."
type PaginatedSSPLocationTaxes {
  "List of location-specific taxes in the current page (required)."
  taxes: [SSPLocationTax!]!

  "Total number of location taxes (required)."
  total: Int!

  "Current page number (required)."
  page: Int!

  "Number of location taxes per page (required)."
  pageSize: Int!
}

"Represents a clock-in/clock-out record for a user at a location."
type ClockInOut {
  "Unique identifier of the clock entry (required)."
  id: ID!

  "The user who clocked in/out (required)."
  user: SSPUser!

  "The location where the user clocked in/out (required)."
  location: SSPLocation!

  "Associated scheduled shift (optional)."
  shift: Shift

  "Timestamp when the user clocked in."
  clock_in_time: DateTime

  "Timestamp when the user clocked out."
  clock_out_time: DateTime

  "Latitude at clock-in (optional)."
  clock_in_lat: Float

  "Longitude at clock-in (optional)."
  clock_in_long: Float

  "Latitude at clock-out (optional)."
  clock_out_lat: Float

  "Longitude at clock-out (optional)."
  clock_out_long: Float

  "Total number of hours worked in this entry."
  total_hours_worked: Float

  "Status of the associated shift (e.g., OPEN, CLOSED)."
  shift_status: ShiftStatus

  "Timestamp when the entry was created (required)."
  created_at: DateTime!

  "Timestamp when the entry was last updated (required)."
  updated_at: DateTime!

  "Source of the clock entry (e.g., MOBILE, ADMIN_OVERRIDE)."
  source: ClockSource!

  "Status of the entry (OPEN, CLOSED, FLAGGED)."
  status: ClockEntryStatus!

  "Reasons why the entry was flagged (e.g., OUT_OF_GEOFENCE)."
  flagged_reasons: [ClockFlagReason!]

  "Device fingerprint at clock-in (optional)."
  device_fingerprint_in: String

  "Device fingerprint at clock-out (optional)."
  device_fingerprint_out: String

  "Manager who approved the entry adjustment (optional)."
  approved_by: SSPUser

  "Timestamp when the adjustment was approved (optional)."
  approved_at: DateTime

  "Manager note about adjustment or approval (optional)."
  note: String
}

"Configuration settings for timeclock behavior at a location."
type TimeclockSettings {
  "Allowed geofence radius in meters (e.g., 75)."
  geofenceRadiusMeters: Int!

  "Whether geofence is required for clock-out validation."
  requireGeofenceOnClockOut: Boolean!

  "Window (in minutes) before scheduled shift start allowed for clock-in."
  clockInWindowBeforeMin: Int!

  "Window (in minutes) after scheduled shift start allowed for clock-in."
  clockInWindowAfterMin: Int!

  "Whether ad-hoc (unscheduled) clock-in is allowed."
  allowAdHocClockIn: Boolean!

  "Rounding rule in minutes for worked hours (e.g., 0, 5, 15)."
  roundingRuleMin: Int!

  "Whether the same device must be used for clock-in and clock-out."
  bindDeviceForShift: Boolean!
}

"Evaluation result of a clock action against rules (geofence, window, device)."
type ClockEvaluation {
  "Whether the geofence validation passed."
  geofenceOk: Boolean!

  "Whether the clock-in/out was within the allowed window."
  windowOk: Boolean!

  "Whether the device matched the expected fingerprint."
  deviceOk: Boolean!

  "Reasons why the entry was flagged (if any)."
  flagged_reasons: [ClockFlagReason!]!
}

"Result of a clock action, containing the entry and evaluation outcome."
type ClockResult {
  "The resulting clock entry (required)."
  entry: ClockInOut!

  "Evaluation of the clock entry (required)."
  evaluation: ClockEvaluation!
}

"Represents a timesheet summary for a user over a period."
type TimesheetSummary {
  "The user whose timesheet is summarized (required)."
  user: SSPUser!

  "Total number of regular hours worked (required)."
  total_hours: Float!

  "Total number of overtime hours worked (required)."
  overtime_hours: Float!

  "List of individual clock-in/out entries (required)."
  entries: [ClockInOut!]!
}

"Represents a scheduled shift for a user or group of users."
type Shift {
  "Unique identifier of the shift (required)."
  id: ID!

  "Location ID where this shift takes place (required)."
  location_id: ID!

  "Optional title/label for the shift (e.g., 'Morning Shift')."
  title: String

  "Role required for the shift (optional)."
  role: String

  "Start time of the shift (required)."
  start_time: DateTime!

  "End time of the shift (required)."
  end_time: DateTime!

  "Timestamp when the shift was created (required)."
  created_at: DateTime!

  "Timestamp when the shift was last updated (required)."
  updated_at: DateTime!

  "Assignments of users to this shift (required)."
  assignments: [ShiftAssignment!]!
}

"Represents a user assignment to a shift."
type ShiftAssignment {
  "Unique identifier of the shift assignment (required)."
  id: ID!

  "ID of the assigned shift (required)."
  shift_id: ID!

  "User ID of the assignee (deprecated, use `user`)."
  user_id: ID @deprecated(reason: "Use `user { \u2026 }`")

  "ID of the user who assigned this shift (deprecated, use `assignedBy`)."
  assigned_by: ID @deprecated(reason: "Use `assignedBy { \u2026 }`")

  "Optional note about the assignment."
  note: String

  "Timestamp when the assignment was created (required)."
  created_at: DateTime!

  "Timestamp when the assignment was last updated (required)."
  updated_at: DateTime!

  "The user assigned to the shift (required)."
  user: SSPUser!

  "The user who assigned this shift (optional)."
  assignedBy: SSPUser

  "The full shift details (required)."
  shift: Shift!
}

"Result of a bulk shift import operation."
type BulkShiftImportResult {
  "Whether the import completed successfully."
  success: Boolean!

  "Number of shifts created."
  shiftsCreated: Int!

  "Number of shift assignments created."
  assignmentsCreated: Int!

  "Total rows processed from CSV."
  rowsProcessed: Int!

  "Number of valid rows (passed validation)."
  validRows: Int!

  "Whether this was a dry run (validation only)."
  dryRun: Boolean!

  "List of errors encountered during import."
  errors: [BulkImportError!]!
}

"Error encountered during bulk import."
type BulkImportError {
  "Row number in the CSV file (1-indexed)."
  row: Int!

  "Description of the error."
  message: String!
}

"Result of shift coverage gap analysis."
type ShiftCoverageGapsResult {
  "Location ID analyzed."
  locationId: ID!

  "Start of the analysis period."
  startDate: DateTime!

  "End of the analysis period."
  endDate: DateTime!

  "Total number of shifts in the period."
  totalShifts: Int!

  "Total number of coverage gaps found."
  totalGaps: Int!

  "List of coverage gaps detected."
  gaps: [CoverageGap!]!
}

"A detected gap in shift or section coverage."
type CoverageGap {
  "Type of gap (UNASSIGNED_SHIFT, UNCOVERED_SECTION)."
  type: CoverageGapType!

  "Severity level (HIGH, MEDIUM, LOW)."
  severity: CoverageGapSeverity!

  "Associated shift ID."
  shiftId: ID

  "Shift title if applicable."
  shiftTitle: String

  "Shift role if applicable."
  shiftRole: String

  "Section ID if applicable."
  sectionId: ID

  "Section name if applicable."
  sectionName: String

  "Start time of the gap period."
  startTime: DateTime!

  "End time of the gap period."
  endTime: DateTime!

  "Human-readable description of the gap."
  message: String!
}

"Type of coverage gap."
enum CoverageGapType {
  "Shift has no employees assigned."
  UNASSIGNED_SHIFT

  "Section has no coverage during a shift."
  UNCOVERED_SECTION

  "User assigned to shift but no section assignment."
  SHIFT_WITHOUT_SECTION
}

"Severity level of a coverage gap."
enum CoverageGapSeverity {
  "Critical - immediate attention required."
  HIGH

  "Warning - should be addressed."
  MEDIUM

  "Informational - minor issue."
  LOW
}

"Result of user coverage analysis."
type UserCoverageAnalysisResult {
  "User ID analyzed."
  userId: ID!

  "Location ID analyzed."
  locationId: ID!

  "Start of the analysis period."
  startDate: DateTime!

  "End of the analysis period."
  endDate: DateTime!

  "Total shift assignments for the user."
  totalShiftAssignments: Int!

  "Total section assignments for the user."
  totalSectionAssignments: Int!

  "List of issues found."
  issues: [CoverageGap!]!
}

"""
Represents a connection between a restaurant location and Uber Eats.
Stores OAuth tokens and connection metadata for syncing orders.
"""
type UberEatsConnection {
  "Unique identifier for this connection"
  id: ID!

  "Restaurant location this connection is registered to"
  location_id: ID!

  "Uber Eats store/restaurant ID"
  store_id: String

  "Connection status: pending, connected, disconnected, error"
  status: String!

  "When the OAuth access token expires"
  token_expires_at: Date

  "Webhook URL registered with Uber Eats"
  webhook_url: String

  "Additional connection metadata"
  metadata: JSON

  "Last successful sync timestamp"
  last_sync_at: Date

  "Last error message if connection failed"
  last_error: String

  "When this connection was created"
  created_at: Date!

  "When this connection was last updated"
  updated_at: Date!

  "Whether the connection is active and token is valid"
  is_active: Boolean!
}

"""
Response returned when initiating Uber Eats OAuth connection.
Contains the authorization URL that the user should visit.
"""
type ConnectUberEatsResponse {
  "Status of the connection initiation"
  status: String!

  "Authorization URL where user grants access"
  authorization_url: String!

  "Temporary state token for security"
  state: String!

  "Message to display to user"
  message: String
}

"Response returned when disconnecting from Uber Eats."
type DisconnectUberEatsResponse {
  "Status of the disconnection"
  status: String!

  "Confirmation message"
  message: String!
}

"Webhook event log for tracking Uber Eats webhook deliveries."
type UberEatsWebhookLog {
  "Unique identifier for this log entry"
  id: ID!

  "Connection this webhook belongs to"
  uber_eats_connection_id: ID

  "Type of event (order.created, order.updated, etc.)"
  event_type: String!

  "Uber Eats order ID"
  external_order_id: String

  "Full webhook payload"
  payload: JSON!

  "Processing status: pending, processed, failed"
  status: String!

  "Error message if processing failed"
  error_message: String

  "When the webhook was processed"
  processed_at: Date

  "When this log was created"
  created_at: Date!

  "When this log was updated"
  updated_at: Date!
}

"Type of printer connection."
enum PrinterConnectionType {
  "RabbitMQ-based printer (via PrinterManagement app on PC)."
  RABBITMQ

  "Star CloudPRNT printer (direct HTTP polling, no PC required)."
  CLOUDPRNT
}

"""
Unified printer representation for the frontend.
Combines both SSPPrinter (RabbitMQ) and CloudPrinter (CloudPRNT) types.
"""
type UnifiedPrinter {
  "Unique identifier of the printer."
  id: ID!

  "Display name of the printer."
  name: String!

  "Optional alias for easier identification."
  alias: String

  "Connection type: RABBITMQ or CLOUDPRNT."
  connection_type: PrinterConnectionType!

  "Current status: ONLINE, OFFLINE, PENDING, ERROR."
  status: String!

  "Whether the printer is currently online."
  is_online: Boolean!

  "Location ID where the printer is installed."
  location_id: ID!

  "Last time the printer was seen/polled."
  last_seen_at: String

  "Printer model (if available)."
  printer_model: String

  "MAC address (CloudPRNT only)."
  mac_address: String

  "Paper width in mm (if available)."
  paper_width: Int

  "Paper length in mm (if available)."
  paper_length: Int

  "Horizontal DPI (if available)."
  dpi_x: Int

  "Vertical DPI (if available)."
  dpi_y: Int

  "Job types this printer handles (e.g., RECEIPT, KITCHEN)."
  job_types: [String!]

  "When the printer was created/registered."
  created_at: String!

  "When the printer was last updated."
  updated_at: String!
}

type SSPUser {
  "Unique identifier for the user."
  id: ID!

  "User's full name."
  name: String!

  "User's email address."
  email: String!

  "Whether two-factor authentication is enabled."
  two_factor_enabled: Boolean!

  "User's username, if set."
  username: String

  "User's status (e.g., ACTIVE, INACTIVE)."
  status: UserStatus

  "List of roles assigned to the user."
  roles: [RestaurantRoles]

  "Locations associated with the user."
  locations: [SSPLocation]

  "Location collections associated with the user."
  collections: [SSPLocCollection]

  "Organization the user belongs to."
  organization: SSPOrganization

  "User-specific settings."
  settings: SSPUserSetting

  "List of permissions assigned to the user."
  permissions: [String!]!

  "Timestamp when the user's email was verified."
  email_verified_at: DateTime

  "Current session details for the waiter."
  session: WaiterSession

  "Social accounts linked to this user."
  socialAccounts: [SocialAccount!]!

  "Whether the user has a password set."
  hasPassword: Boolean!
}

type SSPProfile {
  "Unique identifier for the profile."
  id: ID!

  "User's phone number."
  phone_number: String

  "Creation timestamp."
  created_at: DateTime!

  "Last update timestamp."
  updated_at: DateTime!

  "Associated user object."
  sspUser: SSPUser!
}

type UserProfileExt {
  "Unique identifier for the extended profile."
  id: ID!

  "ID of the associated user."
  s_s_p_user_id: ID!

  "User's address."
  address: String

  "User's city."
  city: String

  "User's state or region."
  state: String

  "User's postal code."
  postal_code: String

  "User's country."
  country: String

  "User's phone number."
  phone_number: String

  "User's website URL."
  website: String

  "Additional notes about the user."
  notes: String

  "Timestamp when the user's email was verified."
  email_verified_at: DateTime

  "Creation timestamp."
  created_at: String

  "Last update timestamp."
  updated_at: String
}

type SSPUserSetting {
  "Unique identifier for the user settings."
  id: ID!

  "ID of the associated user."
  user_id: ID!

  "Whether dark mode is enabled for the user."
  dark_mode: Boolean!

  "Whether training mode is enabled for the user."
  training_mode: Boolean!
}

type WaiterSummary {
  "Unique identifier for the waiter."
  id: ID!

  "Waiter's name."
  name: String

  "Waiter's email address."
  email: String

  "Waiter's username."
  username: String

  "List of role labels assigned to the waiter."
  roleLabels: [String!]!

  "Whether the waiter's PIN must be changed."
  pinMustChange: Boolean!

  "Whether the waiter's PIN is locked."
  pinLocked: Boolean!
}

type LoginPayload {
  "Authenticated user object."
  user: SSPUser!

  "Authentication token for the session."
  token: String

  "Whether two-factor authentication is required."
  requiresTwoFactor: Boolean!

  "Whether organization selection is required (multi-org users). Null during 2FA challenge phase."
  requiresOrganizationSelection: Boolean

  "Challenge token for two-factor authentication (only present if 2FA required)."
  challenge_token: String

  "Selector token for organization selection (only present if org selection required)."
  selection_token: String

  "List of organizations the user can select from (only present if org selection required)."
  organizations: [OrganizationOption!]

  "Token expiration time in seconds (for JWT TTL)."
  expires_in: Int

  "Trusted device token (only returned after successful login)."
  device_token: String
}

"Organization option for multi-org selection during login."
type OrganizationOption {
  "Organization ID."
  id: ID!

  "Organization name."
  name: String!

  "Organization UUID."
  uuid: String!
}

type AuthPayload {
  "Authentication token for the session."
  token: String!

  "Refresh token for renewing the session."
  refresh_token: String!

  "Token expiration time in seconds."
  expires_in: Int!
}

type AuthResult {
  "Whether the authentication attempt was successful."
  success: Boolean!

  "Message describing the authentication outcome."
  message: String!
}

"""
Response from guest order authentication.
Returns a short-lived JWT token for guest access to a specific order.
"""
type GuestAuthResponse {
  "JWT token for authenticated guest access (valid for 2 hours)."
  token: String!

  "Token expiration time in seconds."
  expiresIn: Int!

  "The order ID this token grants access to."
  orderId: String!
}

enum TwoFactorChannel {
  TOTP
  EMAIL
  SMS
  NONE
}

type EnableTwoFactorResponse {
  "Status of the two-factor enablement attempt."
  status: String!

  "QR code for setting up two-factor authentication (TOTP only)."
  qr_code: String

  "The 2FA channel that was enabled."
  channel: TwoFactorChannel!

  "User-friendly message about the 2FA setup."
  message: String!

  "Timestamp when the verification code expires (null for TOTP)."
  code_expires_at: DateTime

  "Timestamp when resend will be available (null for TOTP)."
  resend_available_at: DateTime
}

type VerifyTwoFactorResponse {
  "Whether the two-factor verification was successful."
  success: Boolean!

  "Status of the verification attempt."
  status: String!

  "Authentication token, if successful."
  token: String

  "Device token for \"Remember Device\" feature (if rememberDevice was true)."
  device_token: String

  "Whether organization selection is required (multi-org users)."
  requiresOrganizationSelection: Boolean

  "Selector token for organization selection (only present if org selection required)."
  selection_token: String

  "List of organizations the user can select from (only present if org selection required)."
  organizations: [OrganizationOption!]
}

type TwoFactorStatusResponse {
  "Whether two-factor authentication is enabled for the user."
  two_factor_enabled: Boolean!

  "The active 2FA channel (null if not enabled)."
  channel: TwoFactorChannel

  "Masked phone number for SMS 2FA (e.g., +1***5678, null if not using SMS or not enabled)."
  masked_phone: String

  "Timestamp when 2FA was confirmed."
  confirmed_at: DateTime

  "Number of remaining recovery codes."
  recovery_codes_remaining: Int!
}

type TwoFactorAvailabilityResponse {
  "Whether TOTP (authenticator app) is available."
  totp_available: Boolean!

  "Whether Email 2FA is available."
  email_available: Boolean!

  "Whether SMS 2FA is available (requires phone number)."
  sms_available: Boolean!

  "Current phone number on file (null if none)."
  phone_number: String

  "Whether a phone number needs to be provided for SMS 2FA."
  requires_phone_for_sms: Boolean!
}

type DisableTwoFactorResponse {
  "Status of the two-factor disablement attempt."
  status: String!
}

type ConfirmTwoFactorResponse {
  "Whether the two-factor confirmation was successful."
  success: Boolean!

  "Status of the confirmation attempt."
  status: String!

  "The confirmed 2FA channel."
  channel: TwoFactorChannel!

  "Timestamp when 2FA was confirmed."
  confirmed_at: DateTime!

  """
  Recovery codes (only returned once, immediately after successful confirmation). 
  Subsequent calls will return an empty list.
  """
  recoveryCodes: [String!]!
}

type RegenerateTwoFactorRecoveryCodesResponse {
  "Status of the regeneration attempt."
  status: String!

  "New recovery codes (only shown once)."
  recoveryCodes: [String!]!

  "Number of recovery codes generated."
  count: Int!
}

type ResendTwoFactorCodeResponse {
  "Status of the resend attempt."
  status: String!

  "Message describing the outcome."
  message: String!

  "Timestamp when the new verification code expires."
  code_expires_at: DateTime

  "Timestamp when the next resend will be available."
  resend_available_at: DateTime
}

type TrustedDevice {
  "Unique device ID."
  id: ID!

  "User-friendly device name (e.g., \"Chrome on MacOS\")."
  device_name: String

  "Last time this device was used."
  last_used_at: DateTime

  "When this device trust expires."
  expires_at: DateTime!

  "Whether this device is still active."
  is_active: Boolean!

  "IP address when device was registered."
  created_ip: String
}

type TrustedDevicesResponse {
  "List of active trusted devices."
  devices: [TrustedDevice!]!

  "Total count of active devices."
  count: Int!
}

type RevokeTrustedDeviceResponse {
  "Status of the revocation."
  status: String!

  "Whether the device was successfully revoked."
  success: Boolean!
}

type PasswordResetResponse {
  "Status of the password reset attempt."
  status: String!

  "Whether two-factor authentication is required after reset."
  requiresTwoFactorAuthentication: Boolean!
}

type PinPolicy {
  "ID of the location associated with the PIN policy."
  locationId: ID!

  "Minimum length of the PIN."
  minLength: Int!

  "Maximum length of the PIN."
  maxLength: Int!

  "Whether users can change their own PIN."
  allowSelfServiceChange: Boolean!

  "Whether users can reset their own PIN."
  allowSelfServiceReset: Boolean!

  "Maximum failed PIN attempts before cooldown."
  maxAttemptsBeforeCooldown: Int!

  "Cooldown period in seconds after max failed attempts."
  cooldownSeconds: Int!

  "Maximum failed attempts before account lock."
  maxAttemptsBeforeLock: Int!

  "Days after which PIN must be changed."
  requirePeriodicChangeDays: Int
}

type PinStatus {
  "Whether the user must change their PIN."
  mustChangePin: Boolean!

  "Timestamp of the last PIN change."
  lastChangedAt: DateTime

  "Number of failed PIN attempts."
  failedAttempts: Int!

  "Timestamp until which the account is locked due to failed attempts."
  lockedUntil: DateTime
}

type PinLoginResponse {
  "Authentication token issued after successful PIN login."
  token: String!
}

type PinVerifyResponse {
  "Whether the PIN verification was successful."
  authorized: Boolean!

  message: String
}

type PinResponse {
  "Message describing the outcome of an action on the PIN."
  message: String!
}

type GeneratePinResponse {
  "Message describing the outcome of PIN generation."
  message: String!

  "The generated PIN code (only returned to manager for fallback delivery)."
  pin: String!

  "Whether the PIN was successfully sent via email."
  sent_via_email: Boolean!

  "Whether the user's email is verified."
  email_verified: Boolean!
}

type ResetPinResponse {
  "Message describing the outcome of PIN reset."
  message: String!

  "The new PIN if generate_new was true."
  pin: String

  "Whether the new PIN was sent via email."
  sent_via_email: Boolean!
}

type ResendPinResponse {
  "Message describing the outcome."
  message: String!

  "Whether the PIN was sent via email."
  sent_via_email: Boolean!
}

type WaiterSession {
  "ID of the waiter associated with the session."
  waiterId: ID!

  "ID of the location, if applicable."
  locationId: ID

  "ID of the device used for the session."
  deviceId: ID

  "Timestamp when the session was issued."
  issuedAt: DateTime

  "Timestamp when the session expires."
  expiresAt: DateTime

  "Authentication method used (e.g., PIN or PASSWORD)."
  authMethod: String!
}

type UserCapabilities {
  "Whether the user can edit roles."
  canEditRoles: Boolean!

  "Whether the user can assign locations."
  canAssignLocations: Boolean!

  "Whether the user can assign location collections."
  canAssignCollections: Boolean!

  "Whether the user can update their status."
  canUpdateStatus: Boolean!

  "List of system roles the user is allowed to assign (e.g., WAIT_STAFF, LOCATION_MANAGER). Excludes SUPPORT_ADMIN."
  allowedRoles: [AssignableRoles!]!

  "List of custom roles the user is allowed to assign."
  allowedCustomRoles: [CustomRole!]!

  "List of locations the user is allowed to assign."
  allowedLocations: [SSPLocation!]!

  "List of location collections the user is allowed to assign."
  allowedCollections: [SSPLocCollection!]!
}

type Invitation {
  "Unique identifier for the invitation."
  id: Int!

  "Email address of the invited user."
  email: String!

  "ID of the user who sent the invitation."
  user_id: Int!

  "Unique code for the invitation."
  code: String!

  "ID of the role assigned to the invitation (Spatie role ID)."
  role_id: Int!

  "List of system role names associated with the invitation (empty if custom role)."
  role_names: [AssignableRoles]!

  "Custom role assigned to this invitation (null if system role)."
  customRole: CustomRole

  "Whether this invitation is for a custom role."
  isCustomRole: Boolean!

  "List of location collection IDs associated with the invitation."
  collection_ids: [Int]

  "List of location IDs associated with the invitation."
  location_ids: [Int]

  "Current status of the invitation (e.g., pending, accepted)."
  status: String

  "Timestamp until which the invitation is valid."
  valid_till: String
}

type DeleteInvitationPayload {
  "Status of the invitation deletion attempt."
  status: String
}

type ResendInvitationPayload {
  "Status of the invitation resend attempt."
  status: String
}

type CancelInvitationPayload {
  "Whether the invitation cancellation was successful."
  success: Boolean!

  "Message describing the cancellation outcome."
  message: String!
}

type UserWithRolesAndLocations {
  "User object with associated data."
  user: SSPUser!

  "List of collection IDs assigned to the user."
  collections: [Int!]

  "List of location IDs assigned to the user."
  locations: [Int!]
}

type RemoveMemberPayload {
  "Status of the member removal attempt."
  status: String

  "Message describing the removal outcome."
  message: String
}

type PaginatedUsers {
  "List of users in the current page."
  users: [SSPUser!]!

  "Total number of users."
  total: Int!

  "Current page number."
  page: Int!

  "Number of users per page."
  pageSize: Int!
}

type UserPermissionMatrix {
  "Role object."
  role: RestaurantRoles!

  "List of permissions directly assigned to the role."
  inheritedPermissions: [Permissions!]!

  "List of permissions effectively granted by the role (including inherited)."
  directPermissions: [Permissions!]!

  "List of all effective permissions for the role."
  effectivePermissions: [Permissions!]!
}

type SocialLoginResponse {
  user: SSPUser!
  token: String
  requiresTwoFactor: Boolean
  challenge_token: String

  "Whether organization selection is required (multi-org users)."
  requiresOrganizationSelection: Boolean

  "Selector token for organization selection (only present if org selection required)."
  selection_token: String

  "List of organizations the user can select from (only present if org selection required)."
  organizations: [OrganizationOption!]
}

type LinkSocialAccountResponse {
  user: SSPUser!
  provider: SocialProvider!
  provider_id: String!
}

type SocialAccount {
  id: ID!
  provider: SocialProvider!
  provider_id: String!
  provider_email: String
  provider_name: String
  provider_avatar: String
  user: SSPUser!
  created_at: DateTime!
  updated_at: DateTime!
}

"Represents a user's membership in an organization."
type UserOrganizationMembership {
  "Unique membership ID."
  id: ID!

  "The user who holds this membership."
  user: SSPUser!

  "The organization the user belongs to."
  organization: SSPOrganization!

  "Membership status (active, suspended, pending)."
  status: String!

  "When the user joined this organization."
  joinedAt: DateTime!
}

"Response from accepting an organization invitation."
type AcceptInvitationPayload {
  "Whether the invitation was successfully accepted."
  success: Boolean!

  "The organization that was joined."
  organization: SSPOrganization

  "Message describing the outcome."
  message: String!

  "Fresh selector token with the newly joined organization included in allowed_orgs."
  selection_token: String
}

"Result of validating an invitation token."
type InvitationValidationResult {
  "Whether the invitation token is valid."
  valid: Boolean!

  "Whether a user already exists with this email."
  userExists: Boolean!

  "The email address the invitation was sent to."
  email: String

  "Name of the organization the invitation is for."
  organizationName: String

  "ID of the organization the invitation is for."
  organizationId: ID

  "Name of the role that will be assigned."
  roleName: String

  "Error message if the invitation is invalid."
  errorMessage: String
}

"Support session status for filtering"
enum SupportSessionStatus {
  "Session is currently active (not expired and not ended)"
  ACTIVE

  "Session was manually ended by the support user"
  ENDED

  "Session auto-expired due to time limit"
  EXPIRED
}

"Input for creating a support session"
input CreateSupportSessionInput {
  "ID of the customer organization to access"
  organizationId: ID!

  """
  Detailed reason for accessing the organization.
  This will be visible to the customer in their transaction logs.
  Minimum 20 characters required.
  """
  reason: String!

  """
  Optional Jira ticket ID (e.g., "SUPPORT-1234").
  If Jira integration is enabled, ticket will be validated.
  """
  ticketId: String

  """
  Session duration in hours (default: 4, max: 24).
  Session will auto-expire after this duration.
  """
  durationHours: Int = 4
}

"Response from creating a support session"
type CreateSupportSessionPayload {
  "The created support session"
  session: SupportSession!

  "Human-readable success message"
  message: String!
}

"Response from ending a support session"
type EndSupportSessionPayload {
  "Whether the operation was successful"
  success: Boolean!

  "The ended support session"
  session: SupportSession!

  "Human-readable success message"
  message: String!
}

"Response from switching support sessions"
type SwitchSupportSessionPayload {
  "The newly focused support session"
  session: SupportSession!

  "Human-readable success message"
  message: String!
}

"""
Support Session
Represents a time-limited session where a support admin accesses a customer organization.
"""
type SupportSession {
  "Unique session ID"
  id: ID!

  "Support team member who created this session"
  supportUser: SSPUser!

  "Customer organization being accessed"
  organization: SSPOrganization!

  "Jira ticket reference (optional)"
  ticketId: String

  "Reason for accessing the organization"
  reason: String!

  "When the session started"
  startedAt: DateTime!

  "When the session will auto-expire"
  endsAt: DateTime!

  "When the session was manually ended (null if still active or auto-expired)"
  endedAt: DateTime

  "Session duration in minutes"
  durationMinutes: Int!

  "Whether the session is currently active (not expired and not ended)"
  isActive: Boolean!

  "Session status (ACTIVE, ENDED, EXPIRED) - computed from isActive and endedAt"
  status: String!

  "Total count of actions performed during this session"
  actionsCount: Int!

  """
  IP address of the support user
  **SUPPORT_ADMIN ONLY**
  """
  ipAddress: String

  """
  Browser/client user agent
  **SUPPORT_ADMIN ONLY**
  """
  userAgent: String

  """
  Actions performed during this session (paginated)
  **SUPPORT_ADMIN ONLY**
  """
  actions(page: Int = 1, limit: Int = 20): SupportActionLogPaginator

  """
  Recent actions (non-paginated, for quick access)
  **SUPPORT_ADMIN ONLY**
  """
  recentActions(limit: Int = 10): [SupportActionLog!]!

  "When the record was created"
  createdAt: DateTime!

  "When the record was last updated"
  updatedAt: DateTime!
}

"""
Support Action Log
Represents a single action performed during a support session.
"""
type SupportActionLog {
  "Unique log entry ID"
  id: ID!

  "Support session this action belongs to"
  session: SupportSession!

  "Support user who performed the action"
  supportUser: SSPUser!

  "Customer organization being accessed"
  organization: SSPOrganization!

  "Action type identifier (e.g., \"POST /graphql\", \"GraphQL: viewerOrganization\")"
  action: String!

  "Human-readable description of the action"
  description: String!

  """
  Additional action metadata as JSON
  **SUPPORT_ADMIN ONLY**
  """
  data: JSON

  "IP address when action occurred"
  ipAddress: String

  "When the action was performed"
  createdAt: DateTime!
}

"Paginated list of organizations"
type OrganizationPaginator {
  "List of organizations for current page"
  data: [SSPOrganization!]!

  "Pagination information"
  paginatorInfo: PaginatorInfo!
}

"Paginated list of support sessions"
type SupportSessionPaginator {
  "List of support sessions for current page"
  data: [SupportSession!]!

  "Pagination information"
  paginatorInfo: PaginatorInfo!
}

"Paginated list of support action logs"
type SupportActionLogPaginator {
  "List of action logs for current page"
  data: [SupportActionLog!]!

  "Pagination information"
  paginatorInfo: PaginatorInfo!
}

"Plugin integration for marketplace"
type PluginIntegration {
  id: ID!
  organization_id: ID
  organization: SSPOrganization

  "Unique identifier (slug)"
  name: String!

  display_name: String!
  description: String
  plugin_type: PluginType!
  integration_type: IntegrationType!
  status: PluginStatus!
  visibility: PluginVisibility!

  "API Configuration"
  api_endpoint: String!

  webhook_endpoint: String
  documentation_url: String
  icon_url: String

  "Additional Info"
  version: String

  screenshots: [String!]
  pricing_model: String
  developer_website: String

  "Authentication"
  auth_type: String!

  "Capabilities"
  supported_features: [String!]

  supported_currencies: [String!]
  supported_regions: [String!]

  "Webhook Event Subscriptions"
  supported_events: [String!]

  "Provider Information"
  developer_name: String!

  developer_email: String!

  "Certification & Marketplace"
  is_certified: Boolean!

  certification_level: String
  certification_details: JSON
  is_featured: Boolean!
  is_published: Boolean!
  is_active: Boolean!

  "Statistics"
  average_rating: Float

  review_count: Int!
  install_count: Int!

  "Lifecycle Dates"
  submitted_at: DateTime

  approved_at: DateTime
  rejected_at: DateTime
  published_at: DateTime
  suspended_at: DateTime
  deprecated_at: DateTime

  "Timestamps"
  created_at: DateTime!

  updated_at: DateTime!
  deleted_at: DateTime

  "Relationships"
  installations: [PluginInstallation!]!

  reviews: [PluginReview!]!
  changelog: [PluginChangelog!]!
}

"Plugin installation instance"
type PluginInstallation {
  id: ID!
  plugin_integration_id: ID!
  organization_id: ID!
  location_id: ID
  plugin: PluginIntegration!
  organization: SSPOrganization!
  location: SSPLocation
  status: String!
  health_status: String
  configuration: JSON

  "Statistics"
  total_requests: Int!

  successful_requests: Int!
  failed_requests: Int!
  last_request_at: DateTime

  "Subscription"
  subscription_status: String

  monthly_cost: String
  installed_at: DateTime!
  uninstalled_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!

  "API key for plugin data access (only returned on install, not persisted)"
  api_key: String
}

"Plugin review"
type PluginReview {
  id: ID!
  plugin_integration_id: ID!
  organization_id: ID!
  plugin: PluginIntegration!
  organization: SSPOrganization!
  rating: Int!
  review: String
  created_at: DateTime!
  updated_at: DateTime!
}

"Plugin changelog entry"
type PluginChangelog {
  id: ID!
  plugin_integration_id: ID!
  plugin: PluginIntegration!
  version: String!
  release_notes: String!
  breaking_changes: Boolean!
  published_at: DateTime!
}

enum PluginType {
  payment
  delivery
  inventory
  accounting
  marketing
  analytics
  hr
  reservation
  loyalty
}

enum IntegrationType {
  rest_api
  oauth2
  webhook
  graphql
  soap
}

enum PluginStatus {
  draft
  submitted
  in_review
  approved
  rejected
  active
  suspended
  deprecated
}

enum PluginVisibility {
  private
  organization
  public
}

input SubmitPluginIntegrationInput {
  name: String!
  display_name: String!
  description: String
  plugin_type: PluginType!
  integration_type: IntegrationType!

  "API Configuration"
  api_endpoint: String!
  webhook_endpoint: String
  documentation_url: String
  icon_url: String

  "Capabilities"
  supported_features: [String!]
  supported_currencies: [String!]
  supported_regions: [String!]

  "Webhook Event Subscriptions (e.g., order.created, payment.*, menu.item_updated)"
  supported_events: [String!]

  "Authentication"
  auth_type: String!
  api_key: String!

  "Developer Info"
  developer_name: String!
  developer_email: String!

  "Visibility"
  visibility: PluginVisibility
}

input UpdatePluginIntegrationInput {
  display_name: String
  description: String
  api_endpoint: String
  webhook_endpoint: String
  documentation_url: String
  icon_url: String
  supported_features: [String!]
  supported_currencies: [String!]
  supported_regions: [String!]

  "Webhook Event Subscriptions (e.g., order.created, payment.*, menu.item_updated)"
  supported_events: [String!]
}

"Available webhook event definition"
type PluginWebhookEventDefinition {
  event: String!
  description: String!
}

"Input for installing a plugin"
input InstallPluginInput {
  plugin_id: ID!
  location_id: ID
  config: JSON
}

"Response from installPlugin mutation"
type InstallPluginResponse {
  success: Boolean!
  message: String!
  installation: PluginInstallation
  api_key: String
}

"Response from uninstallPlugin mutation"
type UninstallPluginResponse {
  success: Boolean!
  message: String!
}

scalar Date

scalar JSON

scalar Upload

"""
DateTime scalar for handling timestamps across timezones.

## Architecture

**Storage:** All timestamps are stored in the database as UTC.

**Outputs:** All DateTime fields are returned as ISO 8601 strings WITH timezone offset,
representing the location's configured timezone. The offset makes the value self-documenting.
Example: `2024-01-15T14:30:00-05:00` (Eastern Time)

**Inputs:** Accepts ISO 8601 format. Best practice is to include the timezone offset:
- With offset (preferred): `2024-01-15T14:30:00-05:00`
- UTC: `2024-01-15T19:30:00Z`
- Without offset: `2024-01-15 14:30:00` (interpreted based on query context)

## For Date Range Queries

When sending date ranges (startDate/endDate), always include the timezone offset:
- Correct: `2024-01-15T00:00:00-05:00` to `2024-01-15T23:59:59-05:00`
- Also valid: `2024-01-15T05:00:00Z` to `2024-01-16T04:59:59Z` (UTC)

Business day boundaries respect the location's timezone. A "daily report" for a Toronto
restaurant means midnight-to-midnight Toronto time, not UTC.

## Exception

`itemSalesReport` uses UTC explicitly for both input and output for performance reasons.
See its field documentation for details.
"""
scalar DateTime

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
  "Number of items in the current page."
  count: Int!

  "Index of the current page."
  currentPage: Int!

  "Index of the first item in the current page."
  firstItem: Int

  "Are there more pages after this one?"
  hasMorePages: Boolean!

  "Index of the last item in the current page."
  lastItem: Int

  "Index of the last available page."
  lastPage: Int!

  "Number of items per page."
  perPage: Int!

  "Number of total available items."
  total: Int!
}

"A paginated list of SSPTableOrderItem items."
type SSPTableOrderItemPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of SSPTableOrderItem items."
  data: [SSPTableOrderItem!]!
}

"A paginated list of SSPMenuItem items."
type SSPMenuItemPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of SSPMenuItem items."
  data: [SSPMenuItem!]!
}

"A paginated list of SSPProfile items."
type SSPProfilePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of SSPProfile items."
  data: [SSPProfile!]!
}

"A paginated list of SSPOrderCustomer items."
type SSPOrderCustomerPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of SSPOrderCustomer items."
  data: [SSPOrderCustomer!]!
}

"A paginated list of PluginIntegration items."
type PluginIntegrationPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of PluginIntegration items."
  data: [PluginIntegration!]!
}

"Directions for ordering a list of records."
enum SortOrder {
  "Sort records in ascending order."
  ASC

  "Sort records in descending order."
  DESC
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
  "Amount of items."
  COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
  "Average."
  AVG

  "Minimum."
  MIN

  "Maximum."
  MAX

  "Sum."
  SUM

  "Amount of items."
  COUNT
}

"Allows ordering a list of records."
input OrderByClause {
  "The column that is used for ordering."
  column: String!

  "The direction that is used for ordering."
  order: SortOrder!
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
  "Only return trashed results."
  ONLY

  "Return both trashed and non-trashed results."
  WITH

  "Only return non-trashed results."
  WITHOUT
}

